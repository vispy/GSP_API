{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"GSP Documentation","text":"<p>This is your documentation homepage.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#overview","title":"Overview","text":"<p>This page provides information about the project.</p>"},{"location":"about/#description","title":"Description","text":"<p>Add your description here.</p>"},{"location":"about/#contact","title":"Contact","text":"<p>For questions or support, please contact us.</p>"},{"location":"api/gsp/","title":"GSP API Reference","text":"<p>The Graphic Server Protocol (GSP) API provides a unified interface for creating and rendering graphics across different backends.</p>"},{"location":"api/gsp/#core-module","title":"Core Module","text":""},{"location":"api/gsp/#gsp.core.canvas","title":"<code>gsp.core.canvas</code>","text":""},{"location":"api/gsp/#gsp.core.canvas.Canvas","title":"<code>Canvas</code>","text":"Source code in <code>src/gsp/core/canvas.py</code> <pre><code>class Canvas:\n    __slots__ = [\"_uuid\", \"_width\", \"_height\", \"_dpi\", \"userData\"]\n\n    def __init__(self, width: int, height: int, dpi: float):\n        \"\"\"Create a new Canvas object with the given width, height, and dpi.\n\n        Args:\n            width (int): Width of the canvas in pixels.\n            height (int): Height of the canvas in pixels.\n            dpi (float): Dots per inch (DPI) of the canvas.\n        \"\"\"\n        self._uuid: str = UuidUtils.generate_uuid()\n        self._width: int = width\n        self._height: int = height\n        self._dpi: float = dpi\n        self.userData: dict[str, Any] = {}\n\n    def __repr__(self) -&gt; str:\n        return f\"Canvas(width={self._width}, height={self._height}, dpi={self._dpi})\"\n\n    def get_uuid(self) -&gt; str:\n        return self._uuid\n\n    def get_width(self) -&gt; int:\n        return self._width\n\n    def set_width(self, width: int) -&gt; None:\n        self._width = width\n\n    def get_height(self) -&gt; int:\n        return self._height\n\n    def set_height(self, height: int) -&gt; None:\n        self._height = height\n\n    def get_dpi(self) -&gt; float:\n        return self._dpi\n\n    def set_dpi(self, dpi: float) -&gt; None:\n        self._dpi = dpi\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.__init__","title":"<code>__init__(width: int, height: int, dpi: float)</code>","text":"<p>Create a new Canvas object with the given width, height, and dpi.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the canvas in pixels.</p> required <code>height</code> <code>int</code> <p>Height of the canvas in pixels.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch (DPI) of the canvas.</p> required Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def __init__(self, width: int, height: int, dpi: float):\n    \"\"\"Create a new Canvas object with the given width, height, and dpi.\n\n    Args:\n        width (int): Width of the canvas in pixels.\n        height (int): Height of the canvas in pixels.\n        dpi (float): Dots per inch (DPI) of the canvas.\n    \"\"\"\n    self._uuid: str = UuidUtils.generate_uuid()\n    self._width: int = width\n    self._height: int = height\n    self._dpi: float = dpi\n    self.userData: dict[str, Any] = {}\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport","title":"<code>gsp.core.viewport</code>","text":""},{"location":"api/gsp/#gsp.core.viewport.Viewport","title":"<code>Viewport</code>","text":"Source code in <code>src/gsp/core/viewport.py</code> <pre><code>class Viewport:\n    __slots__ = [\"_uuid\", \"_x\", \"_y\", \"_width\", \"_height\", \"userData\"]\n\n    def __init__(self, x: int, y: int, width: int, height: int):\n        \"\"\"\n        Create a viewport.\n\n        Args:\n            x (int): The x offset (in pixels from left) of the viewport.\n            y (int): The y offset (in pixels from bottom) of the viewport.\n            width (int): The width (in pixels) of the viewport.\n            height (int): The height (in pixels) of the viewport.\n        \"\"\"\n        self._uuid: str = UuidUtils.generate_uuid()\n        self._x: int = x\n        self._y: int = y\n        self._width: int = width\n        self._height: int = height\n        self.userData: dict[str, Any] = {}\n\n    def __repr__(self) -&gt; str:\n        return f\"Viewport(x={self._x}, y={self._y}, width={self._width}, height={self._height})\"\n\n    def get_uuid(self) -&gt; str:\n        \"\"\"Get the unique identifier of the viewport.\n\n        Returns:\n            str: The unique identifier.\n        \"\"\"\n        return self._uuid\n\n    def get_x(self) -&gt; int:\n        \"\"\"\n        Get the x offset (in pixels from left) of the viewport.\n\n        Returns:\n            int: The x offset.\n        \"\"\"\n        return self._x\n\n    def set_x(self, x: int) -&gt; None:\n        \"\"\"\n        Set the x offset (in pixels from left) of the viewport.\n\n        Args:\n            x (int): The new x offset.\n        \"\"\"\n        self._x = x\n\n    def get_y(self) -&gt; int:\n        \"\"\"\n        Get the y offset (in pixels from bottom) of the viewport.\n\n        Returns:\n            int: The y offset.\n        \"\"\"\n        return self._y\n\n    def set_y(self, y: int) -&gt; None:\n        \"\"\"\n        Set the y offset (in pixels from bottom) of the viewport.\n\n        Args:\n            y (int): The new y offset.\n        \"\"\"\n        self._y = y\n\n    def get_width(self) -&gt; int:\n        \"\"\"\n        Get the width (in pixels) of the viewport.\n\n        Returns:\n            int: The width.\n        \"\"\"\n        return self._width\n\n    def set_width(self, width: int) -&gt; None:\n        \"\"\"\n        Set the width (in pixels) of the viewport.\n\n        Args:\n            width (int): The new width.\n        \"\"\"\n        self._width = width\n\n    def get_height(self) -&gt; int:\n        \"\"\"\n        Get the height (in pixels) of the viewport.\n\n        Returns:\n            int: The height.\n        \"\"\"\n        return self._height\n\n    def set_height(self, height: int) -&gt; None:\n        \"\"\"\n        Set the height (in pixels) of the viewport.\n\n        Args:\n            height (int): The new height.\n        \"\"\"\n        self._height = height\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.__init__","title":"<code>__init__(x: int, y: int, width: int, height: int)</code>","text":"<p>Create a viewport.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The x offset (in pixels from left) of the viewport.</p> required <code>y</code> <code>int</code> <p>The y offset (in pixels from bottom) of the viewport.</p> required <code>width</code> <code>int</code> <p>The width (in pixels) of the viewport.</p> required <code>height</code> <code>int</code> <p>The height (in pixels) of the viewport.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def __init__(self, x: int, y: int, width: int, height: int):\n    \"\"\"\n    Create a viewport.\n\n    Args:\n        x (int): The x offset (in pixels from left) of the viewport.\n        y (int): The y offset (in pixels from bottom) of the viewport.\n        width (int): The width (in pixels) of the viewport.\n        height (int): The height (in pixels) of the viewport.\n    \"\"\"\n    self._uuid: str = UuidUtils.generate_uuid()\n    self._x: int = x\n    self._y: int = y\n    self._width: int = width\n    self._height: int = height\n    self.userData: dict[str, Any] = {}\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_height","title":"<code>get_height() -&gt; int</code>","text":"<p>Get the height (in pixels) of the viewport.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The height.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_height(self) -&gt; int:\n    \"\"\"\n    Get the height (in pixels) of the viewport.\n\n    Returns:\n        int: The height.\n    \"\"\"\n    return self._height\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_uuid","title":"<code>get_uuid() -&gt; str</code>","text":"<p>Get the unique identifier of the viewport.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_uuid(self) -&gt; str:\n    \"\"\"Get the unique identifier of the viewport.\n\n    Returns:\n        str: The unique identifier.\n    \"\"\"\n    return self._uuid\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_width","title":"<code>get_width() -&gt; int</code>","text":"<p>Get the width (in pixels) of the viewport.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The width.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_width(self) -&gt; int:\n    \"\"\"\n    Get the width (in pixels) of the viewport.\n\n    Returns:\n        int: The width.\n    \"\"\"\n    return self._width\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_x","title":"<code>get_x() -&gt; int</code>","text":"<p>Get the x offset (in pixels from left) of the viewport.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The x offset.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_x(self) -&gt; int:\n    \"\"\"\n    Get the x offset (in pixels from left) of the viewport.\n\n    Returns:\n        int: The x offset.\n    \"\"\"\n    return self._x\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_y","title":"<code>get_y() -&gt; int</code>","text":"<p>Get the y offset (in pixels from bottom) of the viewport.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The y offset.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_y(self) -&gt; int:\n    \"\"\"\n    Get the y offset (in pixels from bottom) of the viewport.\n\n    Returns:\n        int: The y offset.\n    \"\"\"\n    return self._y\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.set_height","title":"<code>set_height(height: int) -&gt; None</code>","text":"<p>Set the height (in pixels) of the viewport.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>The new height.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def set_height(self, height: int) -&gt; None:\n    \"\"\"\n    Set the height (in pixels) of the viewport.\n\n    Args:\n        height (int): The new height.\n    \"\"\"\n    self._height = height\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.set_width","title":"<code>set_width(width: int) -&gt; None</code>","text":"<p>Set the width (in pixels) of the viewport.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The new width.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def set_width(self, width: int) -&gt; None:\n    \"\"\"\n    Set the width (in pixels) of the viewport.\n\n    Args:\n        width (int): The new width.\n    \"\"\"\n    self._width = width\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.set_x","title":"<code>set_x(x: int) -&gt; None</code>","text":"<p>Set the x offset (in pixels from left) of the viewport.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The new x offset.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def set_x(self, x: int) -&gt; None:\n    \"\"\"\n    Set the x offset (in pixels from left) of the viewport.\n\n    Args:\n        x (int): The new x offset.\n    \"\"\"\n    self._x = x\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.set_y","title":"<code>set_y(y: int) -&gt; None</code>","text":"<p>Set the y offset (in pixels from bottom) of the viewport.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>int</code> <p>The new y offset.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def set_y(self, y: int) -&gt; None:\n    \"\"\"\n    Set the y offset (in pixels from bottom) of the viewport.\n\n    Args:\n        y (int): The new y offset.\n    \"\"\"\n    self._y = y\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera","title":"<code>gsp.core.camera</code>","text":""},{"location":"api/gsp/#gsp.core.camera.Camera","title":"<code>Camera</code>","text":"Source code in <code>src/gsp/core/camera.py</code> <pre><code>class Camera:\n    __slots__ = [\"_uuid\", \"_view_matrix\", \"_projection_matrix\", \"userData\"]\n\n    def __init__(self, view_matrix: TransBuf, projection_matrix: TransBuf):\n        \"\"\"Initialize a Camera instance. Just a container for view and projection matrices.\n\n        Args:\n            view_matrix (TransBuf): View matrix - [view-matrix](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-view-matrix)\n            projection_matrix (TransBuf): Projection matrix - [projection-matrix](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-projection-matrix)\n        \"\"\"\n        self._uuid: str = UuidUtils.generate_uuid()\n        self._view_matrix: TransBuf = view_matrix\n        self._projection_matrix: TransBuf = projection_matrix\n        self.userData: dict[str, Any] = {}\n        \"\"\"A dictionary for storing custom user data associated with the Camera instance.\"\"\"\n\n    def __repr__(self) -&gt; str:\n        return f\"Camera(uuid={self._uuid})\"\n\n    def get_uuid(self) -&gt; str:\n        \"\"\"Get the UUID of the Camera instance.\n\n        Returns:\n            str: The UUID of the Camera.\n        \"\"\"\n        return self._uuid\n\n    def set_view_matrix(self, view_matrix: TransBuf):\n        \"\"\"Set the view matrix of the Camera.\n\n        Args:\n            view_matrix (TransBuf): The new view matrix.\n        \"\"\"\n        self._view_matrix = view_matrix\n\n    def get_view_matrix(self) -&gt; TransBuf:\n        \"\"\"Get the view matrix of the Camera.\n\n        Returns:\n            TransBuf: The view matrix.\n        \"\"\"\n        return self._view_matrix\n\n    def set_projection_matrix(self, projection_matrix: TransBuf):\n        \"\"\"Set the projection matrix of the Camera.\n\n        Args:\n            projection_matrix (TransBuf): The new projection matrix.\n        \"\"\"\n        self._projection_matrix = projection_matrix\n\n    def get_projection_matrix(self) -&gt; TransBuf:\n        \"\"\"Get the projection matrix of the Camera.\n\n        Returns:\n            TransBuf: The projection matrix.\n        \"\"\"\n        return self._projection_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.userData","title":"<code>userData: dict[str, Any] = {}</code>  <code>instance-attribute</code>","text":"<p>A dictionary for storing custom user data associated with the Camera instance.</p>"},{"location":"api/gsp/#gsp.core.camera.Camera.__init__","title":"<code>__init__(view_matrix: TransBuf, projection_matrix: TransBuf)</code>","text":"<p>Initialize a Camera instance. Just a container for view and projection matrices.</p> <p>Parameters:</p> Name Type Description Default <code>view_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>View matrix - view-matrix</p> required <code>projection_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>Projection matrix - projection-matrix</p> required Source code in <code>src/gsp/core/camera.py</code> <pre><code>def __init__(self, view_matrix: TransBuf, projection_matrix: TransBuf):\n    \"\"\"Initialize a Camera instance. Just a container for view and projection matrices.\n\n    Args:\n        view_matrix (TransBuf): View matrix - [view-matrix](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-view-matrix)\n        projection_matrix (TransBuf): Projection matrix - [projection-matrix](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-projection-matrix)\n    \"\"\"\n    self._uuid: str = UuidUtils.generate_uuid()\n    self._view_matrix: TransBuf = view_matrix\n    self._projection_matrix: TransBuf = projection_matrix\n    self.userData: dict[str, Any] = {}\n    \"\"\"A dictionary for storing custom user data associated with the Camera instance.\"\"\"\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.get_projection_matrix","title":"<code>get_projection_matrix() -&gt; TransBuf</code>","text":"<p>Get the projection matrix of the Camera.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The projection matrix.</p> Source code in <code>src/gsp/core/camera.py</code> <pre><code>def get_projection_matrix(self) -&gt; TransBuf:\n    \"\"\"Get the projection matrix of the Camera.\n\n    Returns:\n        TransBuf: The projection matrix.\n    \"\"\"\n    return self._projection_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.get_uuid","title":"<code>get_uuid() -&gt; str</code>","text":"<p>Get the UUID of the Camera instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The UUID of the Camera.</p> Source code in <code>src/gsp/core/camera.py</code> <pre><code>def get_uuid(self) -&gt; str:\n    \"\"\"Get the UUID of the Camera instance.\n\n    Returns:\n        str: The UUID of the Camera.\n    \"\"\"\n    return self._uuid\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.get_view_matrix","title":"<code>get_view_matrix() -&gt; TransBuf</code>","text":"<p>Get the view matrix of the Camera.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The view matrix.</p> Source code in <code>src/gsp/core/camera.py</code> <pre><code>def get_view_matrix(self) -&gt; TransBuf:\n    \"\"\"Get the view matrix of the Camera.\n\n    Returns:\n        TransBuf: The view matrix.\n    \"\"\"\n    return self._view_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.set_projection_matrix","title":"<code>set_projection_matrix(projection_matrix: TransBuf)</code>","text":"<p>Set the projection matrix of the Camera.</p> <p>Parameters:</p> Name Type Description Default <code>projection_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new projection matrix.</p> required Source code in <code>src/gsp/core/camera.py</code> <pre><code>def set_projection_matrix(self, projection_matrix: TransBuf):\n    \"\"\"Set the projection matrix of the Camera.\n\n    Args:\n        projection_matrix (TransBuf): The new projection matrix.\n    \"\"\"\n    self._projection_matrix = projection_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.set_view_matrix","title":"<code>set_view_matrix(view_matrix: TransBuf)</code>","text":"<p>Set the view matrix of the Camera.</p> <p>Parameters:</p> Name Type Description Default <code>view_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new view matrix.</p> required Source code in <code>src/gsp/core/camera.py</code> <pre><code>def set_view_matrix(self, view_matrix: TransBuf):\n    \"\"\"Set the view matrix of the Camera.\n\n    Args:\n        view_matrix (TransBuf): The new view matrix.\n    \"\"\"\n    self._view_matrix = view_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.event","title":"<code>gsp.core.event</code>","text":""},{"location":"api/gsp/#gsp.core.event.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>typing.Generic[gsp.core.event.Callback]</code></p> <p>A simple, standalone event implementation with subscribe and dispatch methods.</p> <p>This class allows for a \"one-to-many\" communication pattern where a single event can notify multiple listeners (subscribers) that an action has occurred.</p> <p>The generic type <code>Callback</code> allows the event to be type-hinted with the specific signature of the functions it will dispatch to, ensuring type safety.</p> Source code in <code>src/gsp/core/event.py</code> <pre><code>class Event(Generic[Callback]):\n    \"\"\"\n    A simple, standalone event implementation with subscribe and dispatch methods.\n\n    This class allows for a \"one-to-many\" communication pattern where a single event\n    can notify multiple listeners (subscribers) that an action has occurred.\n\n    The generic type `Callback` allows the event to be type-hinted with the\n    specific signature of the functions it will dispatch to, ensuring type safety.\n    \"\"\"\n\n    def __init__(self):\n        # A list to store the subscribed callback functions.\n        self._callbacks: list[Callback] = []\n\n    def subscribe(self, callback: Callback) -&gt; None:\n        \"\"\"\n        Subscribes a callback to the event.\n\n        Args:\n            callback (Callback): The function to be called when the event is dispatched.\n                      Its signature should match the event's generic type.\n        \"\"\"\n        self._callbacks.append(callback)\n\n    def unsubscribe(self, callback: Callback) -&gt; None:\n        \"\"\"\n        Unsubscribes a previously subscribed callback from the event.\n\n        Args:\n            callback (Callback): The function to be removed from the event's subscribers.\n        \"\"\"\n        self._callbacks.remove(callback)\n\n    def dispatch(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Dispatches the event, calling all subscribed callbacks with the given arguments.\n\n        Args:\n            *args (Any): Positional arguments to pass to the callbacks.\n            **kwargs (Any): Keyword arguments to pass to the callbacks.\n        \"\"\"\n        for callback in self._callbacks:\n            callback(*args, **kwargs)\n\n    def event_listener(self, callback: Callback) -&gt; Callback:\n        \"\"\"\n        Decorator to subscribe a function to the event. This is a convenience method.\n        It still ensure static type checking on the decorated function.\n\n        **NOTE**: it is possible to unsubscribe the function later using `event.unsubscribe(handler)`.\n\n        Usage:\n            @event.subscriber\n            def handler(...): ...\n\n        Args:\n            callback (Callback): The function to be subscribed.\n\n        Returns:\n            Callback: The same function that was passed in.\n        \"\"\"\n        self.subscribe(callback)\n        return callback\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.dispatch","title":"<code>dispatch(*args: Any, **kwargs: Any) -&gt; None</code>","text":"<p>Dispatches the event, calling all subscribed callbacks with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>typing.Any</code> <p>Positional arguments to pass to the callbacks.</p> <code>()</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments to pass to the callbacks.</p> <code>{}</code> Source code in <code>src/gsp/core/event.py</code> <pre><code>def dispatch(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Dispatches the event, calling all subscribed callbacks with the given arguments.\n\n    Args:\n        *args (Any): Positional arguments to pass to the callbacks.\n        **kwargs (Any): Keyword arguments to pass to the callbacks.\n    \"\"\"\n    for callback in self._callbacks:\n        callback(*args, **kwargs)\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.event_listener","title":"<code>event_listener(callback: Callback) -&gt; Callback</code>","text":"<p>Decorator to subscribe a function to the event. This is a convenience method. It still ensure static type checking on the decorated function.</p> <p>NOTE: it is possible to unsubscribe the function later using <code>event.unsubscribe(handler)</code>.</p> Usage <p>@event.subscriber def handler(...): ...</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>gsp.core.event.Callback</code> <p>The function to be subscribed.</p> required <p>Returns:</p> Name Type Description <code>Callback</code> <code>gsp.core.event.Callback</code> <p>The same function that was passed in.</p> Source code in <code>src/gsp/core/event.py</code> <pre><code>def event_listener(self, callback: Callback) -&gt; Callback:\n    \"\"\"\n    Decorator to subscribe a function to the event. This is a convenience method.\n    It still ensure static type checking on the decorated function.\n\n    **NOTE**: it is possible to unsubscribe the function later using `event.unsubscribe(handler)`.\n\n    Usage:\n        @event.subscriber\n        def handler(...): ...\n\n    Args:\n        callback (Callback): The function to be subscribed.\n\n    Returns:\n        Callback: The same function that was passed in.\n    \"\"\"\n    self.subscribe(callback)\n    return callback\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.subscribe","title":"<code>subscribe(callback: Callback) -&gt; None</code>","text":"<p>Subscribes a callback to the event.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>gsp.core.event.Callback</code> <p>The function to be called when the event is dispatched.       Its signature should match the event's generic type.</p> required Source code in <code>src/gsp/core/event.py</code> <pre><code>def subscribe(self, callback: Callback) -&gt; None:\n    \"\"\"\n    Subscribes a callback to the event.\n\n    Args:\n        callback (Callback): The function to be called when the event is dispatched.\n                  Its signature should match the event's generic type.\n    \"\"\"\n    self._callbacks.append(callback)\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.unsubscribe","title":"<code>unsubscribe(callback: Callback) -&gt; None</code>","text":"<p>Unsubscribes a previously subscribed callback from the event.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>gsp.core.event.Callback</code> <p>The function to be removed from the event's subscribers.</p> required Source code in <code>src/gsp/core/event.py</code> <pre><code>def unsubscribe(self, callback: Callback) -&gt; None:\n    \"\"\"\n    Unsubscribes a previously subscribed callback from the event.\n\n    Args:\n        callback (Callback): The function to be removed from the event's subscribers.\n    \"\"\"\n    self._callbacks.remove(callback)\n</code></pre>"},{"location":"api/gsp/#types-module","title":"Types Module","text":""},{"location":"api/gsp/#gsp.types.buffer","title":"<code>gsp.types.buffer</code>","text":""},{"location":"api/gsp/#gsp.types.buffer.Buffer","title":"<code>Buffer</code>","text":"<p>typed array with single dimension - it is immutable in count and type, but mutable in content</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>class Buffer:\n    \"\"\"typed array with single dimension\n    - it is immutable in count and type, but mutable in content\n    \"\"\"\n\n    def __init__(self, count: int, buffer_type: BufferType) -&gt; None:\n        \"\"\"Initialize a Buffer instance.\n\n        Args:\n            count (int): The number of elements in the buffer.\n            buffer_type (BufferType): The type of elements in the buffer.\n        \"\"\"\n        item_size = BufferType.get_item_size(buffer_type)\n        self._count: int = count\n        self._type: BufferType = buffer_type\n        self._bytearray: bytearray = bytearray(count * item_size)\n\n    def __repr__(self) -&gt; str:\n        return f\"Buffer(count={self._count}, type={self._type})\"\n\n    def get_count(self) -&gt; int:\n        \"\"\"Return the number of elements in the buffer.\n\n        Returns:\n            int: The number of elements.\n        \"\"\"\n        return self._count\n\n    def get_type(self) -&gt; BufferType:\n        \"\"\"Return the type of each element in the buffer.\n\n        Returns:\n            BufferType: The buffer type.\n        \"\"\"\n        return self._type\n\n    # =============================================================================\n    # .get_data/.set_data\n    # =============================================================================\n\n    def get_data(self, offset: int, count: int) -&gt; \"Buffer\":\n        \"\"\"Return a buffer of count elements starting from offset.\n\n        Args:\n            offset (int): The starting index.\n            count (int): The number of elements to retrieve.\n\n        Returns:\n            Buffer: A new Buffer containing the requested data.\n        \"\"\"\n        item_size = BufferType.get_item_size(self._type)\n        start = offset * item_size\n        end = start + count * item_size\n\n        new_buffer = Buffer(count, self._type)\n        new_buffer.set_data(self._bytearray[start:end], 0, count)\n        return new_buffer\n\n    def set_data(self, _bytearray: bytearray, offset: int, count: int) -&gt; None:\n        \"\"\"Copy count elements starting from offset in the source bytearray.\n\n        Args:\n            _bytearray (bytearray): The source bytearray containing data to copy.\n            offset (int): The starting index in the buffer where data will be copied.\n            count (int): The number of elements to copy.\n        \"\"\"\n        item_size = BufferType.get_item_size(self._type)\n\n        # sanity check\n        assert offset + count &lt;= self._count, f\"Invalid offset {offset} and count {count} for buffer of size {self._count}\"\n\n        start = offset * item_size\n        end = start + count * item_size\n        self._bytearray = self._bytearray[:start] + _bytearray[0 : count * item_size] + self._bytearray[end:]\n\n    # =============================================================================\n    # .to_bytearray/from_bytearray\n    # =============================================================================\n\n    def to_bytearray(self) -&gt; bytearray:\n        \"\"\"Return the content of the Buffer as a bytearray.\n\n        Returns:\n            bytearray: The bytearray representation of the Buffer.\n        \"\"\"\n        return bytearray(self._bytearray)\n\n    @staticmethod\n    def from_bytearray(_bytearray: bytearray, buffer_type: BufferType) -&gt; \"Buffer\":\n        \"\"\"Create a Buffer from a bytearray and a specified BufferType.\n\n        Args:\n            _bytearray (bytearray): The source bytearray.\n            buffer_type (BufferType): The type of elements in the buffer.\n        Returns:\n            Buffer: The created Buffer instance.\n        \"\"\"\n        item_size = BufferType.get_item_size(buffer_type)\n        # sanity check\n        assert len(_bytearray) % item_size == 0, f\"data size {len(_bytearray)} is not aligned with buffer type item size {item_size}\"\n\n        # create buffer\n        buffer = Buffer(len(_bytearray) // item_size, buffer_type)\n        buffer.set_data(_bytearray, 0, buffer.get_count())\n        return buffer\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.__init__","title":"<code>__init__(count: int, buffer_type: BufferType) -&gt; None</code>","text":"<p>Initialize a Buffer instance.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements in the buffer.</p> required <code>buffer_type</code> <code>gsp.types.buffer_type.BufferType</code> <p>The type of elements in the buffer.</p> required Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def __init__(self, count: int, buffer_type: BufferType) -&gt; None:\n    \"\"\"Initialize a Buffer instance.\n\n    Args:\n        count (int): The number of elements in the buffer.\n        buffer_type (BufferType): The type of elements in the buffer.\n    \"\"\"\n    item_size = BufferType.get_item_size(buffer_type)\n    self._count: int = count\n    self._type: BufferType = buffer_type\n    self._bytearray: bytearray = bytearray(count * item_size)\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.from_bytearray","title":"<code>from_bytearray(_bytearray: bytearray, buffer_type: BufferType) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Create a Buffer from a bytearray and a specified BufferType.</p> <p>Parameters:</p> Name Type Description Default <code>_bytearray</code> <code>bytearray</code> <p>The source bytearray.</p> required <code>buffer_type</code> <code>gsp.types.buffer_type.BufferType</code> <p>The type of elements in the buffer.</p> required <p>Returns:     Buffer: The created Buffer instance.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>@staticmethod\ndef from_bytearray(_bytearray: bytearray, buffer_type: BufferType) -&gt; \"Buffer\":\n    \"\"\"Create a Buffer from a bytearray and a specified BufferType.\n\n    Args:\n        _bytearray (bytearray): The source bytearray.\n        buffer_type (BufferType): The type of elements in the buffer.\n    Returns:\n        Buffer: The created Buffer instance.\n    \"\"\"\n    item_size = BufferType.get_item_size(buffer_type)\n    # sanity check\n    assert len(_bytearray) % item_size == 0, f\"data size {len(_bytearray)} is not aligned with buffer type item size {item_size}\"\n\n    # create buffer\n    buffer = Buffer(len(_bytearray) // item_size, buffer_type)\n    buffer.set_data(_bytearray, 0, buffer.get_count())\n    return buffer\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.get_count","title":"<code>get_count() -&gt; int</code>","text":"<p>Return the number of elements in the buffer.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def get_count(self) -&gt; int:\n    \"\"\"Return the number of elements in the buffer.\n\n    Returns:\n        int: The number of elements.\n    \"\"\"\n    return self._count\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.get_data","title":"<code>get_data(offset: int, count: int) -&gt; Buffer</code>","text":"<p>Return a buffer of count elements starting from offset.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The starting index.</p> required <code>count</code> <code>int</code> <p>The number of elements to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.buffer.Buffer</code> <p>A new Buffer containing the requested data.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def get_data(self, offset: int, count: int) -&gt; \"Buffer\":\n    \"\"\"Return a buffer of count elements starting from offset.\n\n    Args:\n        offset (int): The starting index.\n        count (int): The number of elements to retrieve.\n\n    Returns:\n        Buffer: A new Buffer containing the requested data.\n    \"\"\"\n    item_size = BufferType.get_item_size(self._type)\n    start = offset * item_size\n    end = start + count * item_size\n\n    new_buffer = Buffer(count, self._type)\n    new_buffer.set_data(self._bytearray[start:end], 0, count)\n    return new_buffer\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.get_type","title":"<code>get_type() -&gt; BufferType</code>","text":"<p>Return the type of each element in the buffer.</p> <p>Returns:</p> Name Type Description <code>BufferType</code> <code>gsp.types.buffer_type.BufferType</code> <p>The buffer type.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def get_type(self) -&gt; BufferType:\n    \"\"\"Return the type of each element in the buffer.\n\n    Returns:\n        BufferType: The buffer type.\n    \"\"\"\n    return self._type\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.set_data","title":"<code>set_data(_bytearray: bytearray, offset: int, count: int) -&gt; None</code>","text":"<p>Copy count elements starting from offset in the source bytearray.</p> <p>Parameters:</p> Name Type Description Default <code>_bytearray</code> <code>bytearray</code> <p>The source bytearray containing data to copy.</p> required <code>offset</code> <code>int</code> <p>The starting index in the buffer where data will be copied.</p> required <code>count</code> <code>int</code> <p>The number of elements to copy.</p> required Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def set_data(self, _bytearray: bytearray, offset: int, count: int) -&gt; None:\n    \"\"\"Copy count elements starting from offset in the source bytearray.\n\n    Args:\n        _bytearray (bytearray): The source bytearray containing data to copy.\n        offset (int): The starting index in the buffer where data will be copied.\n        count (int): The number of elements to copy.\n    \"\"\"\n    item_size = BufferType.get_item_size(self._type)\n\n    # sanity check\n    assert offset + count &lt;= self._count, f\"Invalid offset {offset} and count {count} for buffer of size {self._count}\"\n\n    start = offset * item_size\n    end = start + count * item_size\n    self._bytearray = self._bytearray[:start] + _bytearray[0 : count * item_size] + self._bytearray[end:]\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.to_bytearray","title":"<code>to_bytearray() -&gt; bytearray</code>","text":"<p>Return the content of the Buffer as a bytearray.</p> <p>Returns:</p> Name Type Description <code>bytearray</code> <code>bytearray</code> <p>The bytearray representation of the Buffer.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def to_bytearray(self) -&gt; bytearray:\n    \"\"\"Return the content of the Buffer as a bytearray.\n\n    Returns:\n        bytearray: The bytearray representation of the Buffer.\n    \"\"\"\n    return bytearray(self._bytearray)\n</code></pre>"},{"location":"api/gsp/#gsp.types.group","title":"<code>gsp.types.group</code>","text":""},{"location":"api/gsp/#gsp.types.group.Groups","title":"<code>Groups = Union[int, list[int], list[list[int]]]</code>  <code>module-attribute</code>","text":"<p>A type that can represent group IDs in various forms.</p> <ul> <li>if an int, it represents the size of the group</li> <li>if a list of int, each int represents the size of each subgroup</li> <li>if a list of list of int, each sublist represents a list of element index which are part of this group</li> <li>len(groups) represents the number of groups</li> <li>groups[0] represent the element indices of the first group<ul> <li>groups[1] represent the element indices of the second group</li> </ul> </li> </ul>"},{"location":"api/gsp/#gsp.types.visual_base","title":"<code>gsp.types.visual_base</code>","text":""},{"location":"api/gsp/#gsp.types.visual_base.VisualBase","title":"<code>VisualBase</code>","text":"Source code in <code>src/gsp/types/visual_base.py</code> <pre><code>class VisualBase:\n    __slots__ = [\"_uuid\", \"userData\"]\n\n    def __init__(self):\n        self._uuid: str = UuidUtils.generate_uuid()\n        self.userData: dict[str, Any] = {}\n\n    def get_uuid(self) -&gt; str:\n        \"\"\"Get the unique identifier of the visual object.\n\n        Returns:\n            str: The unique identifier.\n        \"\"\"\n        return self._uuid\n</code></pre>"},{"location":"api/gsp/#gsp.types.visual_base.VisualBase.get_uuid","title":"<code>get_uuid() -&gt; str</code>","text":"<p>Get the unique identifier of the visual object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier.</p> Source code in <code>src/gsp/types/visual_base.py</code> <pre><code>def get_uuid(self) -&gt; str:\n    \"\"\"Get the unique identifier of the visual object.\n\n    Returns:\n        str: The unique identifier.\n    \"\"\"\n    return self._uuid\n</code></pre>"},{"location":"api/gsp/#visuals-module","title":"Visuals Module","text":""},{"location":"api/gsp/#gsp.visuals.points","title":"<code>gsp.visuals.points</code>","text":""},{"location":"api/gsp/#gsp.visuals.points.Points","title":"<code>Points</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>class Points(VisualBase):\n    __slots__ = [\"_positions\", \"_sizes\", \"_face_colors\", \"_edge_colors\", \"_edge_widths\"]\n\n    def __init__(self, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf):\n        super().__init__()\n\n        self._positions: TransBuf = positions\n        self._sizes: TransBuf = sizes\n        self._face_colors: TransBuf = face_colors\n        self._edge_colors: TransBuf = edge_colors\n        self._edge_widths: TransBuf = edge_widths\n\n        self.check_attributes()\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        self._positions = positions\n        self.check_attributes()\n\n    def get_sizes(self) -&gt; TransBuf:\n        return self._sizes\n\n    def set_sizes(self, sizes: TransBuf) -&gt; None:\n        self._sizes = sizes\n        self.check_attributes()\n\n    def get_face_colors(self) -&gt; TransBuf:\n        return self._face_colors\n\n    def set_face_colors(self, face_colors: TransBuf) -&gt; None:\n        self._face_colors = face_colors\n        self.check_attributes()\n\n    def get_edge_colors(self) -&gt; TransBuf:\n        return self._edge_colors\n\n    def set_edge_colors(self, edge_colors: TransBuf) -&gt; None:\n        self._edge_colors = edge_colors\n        self.check_attributes()\n\n    def get_edge_widths(self) -&gt; TransBuf:\n        return self._edge_widths\n\n    def set_edge_widths(self, edge_widths: TransBuf) -&gt; None:\n        self._edge_widths = edge_widths\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        positions: TransBuf | None = None,\n        sizes: TransBuf | None = None,\n        face_colors: TransBuf | None = None,\n        edge_colors: TransBuf | None = None,\n        edge_widths: TransBuf | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if positions is not None:\n            self._positions = positions\n        if sizes is not None:\n            self._sizes = sizes\n        if face_colors is not None:\n            self._face_colors = face_colors\n        if edge_colors is not None:\n            self._edge_colors = edge_colors\n        if edge_widths is not None:\n            self._edge_widths = edge_widths\n\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._positions, self._sizes, self._face_colors, self._edge_colors, self._edge_widths)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer):\n        \"\"\"same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(sizes, Buffer), \"Sizes must be a Buffer\"\n        assert isinstance(face_colors, Buffer), \"Face colors must be a Buffer\"\n        assert isinstance(edge_colors, Buffer), \"Edge colors must be a Buffer\"\n        assert isinstance(edge_widths, Buffer), \"Edge widths must be a Buffer\"\n\n        Points.sanity_check_attributes(positions, sizes, face_colors, edge_colors, edge_widths)\n\n    @staticmethod\n    def sanity_check_attributes(\n        positions: TransBuf,\n        sizes: TransBuf,\n        face_colors: TransBuf,\n        edge_colors: TransBuf,\n        edge_widths: TransBuf,\n    ) -&gt; None:\n\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._positions, self._sizes, self._face_colors, self._edge_colors, self._edge_widths)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer)</code>  <code>staticmethod</code>","text":"<p>same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer):\n    \"\"\"same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(sizes, Buffer), \"Sizes must be a Buffer\"\n    assert isinstance(face_colors, Buffer), \"Face colors must be a Buffer\"\n    assert isinstance(edge_colors, Buffer), \"Edge colors must be a Buffer\"\n    assert isinstance(edge_widths, Buffer), \"Edge widths must be a Buffer\"\n\n    Points.sanity_check_attributes(positions, sizes, face_colors, edge_colors, edge_widths)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, sizes: TransBuf | None = None, face_colors: TransBuf | None = None, edge_colors: TransBuf | None = None, edge_widths: TransBuf | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def set_attributes(\n    self,\n    positions: TransBuf | None = None,\n    sizes: TransBuf | None = None,\n    face_colors: TransBuf | None = None,\n    edge_colors: TransBuf | None = None,\n    edge_widths: TransBuf | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if positions is not None:\n        self._positions = positions\n    if sizes is not None:\n        self._sizes = sizes\n    if face_colors is not None:\n        self._face_colors = face_colors\n    if edge_colors is not None:\n        self._edge_colors = edge_colors\n    if edge_widths is not None:\n        self._edge_widths = edge_widths\n\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers","title":"<code>gsp.visuals.markers</code>","text":""},{"location":"api/gsp/#gsp.visuals.markers.Markers","title":"<code>Markers</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>class Markers(VisualBase):\n    __slots__ = [\"_marker_shape\", \"_positions\", \"_sizes\", \"_face_colors\", \"_edge_colors\", \"_edge_widths\"]\n\n    def __init__(self, marker_shape: MarkerShape, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf):\n        super().__init__()\n\n        self._marker_shape: MarkerShape = marker_shape\n        self._positions: TransBuf = positions\n        self._sizes: TransBuf = sizes\n        self._face_colors: TransBuf = face_colors\n        self._edge_colors: TransBuf = edge_colors\n        self._edge_widths: TransBuf = edge_widths\n\n        self.check_attributes()\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_marker_shape(self) -&gt; MarkerShape:\n        return self._marker_shape\n\n    def set_marker_shape(self, marker_shape: MarkerShape) -&gt; None:\n        self._marker_shape = marker_shape\n        self.check_attributes()\n\n    def get_positions(self) -&gt; TransBuf:\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        self._positions = positions\n        self.check_attributes()\n\n    def get_sizes(self) -&gt; TransBuf:\n        return self._sizes\n\n    def set_sizes(self, sizes: TransBuf) -&gt; None:\n        self._sizes = sizes\n        self.check_attributes()\n\n    def get_face_colors(self) -&gt; TransBuf:\n        return self._face_colors\n\n    def set_face_colors(self, face_colors: TransBuf) -&gt; None:\n        self._face_colors = face_colors\n        self.check_attributes()\n\n    def get_edge_colors(self) -&gt; TransBuf:\n        return self._edge_colors\n\n    def set_edge_colors(self, edge_colors: TransBuf) -&gt; None:\n        self._edge_colors = edge_colors\n        self.check_attributes()\n\n    def get_edge_widths(self) -&gt; TransBuf:\n        return self._edge_widths\n\n    def set_edge_widths(self, edge_widths: TransBuf) -&gt; None:\n        self._edge_widths = edge_widths\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        marker_shape: MarkerShape | None = None,\n        positions: TransBuf | None = None,\n        sizes: TransBuf | None = None,\n        face_colors: TransBuf | None = None,\n        edge_colors: TransBuf | None = None,\n        edge_widths: TransBuf | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if marker_shape is not None:\n            self._marker_shape = marker_shape\n        if positions is not None:\n            self._positions = positions\n        if sizes is not None:\n            self._sizes = sizes\n        if face_colors is not None:\n            self._face_colors = face_colors\n        if edge_colors is not None:\n            self._edge_colors = edge_colors\n        if edge_widths is not None:\n            self._edge_widths = edge_widths\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._marker_shape, self._positions, self._sizes, self._face_colors, self._edge_colors, self._edge_widths)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(\n        marker_shape: MarkerShape, positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer\n    ):\n        \"\"\"same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(sizes, Buffer), \"Sizes must be a Buffer\"\n        assert isinstance(face_colors, Buffer), \"Face colors must be a Buffer\"\n        assert isinstance(edge_colors, Buffer), \"Edge colors must be a Buffer\"\n        assert isinstance(edge_widths, Buffer), \"Edge widths must be a Buffer\"\n\n        Markers.sanity_check_attributes(marker_shape, positions, sizes, face_colors, edge_colors, edge_widths)\n\n    @staticmethod\n    def sanity_check_attributes(\n        marker_shape: MarkerShape,\n        positions: TransBuf,\n        sizes: TransBuf,\n        face_colors: TransBuf,\n        edge_colors: TransBuf,\n        edge_widths: TransBuf,\n    ) -&gt; None:\n\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._marker_shape, self._positions, self._sizes, self._face_colors, self._edge_colors, self._edge_widths)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(marker_shape: MarkerShape, positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer)</code>  <code>staticmethod</code>","text":"<p>same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(\n    marker_shape: MarkerShape, positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer\n):\n    \"\"\"same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(sizes, Buffer), \"Sizes must be a Buffer\"\n    assert isinstance(face_colors, Buffer), \"Face colors must be a Buffer\"\n    assert isinstance(edge_colors, Buffer), \"Edge colors must be a Buffer\"\n    assert isinstance(edge_widths, Buffer), \"Edge widths must be a Buffer\"\n\n    Markers.sanity_check_attributes(marker_shape, positions, sizes, face_colors, edge_colors, edge_widths)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_attributes","title":"<code>set_attributes(marker_shape: MarkerShape | None = None, positions: TransBuf | None = None, sizes: TransBuf | None = None, face_colors: TransBuf | None = None, edge_colors: TransBuf | None = None, edge_widths: TransBuf | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_attributes(\n    self,\n    marker_shape: MarkerShape | None = None,\n    positions: TransBuf | None = None,\n    sizes: TransBuf | None = None,\n    face_colors: TransBuf | None = None,\n    edge_colors: TransBuf | None = None,\n    edge_widths: TransBuf | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if marker_shape is not None:\n        self._marker_shape = marker_shape\n    if positions is not None:\n        self._positions = positions\n    if sizes is not None:\n        self._sizes = sizes\n    if face_colors is not None:\n        self._face_colors = face_colors\n    if edge_colors is not None:\n        self._edge_colors = edge_colors\n    if edge_widths is not None:\n        self._edge_widths = edge_widths\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments","title":"<code>gsp.visuals.segments</code>","text":""},{"location":"api/gsp/#gsp.visuals.segments.Segments","title":"<code>Segments</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>class Segments(VisualBase):\n    __slots__ = [\"_positions\", \"_colors\", \"_line_widths\", \"_cap_style\"]\n\n    def __init__(self, positions: TransBuf, line_widths: TransBuf, cap_style: CapStyle, colors: TransBuf) -&gt; None:\n        super().__init__()\n\n        self._positions: TransBuf = positions\n        self._line_widths: TransBuf = line_widths\n        self._cap_style: CapStyle = cap_style\n        self._colors: TransBuf = colors\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        self._positions = positions\n        self.check_attributes()\n\n    def get_line_widths(self) -&gt; TransBuf:\n        return self._line_widths\n\n    def set_line_widths(self, line_widths: TransBuf) -&gt; None:\n        self._line_widths = line_widths\n        self.check_attributes()\n\n    def get_cap_style(self) -&gt; CapStyle:\n        return self._cap_style\n\n    def set_cap_style(self, cap_style: CapStyle) -&gt; None:\n        self._cap_style = cap_style\n        self.check_attributes()\n\n    def get_colors(self) -&gt; TransBuf:\n        return self._colors\n\n    def set_colors(self, colors: TransBuf) -&gt; None:\n        self._colors = colors\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        positions: TransBuf | None = None,\n        line_widths: TransBuf | None = None,\n        cap_style: CapStyle | None = None,\n        colors: TransBuf | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if positions is not None:\n            self._positions = positions\n        if line_widths is not None:\n            self._line_widths = line_widths\n        if cap_style is not None:\n            self._cap_style = cap_style\n        if colors is not None:\n            self._colors = colors\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._positions, self._line_widths, self._cap_style, self._colors)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(positions: Buffer, line_widths: Buffer, cap_style: CapStyle, colors: Buffer) -&gt; None:\n        \"\"\"same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(line_widths, Buffer), \"Line widths must be a Buffer\"\n        assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n\n        Segments.sanity_check_attributes(positions, line_widths, cap_style, colors)\n\n    @staticmethod\n    def sanity_check_attributes(\n        positions: TransBuf,\n        line_widths: TransBuf,\n        cap_style: CapStyle,\n        colors: TransBuf,\n    ) -&gt; None:\n\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._positions, self._line_widths, self._cap_style, self._colors)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(positions: Buffer, line_widths: Buffer, cap_style: CapStyle, colors: Buffer) -&gt; None</code>  <code>staticmethod</code>","text":"<p>same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(positions: Buffer, line_widths: Buffer, cap_style: CapStyle, colors: Buffer) -&gt; None:\n    \"\"\"same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(line_widths, Buffer), \"Line widths must be a Buffer\"\n    assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n\n    Segments.sanity_check_attributes(positions, line_widths, cap_style, colors)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, line_widths: TransBuf | None = None, cap_style: CapStyle | None = None, colors: TransBuf | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def set_attributes(\n    self,\n    positions: TransBuf | None = None,\n    line_widths: TransBuf | None = None,\n    cap_style: CapStyle | None = None,\n    colors: TransBuf | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if positions is not None:\n        self._positions = positions\n    if line_widths is not None:\n        self._line_widths = line_widths\n    if cap_style is not None:\n        self._cap_style = cap_style\n    if colors is not None:\n        self._colors = colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths","title":"<code>gsp.visuals.paths</code>","text":""},{"location":"api/gsp/#gsp.visuals.paths.Paths","title":"<code>Paths</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>class Paths(VisualBase):\n    __slots__ = [\"_positions\", \"_path_sizes\", \"_colors\", \"_line_widths\", \"_cap_style\", \"_join_style\"]\n\n    def __init__(self, positions: TransBuf, path_sizes: TransBuf, colors: TransBuf, line_widths: TransBuf, cap_style: CapStyle, join_style: JoinStyle) -&gt; None:\n        super().__init__()\n\n        self._positions: TransBuf = positions\n        self._path_sizes: TransBuf = path_sizes\n        self._colors: TransBuf = colors\n        self._line_widths: TransBuf = line_widths\n        self._cap_style: CapStyle = cap_style\n        self._join_style: JoinStyle = join_style\n        self.check_attributes()\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        self._positions = positions\n        self.check_attributes()\n\n    def get_path_sizes(self) -&gt; TransBuf:\n        return self._path_sizes\n\n    def set_path_sizes(self, path_sizes: TransBuf) -&gt; None:\n        self._path_sizes = path_sizes\n        self.check_attributes()\n\n    def get_colors(self) -&gt; TransBuf:\n        return self._colors\n\n    def set_colors(self, colors: TransBuf) -&gt; None:\n        self._colors = colors\n        self.check_attributes()\n\n    def get_line_widths(self) -&gt; TransBuf:\n        return self._line_widths\n\n    def set_line_widths(self, line_widths: TransBuf) -&gt; None:\n        self._line_widths = line_widths\n        self.check_attributes()\n\n    def get_join_style(self) -&gt; JoinStyle:\n        return self._join_style\n\n    def set_join_style(self, join_style: JoinStyle) -&gt; None:\n        self._join_style = join_style\n        self.check_attributes()\n\n    def get_cap_style(self) -&gt; CapStyle:\n        return self._cap_style\n\n    def set_cap_style(self, cap_style: CapStyle) -&gt; None:\n        self._cap_style = cap_style\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        positions: TransBuf | None = None,\n        path_sizes: TransBuf | None = None,\n        colors: TransBuf | None = None,\n        line_widths: TransBuf | None = None,\n        cap_style: CapStyle | None = None,\n        join_style: JoinStyle | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if positions is not None:\n            self._positions = positions\n        if path_sizes is not None:\n            self._path_sizes = path_sizes\n        if colors is not None:\n            self._colors = colors\n        if line_widths is not None:\n            self._line_widths = line_widths\n        if cap_style is not None:\n            self._cap_style = cap_style\n        if join_style is not None:\n            self._join_style = join_style\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._positions, self._path_sizes, self._colors, self._line_widths, self._cap_style, self._join_style)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(\n        positions: Buffer, path_sizes: Buffer, colors: Buffer, line_widths: Buffer, cap_style: CapStyle, join_style: JoinStyle\n    ) -&gt; None:\n        \"\"\"same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(path_sizes, Buffer), \"Path sizes must be a Buffer\"\n        assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n        assert isinstance(line_widths, Buffer), \"Line widths must be a Buffer\"\n\n        Paths.sanity_check_attributes(positions, path_sizes, colors, line_widths, cap_style, join_style)\n\n    @staticmethod\n    def sanity_check_attributes(\n        positions: TransBuf,\n        path_sizes: TransBuf,\n        colors: TransBuf,\n        line_widths: TransBuf,\n        cap_style: CapStyle,\n        join_style: JoinStyle,\n    ) -&gt; None:\n\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._positions, self._path_sizes, self._colors, self._line_widths, self._cap_style, self._join_style)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(positions: Buffer, path_sizes: Buffer, colors: Buffer, line_widths: Buffer, cap_style: CapStyle, join_style: JoinStyle) -&gt; None</code>  <code>staticmethod</code>","text":"<p>same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(\n    positions: Buffer, path_sizes: Buffer, colors: Buffer, line_widths: Buffer, cap_style: CapStyle, join_style: JoinStyle\n) -&gt; None:\n    \"\"\"same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(path_sizes, Buffer), \"Path sizes must be a Buffer\"\n    assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n    assert isinstance(line_widths, Buffer), \"Line widths must be a Buffer\"\n\n    Paths.sanity_check_attributes(positions, path_sizes, colors, line_widths, cap_style, join_style)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, path_sizes: TransBuf | None = None, colors: TransBuf | None = None, line_widths: TransBuf | None = None, cap_style: CapStyle | None = None, join_style: JoinStyle | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_attributes(\n    self,\n    positions: TransBuf | None = None,\n    path_sizes: TransBuf | None = None,\n    colors: TransBuf | None = None,\n    line_widths: TransBuf | None = None,\n    cap_style: CapStyle | None = None,\n    join_style: JoinStyle | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if positions is not None:\n        self._positions = positions\n    if path_sizes is not None:\n        self._path_sizes = path_sizes\n    if colors is not None:\n        self._colors = colors\n    if line_widths is not None:\n        self._line_widths = line_widths\n    if cap_style is not None:\n        self._cap_style = cap_style\n    if join_style is not None:\n        self._join_style = join_style\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels","title":"<code>gsp.visuals.pixels</code>","text":""},{"location":"api/gsp/#gsp.visuals.pixels.Pixels","title":"<code>Pixels</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>class Pixels(VisualBase):\n    __slots__ = [\"__positions\", \"__colors\", \"__groups\"]\n\n    def __init__(self, positions: TransBuf, colors: TransBuf, groups: Groups):\n        super().__init__()\n\n        self.__positions: TransBuf = positions\n        self.__colors: TransBuf = colors\n        self.__groups: Groups = groups\n\n        self.check_attributes()\n\n    def __repr__(self) -&gt; str:\n        return f\"Pixels(positions={self.__positions}, colors={self.__colors}, groups={self.__groups})\"\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        return self.__positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        self.__positions = positions\n        self.check_attributes()\n\n    def get_colors(self) -&gt; TransBuf:\n        return self.__colors\n\n    def set_colors(self, colors: TransBuf) -&gt; None:\n        self.__colors = colors\n        self.check_attributes()\n\n    def get_groups(self) -&gt; Groups:\n        return self.__groups\n\n    def set_groups(self, groups: Groups) -&gt; None:\n        self.__groups = groups\n        self.check_attributes()\n\n    def set_attributes(self, positions: TransBuf | None = None, colors: TransBuf | None = None, groups: Groups | None = None) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if positions is not None:\n            self.__positions = positions\n        if colors is not None:\n            self.__colors = colors\n        if groups is not None:\n            self.__groups = groups\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self.__positions, self.__colors, self.__groups)\n\n    @staticmethod\n    def sanity_check_attribute_buffers(positions: Buffer, colors: Buffer, groups: Groups):\n        \"\"\"same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n\n        Pixels.sanity_check_attributes(positions, colors, groups)\n\n    @staticmethod\n    def sanity_check_attributes(positions: TransBuf, colors: TransBuf, groups: Groups):\n\n        # =============================================================================\n        # if any of the attributes is a TransformChain not fully defined, skip the sanity check\n        # =============================================================================\n\n        if isinstance(positions, TransformChain) and not positions.is_fully_defined():\n            return\n        if isinstance(colors, TransformChain) and not colors.is_fully_defined():\n            return\n\n        # =============================================================================\n        # Check groups\n        # =============================================================================\n\n        # get position_count and group_count\n        position_count = positions.get_count() if isinstance(positions, Buffer) else positions.get_buffer_count()\n        group_count = GroupUtils.get_group_count(position_count, groups)\n\n        # Check groups matches position count\n        GroupUtils.sanity_check(position_count, groups)\n\n        # =============================================================================\n        # Check each attributes\n        # =============================================================================\n\n        # Check colors attribute\n        color_count = colors.get_count() if isinstance(colors, Buffer) else colors.get_buffer_count()\n        assert color_count == group_count, f\"Colors count {color_count} must match group count {group_count}\"\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self.__positions, self.__colors, self.__groups)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.sanity_check_attribute_buffers","title":"<code>sanity_check_attribute_buffers(positions: Buffer, colors: Buffer, groups: Groups)</code>  <code>staticmethod</code>","text":"<p>same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>@staticmethod\ndef sanity_check_attribute_buffers(positions: Buffer, colors: Buffer, groups: Groups):\n    \"\"\"same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n\n    Pixels.sanity_check_attributes(positions, colors, groups)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, colors: TransBuf | None = None, groups: Groups | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def set_attributes(self, positions: TransBuf | None = None, colors: TransBuf | None = None, groups: Groups | None = None) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if positions is not None:\n        self.__positions = positions\n    if colors is not None:\n        self.__colors = colors\n    if groups is not None:\n        self.__groups = groups\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts","title":"<code>gsp.visuals.texts</code>","text":""},{"location":"api/gsp/#gsp.visuals.texts.Texts","title":"<code>Texts</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>class Texts(VisualBase):\n    __slots__ = [\"_positions\", \"_strings\", \"_colors\", \"_font_sizes\", \"_anchors\", \"_angles\", \"_font_name\"]\n\n    def __init__(\n        self,\n        positions: TransBuf,\n        strings: list[str],\n        colors: TransBuf,\n        font_sizes: TransBuf,\n        anchors: TransBuf,\n        angles: TransBuf,\n        font_name: str,\n    ) -&gt; None:\n        super().__init__()\n\n        self._positions: TransBuf = positions\n        self._strings: list[str] = strings\n        self._colors: TransBuf = colors\n        self._font_sizes: TransBuf = font_sizes\n        self._anchors: TransBuf = anchors\n        self._angles: TransBuf = angles\n        self._font_name: str = font_name\n        self.check_attributes()\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        self._positions = positions\n        self.check_attributes()\n\n    def get_strings(self) -&gt; list[str]:\n        return self._strings\n\n    def set_strings(self, strings: list[str]) -&gt; None:\n        self._strings = strings\n        self.check_attributes()\n\n    def get_colors(self) -&gt; TransBuf:\n        return self._colors\n\n    def set_colors(self, colors: TransBuf) -&gt; None:\n        self._colors = colors\n        self.check_attributes()\n\n    def get_font_sizes(self) -&gt; TransBuf:\n        return self._font_sizes\n\n    def set_font_sizes(self, font_sizes: TransBuf) -&gt; None:\n        self._font_sizes = font_sizes\n        self.check_attributes()\n\n    def get_anchors(self) -&gt; TransBuf:\n        return self._anchors\n\n    def set_anchors(self, anchors: TransBuf) -&gt; None:\n        self._anchors = anchors\n        self.check_attributes()\n\n    def get_angles(self) -&gt; TransBuf:\n        return self._angles\n\n    def set_angles(self, angles: TransBuf) -&gt; None:\n        self._angles = angles\n        self.check_attributes()\n\n    def get_font_name(self) -&gt; str:\n        return self._font_name\n\n    def set_font_name(self, font_name: str) -&gt; None:\n        self._font_name = font_name\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        positions: TransBuf | None = None,\n        texts: list[str] | None = None,\n        colors: TransBuf | None = None,\n        font_sizes: TransBuf | None = None,\n        anchors: TransBuf | None = None,\n        angles: TransBuf | None = None,\n        font_name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if positions is not None:\n            self._positions = positions\n        if texts is not None:\n            self._strings = texts\n        if colors is not None:\n            self._colors = colors\n        if font_sizes is not None:\n            self._font_sizes = font_sizes\n        if anchors is not None:\n            self._anchors = anchors\n        if angles is not None:\n            self._angles = angles\n        if font_name is not None:\n            self._font_name = font_name\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._positions, self._strings, self._colors, self._font_sizes, self._anchors, self._angles, self._font_name)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(\n        positions: Buffer, texts: list[str], colors: Buffer, font_sizes: Buffer, anchors: Buffer, angles: Buffer, font_name: str\n    ) -&gt; None:\n        \"\"\"same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(texts, list), \"Texts must be a list of strings\"\n        assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n        assert isinstance(font_sizes, Buffer), \"Font sizes must be a Buffer\"\n        assert isinstance(anchors, Buffer), \"Anchors must be a Buffer\"\n        assert isinstance(angles, Buffer), \"Angles must be a Buffer\"\n        assert isinstance(font_name, str), \"Font name must be a string\"\n\n        Texts.sanity_check_attributes(positions, texts, colors, font_sizes, anchors, angles, font_name)\n\n    @staticmethod\n    def sanity_check_attributes(\n        positions: TransBuf,\n        texts: list[str],\n        colors: TransBuf,\n        font_sizes: TransBuf,\n        anchors: TransBuf,\n        angles: TransBuf,\n        font_name: str,\n    ) -&gt; None:\n\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._positions, self._strings, self._colors, self._font_sizes, self._anchors, self._angles, self._font_name)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(positions: Buffer, texts: list[str], colors: Buffer, font_sizes: Buffer, anchors: Buffer, angles: Buffer, font_name: str) -&gt; None</code>  <code>staticmethod</code>","text":"<p>same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(\n    positions: Buffer, texts: list[str], colors: Buffer, font_sizes: Buffer, anchors: Buffer, angles: Buffer, font_name: str\n) -&gt; None:\n    \"\"\"same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(texts, list), \"Texts must be a list of strings\"\n    assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n    assert isinstance(font_sizes, Buffer), \"Font sizes must be a Buffer\"\n    assert isinstance(anchors, Buffer), \"Anchors must be a Buffer\"\n    assert isinstance(angles, Buffer), \"Angles must be a Buffer\"\n    assert isinstance(font_name, str), \"Font name must be a string\"\n\n    Texts.sanity_check_attributes(positions, texts, colors, font_sizes, anchors, angles, font_name)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, texts: list[str] | None = None, colors: TransBuf | None = None, font_sizes: TransBuf | None = None, anchors: TransBuf | None = None, angles: TransBuf | None = None, font_name: str | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_attributes(\n    self,\n    positions: TransBuf | None = None,\n    texts: list[str] | None = None,\n    colors: TransBuf | None = None,\n    font_sizes: TransBuf | None = None,\n    anchors: TransBuf | None = None,\n    angles: TransBuf | None = None,\n    font_name: str | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if positions is not None:\n        self._positions = positions\n    if texts is not None:\n        self._strings = texts\n    if colors is not None:\n        self._colors = colors\n    if font_sizes is not None:\n        self._font_sizes = font_sizes\n    if anchors is not None:\n        self._anchors = anchors\n    if angles is not None:\n        self._angles = angles\n    if font_name is not None:\n        self._font_name = font_name\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#transforms-module","title":"Transforms Module","text":""},{"location":"api/gsp/#gsp.transforms","title":"<code>gsp.transforms</code>","text":""},{"location":"api/gsp/#gsp.transforms.transform_chain","title":"<code>gsp.transforms.transform_chain</code>","text":""},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain","title":"<code>TransformChain</code>","text":"<p>Chain of transformations to apply to data.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>class TransformChain:\n    \"\"\"Chain of transformations to apply to data.\"\"\"\n\n    __slots__ = [\"__links\", \"__buffer_count\", \"__buffer_type\"]\n\n    def __init__(self, buffer_count: int, buffer_type: BufferType | None) -&gt; None:\n        \"\"\"\n        Initialize a TransformChain.\n\n        Args:\n            buffer_count (int): Number of elements in the output Buffer. -1 if not defined yet.\n            buffer_type (BufferType | None): Type of the output Buffer. None if not defined yet.\n        \"\"\"\n\n        self.__links: list[TransformLinkBase] = []\n        \"\"\"Ordered list of links defining the transform.\"\"\"\n\n        # sanity check\n        if buffer_count &lt; 0:\n            assert buffer_count == -1, \"TransformChain: buffer_count must be -1 (undefined) or &gt;= 0\"\n\n        self.__buffer_count = buffer_count\n        \"\"\"Number of elements in the output Buffer. -1 if not defined yet.\"\"\"\n\n        self.__buffer_type = buffer_type\n        \"\"\"Type of the output Buffer. None if not defined yet.\"\"\"\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    def is_fully_defined(self) -&gt; bool:\n        \"\"\"Check if the TransformChain is fully defined (i.e., buffer_type is not None and buffer_count &gt;= 0).\"\"\"\n        if self.__buffer_type is None:\n            return False\n        if self.__buffer_count &lt; 0:\n            return False\n        return True\n\n    def get_buffer_count(self) -&gt; int:\n        \"\"\"Get the number of elements in the output Buffer. use this only if .is_fully_defined() is True.\"\"\"\n\n        # sanity check - buffer_count MUST be defined\n        assert self.__buffer_type is not None, \"TransformChain.get_buffer_count: buffer_type is None. use .is_fully_defined() to check.\"\n        assert self.__buffer_count &gt;= 0, \"TransformChain.get_buffer_count: buffer_count is negative. use .is_fully_defined() to check.\"\n\n        # return the buffer count\n        return self.__buffer_count\n\n    def get_buffer_type(self) -&gt; BufferType:\n        \"\"\"Get the type of the output Buffer. use this only if .is_fully_defined() is True.\"\"\"\n\n        # sanity check - buffer_type MUST be defined\n        assert self.__buffer_type is not None, \"TransformChain.get_buffer_type: buffer_type is None. use .is_fully_defined() to check.\"\n        assert self.__buffer_count &gt;= 0, \"TransformChain.get_buffer_count: buffer_count is negative. use .is_fully_defined() to check.\"\n\n        # return the buffer type\n        return self.__buffer_type\n\n    # =============================================================================\n    # .add/.remove/.clear the links\n    # =============================================================================\n\n    def add(self, link: TransformLinkBase) -&gt; None:\n        \"\"\"Add a TransformLink to the chain.\"\"\"\n        self.__links.append(link)\n\n    def remove(self, link: TransformLinkBase) -&gt; None:\n        \"\"\"Remove a TransformLink from the chain.\"\"\"\n        self.__links.remove(link)\n\n    # =============================================================================\n    # .run()\n    # =============================================================================\n\n    def run(self) -&gt; Buffer:\n        \"\"\"Compute the transform and return a Buffer with the result.\"\"\"\n\n        # Create a new Buffer to hold the transformed data\n        buffer = None\n\n        # Apply each link in the chain\n        for link in self.__links:\n            buffer = link.apply(buffer)\n\n        # Sanity check the output buffer\n        assert buffer is not None, \"TransformChain.to_buffer: No buffer produced by the transform chain.\"\n\n        # Return the final buffer\n        return buffer\n\n    # =============================================================================\n    # Serialisation\n    # =============================================================================\n\n    def serialize(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Serialize the TransformChain to a dictionary.\n\n        Returns:\n            dict[str, Any]: The serialized TransformChain.\n        \"\"\"\n        links_data = [link.serialize() for link in self.__links]\n        chain_serialized = {\n            \"buffer_count\": self.__buffer_count,\n            \"buffer_type\": self.__buffer_type.name if self.__buffer_type is not None else None,\n            \"links\": links_data,\n        }\n        return chain_serialized\n\n    @staticmethod\n    def deserialize(data: dict[str, Any]) -&gt; \"TransformChain\":\n        \"\"\"\n        Deserialize a TransformChain from a dictionary.\n        Args:\n            data (dict[str, Any]): The serialized TransformChain.\n        Returns:\n            TransformChain: The deserialized TransformChain instance.\"\"\"\n        buffer_count = int(data[\"buffer_count\"])\n        buffer_type_str: str | None = data[\"buffer_type\"]\n        buffer_type = BufferType[buffer_type_str] if buffer_type_str is not None else None\n\n        transform_chain = TransformChain(buffer_count, buffer_type)\n\n        links_data: list[dict[str, Any]] = data[\"links\"]\n        for link_data in links_data:\n            link_type: str = link_data[\"link_type\"]\n            link_class: type[TransformLinkBase] = TransformRegistry.get_link_class(link_type)\n            link_instance = link_class.deserialize(link_data)\n            transform_chain.add(link_instance)\n\n        return transform_chain\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.__buffer_count","title":"<code>__buffer_count = buffer_count</code>  <code>instance-attribute</code>","text":"<p>Number of elements in the output Buffer. -1 if not defined yet.</p>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.__buffer_type","title":"<code>__buffer_type = buffer_type</code>  <code>instance-attribute</code>","text":"<p>Type of the output Buffer. None if not defined yet.</p>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.__links","title":"<code>__links: list[TransformLinkBase] = []</code>  <code>instance-attribute</code>","text":"<p>Ordered list of links defining the transform.</p>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.__init__","title":"<code>__init__(buffer_count: int, buffer_type: BufferType | None) -&gt; None</code>","text":"<p>Initialize a TransformChain.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_count</code> <code>int</code> <p>Number of elements in the output Buffer. -1 if not defined yet.</p> required <code>buffer_type</code> <code>gsp.types.BufferType | None</code> <p>Type of the output Buffer. None if not defined yet.</p> required Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def __init__(self, buffer_count: int, buffer_type: BufferType | None) -&gt; None:\n    \"\"\"\n    Initialize a TransformChain.\n\n    Args:\n        buffer_count (int): Number of elements in the output Buffer. -1 if not defined yet.\n        buffer_type (BufferType | None): Type of the output Buffer. None if not defined yet.\n    \"\"\"\n\n    self.__links: list[TransformLinkBase] = []\n    \"\"\"Ordered list of links defining the transform.\"\"\"\n\n    # sanity check\n    if buffer_count &lt; 0:\n        assert buffer_count == -1, \"TransformChain: buffer_count must be -1 (undefined) or &gt;= 0\"\n\n    self.__buffer_count = buffer_count\n    \"\"\"Number of elements in the output Buffer. -1 if not defined yet.\"\"\"\n\n    self.__buffer_type = buffer_type\n    \"\"\"Type of the output Buffer. None if not defined yet.\"\"\"\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.add","title":"<code>add(link: TransformLinkBase) -&gt; None</code>","text":"<p>Add a TransformLink to the chain.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def add(self, link: TransformLinkBase) -&gt; None:\n    \"\"\"Add a TransformLink to the chain.\"\"\"\n    self.__links.append(link)\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.deserialize","title":"<code>deserialize(data: dict[str, Any]) -&gt; TransformChain</code>  <code>staticmethod</code>","text":"<p>Deserialize a TransformChain from a dictionary. Args:     data (dict[str, Any]): The serialized TransformChain. Returns:     TransformChain: The deserialized TransformChain instance.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>@staticmethod\ndef deserialize(data: dict[str, Any]) -&gt; \"TransformChain\":\n    \"\"\"\n    Deserialize a TransformChain from a dictionary.\n    Args:\n        data (dict[str, Any]): The serialized TransformChain.\n    Returns:\n        TransformChain: The deserialized TransformChain instance.\"\"\"\n    buffer_count = int(data[\"buffer_count\"])\n    buffer_type_str: str | None = data[\"buffer_type\"]\n    buffer_type = BufferType[buffer_type_str] if buffer_type_str is not None else None\n\n    transform_chain = TransformChain(buffer_count, buffer_type)\n\n    links_data: list[dict[str, Any]] = data[\"links\"]\n    for link_data in links_data:\n        link_type: str = link_data[\"link_type\"]\n        link_class: type[TransformLinkBase] = TransformRegistry.get_link_class(link_type)\n        link_instance = link_class.deserialize(link_data)\n        transform_chain.add(link_instance)\n\n    return transform_chain\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.get_buffer_count","title":"<code>get_buffer_count() -&gt; int</code>","text":"<p>Get the number of elements in the output Buffer. use this only if .is_fully_defined() is True.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def get_buffer_count(self) -&gt; int:\n    \"\"\"Get the number of elements in the output Buffer. use this only if .is_fully_defined() is True.\"\"\"\n\n    # sanity check - buffer_count MUST be defined\n    assert self.__buffer_type is not None, \"TransformChain.get_buffer_count: buffer_type is None. use .is_fully_defined() to check.\"\n    assert self.__buffer_count &gt;= 0, \"TransformChain.get_buffer_count: buffer_count is negative. use .is_fully_defined() to check.\"\n\n    # return the buffer count\n    return self.__buffer_count\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.get_buffer_type","title":"<code>get_buffer_type() -&gt; BufferType</code>","text":"<p>Get the type of the output Buffer. use this only if .is_fully_defined() is True.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def get_buffer_type(self) -&gt; BufferType:\n    \"\"\"Get the type of the output Buffer. use this only if .is_fully_defined() is True.\"\"\"\n\n    # sanity check - buffer_type MUST be defined\n    assert self.__buffer_type is not None, \"TransformChain.get_buffer_type: buffer_type is None. use .is_fully_defined() to check.\"\n    assert self.__buffer_count &gt;= 0, \"TransformChain.get_buffer_count: buffer_count is negative. use .is_fully_defined() to check.\"\n\n    # return the buffer type\n    return self.__buffer_type\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.is_fully_defined","title":"<code>is_fully_defined() -&gt; bool</code>","text":"<p>Check if the TransformChain is fully defined (i.e., buffer_type is not None and buffer_count &gt;= 0).</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def is_fully_defined(self) -&gt; bool:\n    \"\"\"Check if the TransformChain is fully defined (i.e., buffer_type is not None and buffer_count &gt;= 0).\"\"\"\n    if self.__buffer_type is None:\n        return False\n    if self.__buffer_count &lt; 0:\n        return False\n    return True\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.remove","title":"<code>remove(link: TransformLinkBase) -&gt; None</code>","text":"<p>Remove a TransformLink from the chain.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def remove(self, link: TransformLinkBase) -&gt; None:\n    \"\"\"Remove a TransformLink from the chain.\"\"\"\n    self.__links.remove(link)\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.run","title":"<code>run() -&gt; Buffer</code>","text":"<p>Compute the transform and return a Buffer with the result.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def run(self) -&gt; Buffer:\n    \"\"\"Compute the transform and return a Buffer with the result.\"\"\"\n\n    # Create a new Buffer to hold the transformed data\n    buffer = None\n\n    # Apply each link in the chain\n    for link in self.__links:\n        buffer = link.apply(buffer)\n\n    # Sanity check the output buffer\n    assert buffer is not None, \"TransformChain.to_buffer: No buffer produced by the transform chain.\"\n\n    # Return the final buffer\n    return buffer\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.serialize","title":"<code>serialize() -&gt; dict[str, Any]</code>","text":"<p>Serialize the TransformChain to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>dict[str, Any]: The serialized TransformChain.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Serialize the TransformChain to a dictionary.\n\n    Returns:\n        dict[str, Any]: The serialized TransformChain.\n    \"\"\"\n    links_data = [link.serialize() for link in self.__links]\n    chain_serialized = {\n        \"buffer_count\": self.__buffer_count,\n        \"buffer_type\": self.__buffer_type.name if self.__buffer_type is not None else None,\n        \"links\": links_data,\n    }\n    return chain_serialized\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_link_base","title":"<code>gsp.transforms.transform_link_base</code>","text":""},{"location":"api/gsp/#gsp.transforms.transform_link_base.TransformLinkBase","title":"<code>TransformLinkBase</code>","text":"<p>               Bases: <code>abc.ABC</code></p> <p>Base class for a link in a Transform chain.</p> Source code in <code>src/gsp/transforms/transform_link_base.py</code> <pre><code>class TransformLinkBase(ABC):\n    \"\"\"Base class for a link in a Transform chain.\"\"\"\n\n    @abstractmethod\n    def apply(self, buffer_src: Buffer | None) -&gt; Buffer:\n        \"\"\"\n        Apply the transformation to the given buffer and return a new buffer.\n\n        Args:\n            buffer_src (Buffer | None): The source buffer to transform. Can be None.\n\n        Returns:\n            Buffer: The transformed buffer.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def serialize(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Serialize the TransformLink to a dictionary.\n\n        Returns:\n            dict[str, Any]: The serialized TransformLink.\n        \"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def deserialize(data: dict[str, Any]) -&gt; \"TransformLinkBase\":\n        \"\"\"\n        Deserialize a TransformLink from a dictionary.\n\n        Args:\n            data (dict[str, Any]): The serialized TransformLink.\n        Returns:\n            TransformLinkBase: The deserialized TransformLink instance.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_link_base.TransformLinkBase.apply","title":"<code>apply(buffer_src: Buffer | None) -&gt; Buffer</code>  <code>abstractmethod</code>","text":"<p>Apply the transformation to the given buffer and return a new buffer.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_src</code> <code>gsp.types.Buffer | None</code> <p>The source buffer to transform. Can be None.</p> required <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.Buffer</code> <p>The transformed buffer.</p> Source code in <code>src/gsp/transforms/transform_link_base.py</code> <pre><code>@abstractmethod\ndef apply(self, buffer_src: Buffer | None) -&gt; Buffer:\n    \"\"\"\n    Apply the transformation to the given buffer and return a new buffer.\n\n    Args:\n        buffer_src (Buffer | None): The source buffer to transform. Can be None.\n\n    Returns:\n        Buffer: The transformed buffer.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_link_base.TransformLinkBase.deserialize","title":"<code>deserialize(data: dict[str, Any]) -&gt; TransformLinkBase</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Deserialize a TransformLink from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, typing.Any]</code> <p>The serialized TransformLink.</p> required <p>Returns:     TransformLinkBase: The deserialized TransformLink instance.</p> Source code in <code>src/gsp/transforms/transform_link_base.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef deserialize(data: dict[str, Any]) -&gt; \"TransformLinkBase\":\n    \"\"\"\n    Deserialize a TransformLink from a dictionary.\n\n    Args:\n        data (dict[str, Any]): The serialized TransformLink.\n    Returns:\n        TransformLinkBase: The deserialized TransformLink instance.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_link_base.TransformLinkBase.serialize","title":"<code>serialize() -&gt; dict[str, Any]</code>  <code>abstractmethod</code>","text":"<p>Serialize the TransformLink to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>dict[str, Any]: The serialized TransformLink.</p> Source code in <code>src/gsp/transforms/transform_link_base.py</code> <pre><code>@abstractmethod\ndef serialize(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Serialize the TransformLink to a dictionary.\n\n    Returns:\n        dict[str, Any]: The serialized TransformLink.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#utilities-module","title":"Utilities Module","text":""},{"location":"api/gsp/#gsp.utils","title":"<code>gsp.utils</code>","text":""},{"location":"api/gsp/#gsp.utils.cmap_utils","title":"<code>gsp.utils.cmap_utils</code>","text":""},{"location":"api/gsp/#gsp.utils.cmap_utils.CmapUtils","title":"<code>CmapUtils</code>","text":"<p>Utility class for colormap operations. Leverage matplotlib colormaps.</p> Source code in <code>src/gsp/utils/cmap_utils.py</code> <pre><code>class CmapUtils:\n    \"\"\"Utility class for colormap operations. Leverage [matplotlib colormaps](https://matplotlib.org/stable/tutorials/colors/colormaps.html).\"\"\"\n\n    @staticmethod\n    def has_color_map(colormap_name: str) -&gt; bool:\n        \"\"\"Check if the given colormap name is recognized by matplotlib.\n\n        Args:\n            colormap_name (str): Name of the colormap to check.\n\n        Returns:\n            bool: True if the colormap exists, False otherwise.\n        \"\"\"\n        try:\n            matplotlib.cm.get_cmap(colormap_name)\n            return True\n        except ValueError:\n            return False\n\n    @staticmethod\n    def get_color_map(colormap_name: str, values: np.ndarray, vmin: float | None = None, vmax: float | None = None) -&gt; Buffer:\n        \"\"\"Get colors from a colormap for the given values.\n\n        Args:\n            colormap_name (str): Name of the colormap (e.g., 'plasma', 'viridis', etc.).\n            values (np.ndarray): Array of input values to map to colors.\n            vmin (float|None): Minimum value for values normalization. if None, use min of values.\n            vmax (float|None): Maximum value for values normalization. if None, use max of values.\n\n        Returns:\n            Buffer: A Buffer containing the RGBA8 colors mapped from the input values.\n        \"\"\"\n\n        # Handle default parameters\n        vmin = vmin if vmin is not None else values.min()\n        vmax = vmax if vmax is not None else values.max()\n\n        # sanity check\n        assert CmapUtils.has_color_map(colormap_name), f\"Colormap '{colormap_name}' is not recognized.\"\n\n        mpl_color_map = matplotlib.cm.get_cmap(colormap_name)\n\n        # sanity check\n        assert vmin is not None, \"vmin should not be None\"\n        assert vmax is not None, \"vmax should not be None\"\n\n        normalized_values = (values - vmin) / (vmax - vmin)\n        normalized_values = np.clip(normalized_values, 0.0, 1.0)\n        color_mapped_normalized = mpl_color_map(normalized_values)  # normalized values to [0, 1]\n        color_mapped_255 = (color_mapped_normalized * 255).astype(np.uint8)\n\n        # Create a Buffer\n        color_buffer = Buffer(color_mapped_255.__len__(), buffer_type=BufferType.rgba8)\n        color_buffer.set_data(bytearray(color_mapped_255.tobytes()), 0, color_mapped_255.__len__())\n\n        # Return the color buffer\n        return color_buffer\n</code></pre>"},{"location":"api/gsp/#gsp.utils.cmap_utils.CmapUtils.get_color_map","title":"<code>get_color_map(colormap_name: str, values: np.ndarray, vmin: float | None = None, vmax: float | None = None) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Get colors from a colormap for the given values.</p> <p>Parameters:</p> Name Type Description Default <code>colormap_name</code> <code>str</code> <p>Name of the colormap (e.g., 'plasma', 'viridis', etc.).</p> required <code>values</code> <code>numpy.ndarray</code> <p>Array of input values to map to colors.</p> required <code>vmin</code> <code>float | None</code> <p>Minimum value for values normalization. if None, use min of values.</p> <code>None</code> <code>vmax</code> <code>float | None</code> <p>Maximum value for values normalization. if None, use max of values.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.Buffer</code> <p>A Buffer containing the RGBA8 colors mapped from the input values.</p> Source code in <code>src/gsp/utils/cmap_utils.py</code> <pre><code>@staticmethod\ndef get_color_map(colormap_name: str, values: np.ndarray, vmin: float | None = None, vmax: float | None = None) -&gt; Buffer:\n    \"\"\"Get colors from a colormap for the given values.\n\n    Args:\n        colormap_name (str): Name of the colormap (e.g., 'plasma', 'viridis', etc.).\n        values (np.ndarray): Array of input values to map to colors.\n        vmin (float|None): Minimum value for values normalization. if None, use min of values.\n        vmax (float|None): Maximum value for values normalization. if None, use max of values.\n\n    Returns:\n        Buffer: A Buffer containing the RGBA8 colors mapped from the input values.\n    \"\"\"\n\n    # Handle default parameters\n    vmin = vmin if vmin is not None else values.min()\n    vmax = vmax if vmax is not None else values.max()\n\n    # sanity check\n    assert CmapUtils.has_color_map(colormap_name), f\"Colormap '{colormap_name}' is not recognized.\"\n\n    mpl_color_map = matplotlib.cm.get_cmap(colormap_name)\n\n    # sanity check\n    assert vmin is not None, \"vmin should not be None\"\n    assert vmax is not None, \"vmax should not be None\"\n\n    normalized_values = (values - vmin) / (vmax - vmin)\n    normalized_values = np.clip(normalized_values, 0.0, 1.0)\n    color_mapped_normalized = mpl_color_map(normalized_values)  # normalized values to [0, 1]\n    color_mapped_255 = (color_mapped_normalized * 255).astype(np.uint8)\n\n    # Create a Buffer\n    color_buffer = Buffer(color_mapped_255.__len__(), buffer_type=BufferType.rgba8)\n    color_buffer.set_data(bytearray(color_mapped_255.tobytes()), 0, color_mapped_255.__len__())\n\n    # Return the color buffer\n    return color_buffer\n</code></pre>"},{"location":"api/gsp/#gsp.utils.cmap_utils.CmapUtils.has_color_map","title":"<code>has_color_map(colormap_name: str) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Check if the given colormap name is recognized by matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>colormap_name</code> <code>str</code> <p>Name of the colormap to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the colormap exists, False otherwise.</p> Source code in <code>src/gsp/utils/cmap_utils.py</code> <pre><code>@staticmethod\ndef has_color_map(colormap_name: str) -&gt; bool:\n    \"\"\"Check if the given colormap name is recognized by matplotlib.\n\n    Args:\n        colormap_name (str): Name of the colormap to check.\n\n    Returns:\n        bool: True if the colormap exists, False otherwise.\n    \"\"\"\n    try:\n        matplotlib.cm.get_cmap(colormap_name)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils","title":"<code>gsp.utils.group_utils</code>","text":""},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils","title":"<code>GroupUtils</code>","text":"Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>class GroupUtils:\n\n    @staticmethod\n    def get_group_count(vertex_count: int, groups: Groups) -&gt; int:\n        \"\"\"Return the number of groups from the groups object.\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (Groups): groups object\n\n        Returns:\n            int: number of groups\n\n        Raises:\n            NotImplementedError: if the groups object type is not supported\n        \"\"\"\n\n        groups_format = GroupUtils._groups_format(groups)\n        if groups_format == GroupUtils.FORMAT_INT:\n            groups_typed = typing.cast(int, groups)\n            group_count = vertex_count // groups_typed\n        elif groups_format == GroupUtils.FORMAT_LIST_INT:\n            groups_typed = typing.cast(list[int], groups)\n            group_count = len(groups_typed)\n        elif groups_format == GroupUtils.FORMAT_LIST_LIST_INT:\n            groups_typed = typing.cast(list[list[int]], groups)\n            group_count = len(groups_typed)\n        else:\n            raise NotImplementedError(f\"Group buffer shape not supported: {type(groups)}\")\n\n        return group_count\n\n    # =============================================================================\n    # is_instance_of_groups\n    # =============================================================================\n\n    @staticmethod\n    def is_instance_of_groups(groups: Groups) -&gt; bool:\n        \"\"\"Check if the type  of groups.\n        - Deep check where all elements are checked.\n        - Dont check the values themselves, only the types\n\n        groups can be:\n        - int\n        - list[int]\n        - list[list[int]]\n\n        Args:\n            groups (Groups): groups object\n\n        Returns:\n            bool: True if groups is a valid Groups object, False otherwise.\n        \"\"\"\n\n        if isinstance(groups, int):\n            return True\n        elif isinstance(groups, list) and all(isinstance(int_value, int) for int_value in groups):\n            return True\n        elif isinstance(groups, list) and all(isinstance(group, list) for group in groups) and all(isinstance(int_value, int) for int_list in groups for int_value in int_list):  # type: ignore[union-attr]\n            return True\n        else:\n            return False\n\n    # =============================================================================\n    # ._groups_format()\n    # =============================================================================\n\n    FORMAT_INT = \"format_int\"\n    FORMAT_LIST_INT = \"format_list_int\"\n    FORMAT_LIST_LIST_INT = \"format_list_list_int\"\n\n    @staticmethod\n    def _groups_format(groups: Groups) -&gt; Literal[\"format_int\", \"format_list_int\", \"format_list_list_int\"]:\n        \"\"\"Return the format of the groups object as a string.\n        No check is done\n\n        Args:\n            groups (Groups): groups object\n\n        Returns:\n            Literal[\"format_int\", \"format_list_int\", \"format_list_list_int\"]: \"format_int\", \"format_list_int\", \"format_list_list_int\"\n\n        Raises:\n            ValueError: if the groups object is not valid\n        \"\"\"\n\n        if isinstance(groups, int):\n            return GroupUtils.FORMAT_INT\n        elif isinstance(groups, list) and groups.__len__() &gt; 0 and isinstance(groups[0], int):\n            return GroupUtils.FORMAT_LIST_INT\n        elif isinstance(groups, list) and groups.__len__() &gt; 0 and isinstance(groups[0], list) and groups[0].__len__() &gt; 0 and isinstance(groups[0][0], int):\n            return GroupUtils.FORMAT_LIST_LIST_INT\n        else:\n            raise ValueError(f\"Groups object is not valid: {type(groups)}\")\n\n    # =============================================================================\n    # Sanity Checks\n    # =============================================================================\n\n    @staticmethod\n    def sanity_check(vertex_count: int, groups: Groups) -&gt; None:\n        \"\"\"Perform sanity checks on the groups object, raising exceptions if not valid.\n\n        Raise:\n            ValueError: if the groups object is not valid.\n        \"\"\"\n\n        if not GroupUtils.is_instance_of_groups(groups):\n            raise ValueError(f\"Groups object is not valid: {type(groups)}\")\n\n        groups_mode = GroupUtils._groups_format(groups)\n\n        if groups_mode == GroupUtils.FORMAT_INT:\n            groups_int = typing.cast(int, groups)\n            if groups_int &lt;= 0:\n                raise ValueError(f\"Groups as int must be positive, got {groups_int}\")\n            if groups_int &gt; vertex_count:\n                raise ValueError(f\"Groups as int must be less than or equal to vertex_count, got groups={groups_int}, vertex_count={vertex_count}\")\n            if vertex_count % groups_int != 0:\n                raise ValueError(f\"Groups as int must divide vertex_count, got vertex_count={vertex_count}, groups={groups_int}\")\n        elif groups_mode == GroupUtils.FORMAT_LIST_INT:\n            groups_list_int = typing.cast(list[int], groups)\n            if any(group_size &lt;= 0 for group_size in groups_list_int):\n                raise ValueError(f\"Groups as list[int], group sizes must be all positive, got {groups_list_int}\")\n            if sum(groups_list_int) != vertex_count:\n                raise ValueError(\n                    f\"Sum of groups size as list[int] must equal vertex_count, got sum(groups)={sum(groups_list_int)}, vertex_count={vertex_count}\"\n                )\n        elif groups_mode == GroupUtils.FORMAT_LIST_LIST_INT:\n            groups_list_list_int = typing.cast(list[list[int]], groups)\n            all_indices = [index for group in groups_list_list_int for index in group]\n            if any(index &lt; 0 or index &gt;= vertex_count for index in all_indices):\n                raise ValueError(f\"Groups as list[list[int]], all indices must be in range [0, {vertex_count-1}], got indices={all_indices}\")\n            if len(set(all_indices)) != len(all_indices):\n                raise ValueError(f\"Groups as list[list[int]], all indices must be unique, got indices={all_indices}\")\n\n        # TODO check that the list matches the vertex count where needed\n        # TODO check that no list is empty\n\n    @staticmethod\n    def sanity_check_safe(vertex_count: int, groups: Groups) -&gt; bool:\n        \"\"\"Perform sanity checks on the groups object.\n        same as .sanity_check_groups() but dont raise exceptions if not valid\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (Groups): groups object\n\n        Returns:\n            bool: True if the groups object is valid, False otherwise.\n        \"\"\"\n\n        try:\n            GroupUtils.sanity_check(vertex_count, groups)\n            return True\n        except ValueError:\n            return False\n\n    # =============================================================================\n    # .compute_indices_per_group\n    # =============================================================================\n\n    @staticmethod\n    def compute_indices_per_group(vertex_count: int, groups: Groups) -&gt; list[list[int]]:\n        \"\"\"Compute indices_per_group for groups depending on the type of groups\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (Groups): groups object\n\n        Returns:\n            list[list[int]]: list of vertex indices per group\n\n        Raises:\n            NotImplementedError: if the groups object type is not supported\n        \"\"\"\n\n        # sanity check\n        assert GroupUtils.sanity_check_safe(vertex_count, groups), \"groups failed sanity check\"\n\n        groups_format = GroupUtils._groups_format(groups)\n        if groups_format == GroupUtils.FORMAT_INT:\n            groups_typed = typing.cast(int, groups)\n            indices_per_group = GroupUtils._compute_indices_per_group_int(vertex_count, groups_typed)\n        elif groups_format == GroupUtils.FORMAT_LIST_INT:\n            groups_typed = typing.cast(list[int], groups)\n            indices_per_group = GroupUtils._compute_indices_per_group_list_int(vertex_count, groups_typed)\n        elif groups_format == GroupUtils.FORMAT_LIST_LIST_INT:\n            groups_typed = typing.cast(list[list[int]], groups)\n            indices_per_group = GroupUtils._compute_indices_per_group_list_list_int(vertex_count, groups_typed)\n        else:\n            raise NotImplementedError(f\"Group buffer shape not supported: {type(groups)}\")\n\n        return indices_per_group\n\n    # =============================================================================\n    # ._compute_indices_per_group_*() for each format\n    # =============================================================================\n\n    @staticmethod\n    def _compute_indices_per_group_int(vertex_count: int, groups: int) -&gt; list[list[int]]:\n        \"\"\"Compute indices_per_group for groups as int.\n        The int represents the size of each group.\n\n        group_count = vertex_count // groups\n        indices_per_group = list[list[int]]\n\n        Examples:\n        - vertex_count = 6, groups = 2 - divisible - all groups are vertex_count // groups long\n          - indices_per_group = [[0, 1], [2, 3], [4, 5]]\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (int): size of each group\n\n        Returns:\n            list[list[int]]: list of vertex indices per group\n        \"\"\"\n\n        # Initialize output variables\n        group_count: int = vertex_count // groups\n        indices_per_group: list[list[int]] = []\n\n        # Create the indices per group for this case\n        element_count_per_group = groups\n\n        for group_index in range(group_count):\n            start_index = element_count_per_group * group_index\n            end_index = element_count_per_group * (group_index + 1)\n\n            # Fill the indices for this group\n            indices_per_group.append(list(range(start_index, end_index)))\n\n        return indices_per_group\n\n    @staticmethod\n    def _compute_indices_per_group_list_int(vertex_count: int, groups: list[int]) -&gt; list[list[int]]:\n        \"\"\"Compute indices_per_group for groups as list[int].\n        In this case, each int represents the size of each group.\n\n        group_count = len(groups)\n        indices_per_group = list[list[int]]\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (list[int]): list of group sizes\n\n        Returns:\n            list[list[int]]: list of vertex indices per group\n        \"\"\"\n\n        # Initialize output variables\n        indices_per_group: list[list[int]] = []\n\n        # Create the indices per group for this case\n        current_index = 0\n        for group_size in groups:\n            # Fill the indices for this group\n            group_indices = list(range(current_index, current_index + group_size))\n            indices_per_group.append(group_indices)\n\n            # Update the current index\n            current_index += group_size\n\n        return indices_per_group\n\n    @staticmethod\n    def _compute_indices_per_group_list_list_int(vertex_count: int, groups: list[list[int]]) -&gt; list[list[int]]:\n        \"\"\"Compute indices_per_group for groups as list[list[int]].\n        In this case, the groups are directly the indices per group themselves.\n\n        group_count = len(groups)\n        indices_per_group = list[list[int]]\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (list[list[int]]): list of vertex indices per group\n\n        Returns:\n            list[list[int]]: list of vertex indices per group\n        \"\"\"\n\n        # Initialize output variables\n        indices_per_group: list[list[int]] = groups\n\n        return indices_per_group\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.compute_indices_per_group","title":"<code>compute_indices_per_group(vertex_count: int, groups: Groups) -&gt; list[list[int]]</code>  <code>staticmethod</code>","text":"<p>Compute indices_per_group for groups depending on the type of groups</p> <p>Parameters:</p> Name Type Description Default <code>vertex_count</code> <code>int</code> <p>number of vertices</p> required <code>groups</code> <code>gsp.types.group.Groups</code> <p>groups object</p> required <p>Returns:</p> Type Description <code>list[list[int]]</code> <p>list[list[int]]: list of vertex indices per group</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if the groups object type is not supported</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef compute_indices_per_group(vertex_count: int, groups: Groups) -&gt; list[list[int]]:\n    \"\"\"Compute indices_per_group for groups depending on the type of groups\n\n    Args:\n        vertex_count (int): number of vertices\n        groups (Groups): groups object\n\n    Returns:\n        list[list[int]]: list of vertex indices per group\n\n    Raises:\n        NotImplementedError: if the groups object type is not supported\n    \"\"\"\n\n    # sanity check\n    assert GroupUtils.sanity_check_safe(vertex_count, groups), \"groups failed sanity check\"\n\n    groups_format = GroupUtils._groups_format(groups)\n    if groups_format == GroupUtils.FORMAT_INT:\n        groups_typed = typing.cast(int, groups)\n        indices_per_group = GroupUtils._compute_indices_per_group_int(vertex_count, groups_typed)\n    elif groups_format == GroupUtils.FORMAT_LIST_INT:\n        groups_typed = typing.cast(list[int], groups)\n        indices_per_group = GroupUtils._compute_indices_per_group_list_int(vertex_count, groups_typed)\n    elif groups_format == GroupUtils.FORMAT_LIST_LIST_INT:\n        groups_typed = typing.cast(list[list[int]], groups)\n        indices_per_group = GroupUtils._compute_indices_per_group_list_list_int(vertex_count, groups_typed)\n    else:\n        raise NotImplementedError(f\"Group buffer shape not supported: {type(groups)}\")\n\n    return indices_per_group\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.get_group_count","title":"<code>get_group_count(vertex_count: int, groups: Groups) -&gt; int</code>  <code>staticmethod</code>","text":"<p>Return the number of groups from the groups object.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_count</code> <code>int</code> <p>number of vertices</p> required <code>groups</code> <code>gsp.types.group.Groups</code> <p>groups object</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of groups</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if the groups object type is not supported</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef get_group_count(vertex_count: int, groups: Groups) -&gt; int:\n    \"\"\"Return the number of groups from the groups object.\n\n    Args:\n        vertex_count (int): number of vertices\n        groups (Groups): groups object\n\n    Returns:\n        int: number of groups\n\n    Raises:\n        NotImplementedError: if the groups object type is not supported\n    \"\"\"\n\n    groups_format = GroupUtils._groups_format(groups)\n    if groups_format == GroupUtils.FORMAT_INT:\n        groups_typed = typing.cast(int, groups)\n        group_count = vertex_count // groups_typed\n    elif groups_format == GroupUtils.FORMAT_LIST_INT:\n        groups_typed = typing.cast(list[int], groups)\n        group_count = len(groups_typed)\n    elif groups_format == GroupUtils.FORMAT_LIST_LIST_INT:\n        groups_typed = typing.cast(list[list[int]], groups)\n        group_count = len(groups_typed)\n    else:\n        raise NotImplementedError(f\"Group buffer shape not supported: {type(groups)}\")\n\n    return group_count\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.is_instance_of_groups","title":"<code>is_instance_of_groups(groups: Groups) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Check if the type  of groups. - Deep check where all elements are checked. - Dont check the values themselves, only the types</p> <p>groups can be: - int - list[int] - list[list[int]]</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>gsp.types.group.Groups</code> <p>groups object</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if groups is a valid Groups object, False otherwise.</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef is_instance_of_groups(groups: Groups) -&gt; bool:\n    \"\"\"Check if the type  of groups.\n    - Deep check where all elements are checked.\n    - Dont check the values themselves, only the types\n\n    groups can be:\n    - int\n    - list[int]\n    - list[list[int]]\n\n    Args:\n        groups (Groups): groups object\n\n    Returns:\n        bool: True if groups is a valid Groups object, False otherwise.\n    \"\"\"\n\n    if isinstance(groups, int):\n        return True\n    elif isinstance(groups, list) and all(isinstance(int_value, int) for int_value in groups):\n        return True\n    elif isinstance(groups, list) and all(isinstance(group, list) for group in groups) and all(isinstance(int_value, int) for int_list in groups for int_value in int_list):  # type: ignore[union-attr]\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.sanity_check","title":"<code>sanity_check(vertex_count: int, groups: Groups) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Perform sanity checks on the groups object, raising exceptions if not valid.</p> Raise <p>ValueError: if the groups object is not valid.</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef sanity_check(vertex_count: int, groups: Groups) -&gt; None:\n    \"\"\"Perform sanity checks on the groups object, raising exceptions if not valid.\n\n    Raise:\n        ValueError: if the groups object is not valid.\n    \"\"\"\n\n    if not GroupUtils.is_instance_of_groups(groups):\n        raise ValueError(f\"Groups object is not valid: {type(groups)}\")\n\n    groups_mode = GroupUtils._groups_format(groups)\n\n    if groups_mode == GroupUtils.FORMAT_INT:\n        groups_int = typing.cast(int, groups)\n        if groups_int &lt;= 0:\n            raise ValueError(f\"Groups as int must be positive, got {groups_int}\")\n        if groups_int &gt; vertex_count:\n            raise ValueError(f\"Groups as int must be less than or equal to vertex_count, got groups={groups_int}, vertex_count={vertex_count}\")\n        if vertex_count % groups_int != 0:\n            raise ValueError(f\"Groups as int must divide vertex_count, got vertex_count={vertex_count}, groups={groups_int}\")\n    elif groups_mode == GroupUtils.FORMAT_LIST_INT:\n        groups_list_int = typing.cast(list[int], groups)\n        if any(group_size &lt;= 0 for group_size in groups_list_int):\n            raise ValueError(f\"Groups as list[int], group sizes must be all positive, got {groups_list_int}\")\n        if sum(groups_list_int) != vertex_count:\n            raise ValueError(\n                f\"Sum of groups size as list[int] must equal vertex_count, got sum(groups)={sum(groups_list_int)}, vertex_count={vertex_count}\"\n            )\n    elif groups_mode == GroupUtils.FORMAT_LIST_LIST_INT:\n        groups_list_list_int = typing.cast(list[list[int]], groups)\n        all_indices = [index for group in groups_list_list_int for index in group]\n        if any(index &lt; 0 or index &gt;= vertex_count for index in all_indices):\n            raise ValueError(f\"Groups as list[list[int]], all indices must be in range [0, {vertex_count-1}], got indices={all_indices}\")\n        if len(set(all_indices)) != len(all_indices):\n            raise ValueError(f\"Groups as list[list[int]], all indices must be unique, got indices={all_indices}\")\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.sanity_check_safe","title":"<code>sanity_check_safe(vertex_count: int, groups: Groups) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Perform sanity checks on the groups object. same as .sanity_check_groups() but dont raise exceptions if not valid</p> <p>Parameters:</p> Name Type Description Default <code>vertex_count</code> <code>int</code> <p>number of vertices</p> required <code>groups</code> <code>gsp.types.group.Groups</code> <p>groups object</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the groups object is valid, False otherwise.</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef sanity_check_safe(vertex_count: int, groups: Groups) -&gt; bool:\n    \"\"\"Perform sanity checks on the groups object.\n    same as .sanity_check_groups() but dont raise exceptions if not valid\n\n    Args:\n        vertex_count (int): number of vertices\n        groups (Groups): groups object\n\n    Returns:\n        bool: True if the groups object is valid, False otherwise.\n    \"\"\"\n\n    try:\n        GroupUtils.sanity_check(vertex_count, groups)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/gsp/#gsp.utils.math_utils","title":"<code>gsp.utils.math_utils</code>","text":""},{"location":"api/gsp/#gsp.utils.math_utils.MathUtils","title":"<code>MathUtils</code>","text":"Source code in <code>src/gsp/utils/math_utils.py</code> <pre><code>class MathUtils:\n    @staticmethod\n    def apply_mvp_to_vertices(vertices: np.ndarray, model_matrix: np.ndarray, view_matrix: np.ndarray, projection_matrix: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Applies Model-View-Projection transformation to the vertices.\n\n        Args:\n            vertices (np.ndarray): Input vertices of shape (N, 3).\n            model_matrix (np.ndarray): Model matrix of shape (4, 4).\n            view_matrix (np.ndarray): View matrix of shape (4, 4).\n            projection_matrix (np.ndarray): Projection matrix of shape (4, 4).\n        Returns:\n            np.ndarray: Transformed vertices of shape (N, 3).\n        \"\"\"\n\n        # sanity checks\n        assert vertices.ndim == 2 and vertices.shape[1] == 3, f\"Expected vertices shape (N, 3), got {vertices.shape}\"\n        assert model_matrix.shape == (4, 4), f\"Expected model_matrix shape (4, 4), got {model_matrix.shape}\"\n        assert view_matrix.shape == (4, 4), f\"Expected view_matrix shape (4, 4), got {view_matrix.shape}\"\n        assert projection_matrix.shape == (4, 4), f\"Expected projection_matrix shape (4, 4), got {projection_matrix.shape}\"\n\n        # Compute the Model-View-Projection (MVP) matrix\n        mvp_matrix = projection_matrix @ view_matrix @ model_matrix\n\n        # convert vertices to homogeneous coordinates (x, y, z) -&gt; (x, y, z, w=1.0)\n        ws_column = np.ones((vertices.shape[0], 1), dtype=np.float32)\n        vertices_homogeneous = np.hstack((vertices, ws_column))  # shape (N, 4) for N vertices\n\n        # Apply the MVP transformation to the vertices\n        vertices_transformed = (mvp_matrix @ vertices_homogeneous.T).T  # shape (N, 4)\n\n        # Perform perspective division to get normalized device coordinates (NDC)\n        vertices_homo_transformed = vertices_transformed / vertices_transformed[:, 3:4]  # divide by w - shape (N, 4)\n        vertices_3d_transformed = vertices_homo_transformed[:, :3]  # drop w-coordinate - shape (N, 3)\n\n        # NOTE: no need to map NDC to screen coordinates as canvas is drawn directly in NDC coordinates 2d\n        pass\n\n        # return the transformed vertices\n        return vertices_3d_transformed\n</code></pre>"},{"location":"api/gsp/#gsp.utils.math_utils.MathUtils.apply_mvp_to_vertices","title":"<code>apply_mvp_to_vertices(vertices: np.ndarray, model_matrix: np.ndarray, view_matrix: np.ndarray, projection_matrix: np.ndarray) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Applies Model-View-Projection transformation to the vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>numpy.ndarray</code> <p>Input vertices of shape (N, 3).</p> required <code>model_matrix</code> <code>numpy.ndarray</code> <p>Model matrix of shape (4, 4).</p> required <code>view_matrix</code> <code>numpy.ndarray</code> <p>View matrix of shape (4, 4).</p> required <code>projection_matrix</code> <code>numpy.ndarray</code> <p>Projection matrix of shape (4, 4).</p> required <p>Returns:     np.ndarray: Transformed vertices of shape (N, 3).</p> Source code in <code>src/gsp/utils/math_utils.py</code> <pre><code>@staticmethod\ndef apply_mvp_to_vertices(vertices: np.ndarray, model_matrix: np.ndarray, view_matrix: np.ndarray, projection_matrix: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Applies Model-View-Projection transformation to the vertices.\n\n    Args:\n        vertices (np.ndarray): Input vertices of shape (N, 3).\n        model_matrix (np.ndarray): Model matrix of shape (4, 4).\n        view_matrix (np.ndarray): View matrix of shape (4, 4).\n        projection_matrix (np.ndarray): Projection matrix of shape (4, 4).\n    Returns:\n        np.ndarray: Transformed vertices of shape (N, 3).\n    \"\"\"\n\n    # sanity checks\n    assert vertices.ndim == 2 and vertices.shape[1] == 3, f\"Expected vertices shape (N, 3), got {vertices.shape}\"\n    assert model_matrix.shape == (4, 4), f\"Expected model_matrix shape (4, 4), got {model_matrix.shape}\"\n    assert view_matrix.shape == (4, 4), f\"Expected view_matrix shape (4, 4), got {view_matrix.shape}\"\n    assert projection_matrix.shape == (4, 4), f\"Expected projection_matrix shape (4, 4), got {projection_matrix.shape}\"\n\n    # Compute the Model-View-Projection (MVP) matrix\n    mvp_matrix = projection_matrix @ view_matrix @ model_matrix\n\n    # convert vertices to homogeneous coordinates (x, y, z) -&gt; (x, y, z, w=1.0)\n    ws_column = np.ones((vertices.shape[0], 1), dtype=np.float32)\n    vertices_homogeneous = np.hstack((vertices, ws_column))  # shape (N, 4) for N vertices\n\n    # Apply the MVP transformation to the vertices\n    vertices_transformed = (mvp_matrix @ vertices_homogeneous.T).T  # shape (N, 4)\n\n    # Perform perspective division to get normalized device coordinates (NDC)\n    vertices_homo_transformed = vertices_transformed / vertices_transformed[:, 3:4]  # divide by w - shape (N, 4)\n    vertices_3d_transformed = vertices_homo_transformed[:, :3]  # drop w-coordinate - shape (N, 3)\n\n    # NOTE: no need to map NDC to screen coordinates as canvas is drawn directly in NDC coordinates 2d\n    pass\n\n    # return the transformed vertices\n    return vertices_3d_transformed\n</code></pre>"},{"location":"api/gsp/#gsp.utils.transbuf_utils","title":"<code>gsp.utils.transbuf_utils</code>","text":""},{"location":"api/gsp/#gsp.utils.transbuf_utils.TransBufUtils","title":"<code>TransBufUtils</code>","text":"Source code in <code>src/gsp/utils/transbuf_utils.py</code> <pre><code>class TransBufUtils:\n    @staticmethod\n    def to_buffer(trans_buf: TransBuf) -&gt; Buffer:\n        \"\"\"Convert a TransBuf to a Buffer.\"\"\"\n\n        if isinstance(trans_buf, Buffer):\n            buffer = typing.cast(Buffer, trans_buf)\n            return buffer\n        elif isinstance(trans_buf, TransformChain):\n            transform_chain = typing.cast(TransformChain, trans_buf)\n            buffer = transform_chain.run()\n            return buffer\n        else:\n            raise ValueError(f\"Unsupported type for transbuf_to_buffer {type(trans_buf)}\")\n</code></pre>"},{"location":"api/gsp/#gsp.utils.transbuf_utils.TransBufUtils.to_buffer","title":"<code>to_buffer(trans_buf: TransBuf) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Convert a TransBuf to a Buffer.</p> Source code in <code>src/gsp/utils/transbuf_utils.py</code> <pre><code>@staticmethod\ndef to_buffer(trans_buf: TransBuf) -&gt; Buffer:\n    \"\"\"Convert a TransBuf to a Buffer.\"\"\"\n\n    if isinstance(trans_buf, Buffer):\n        buffer = typing.cast(Buffer, trans_buf)\n        return buffer\n    elif isinstance(trans_buf, TransformChain):\n        transform_chain = typing.cast(TransformChain, trans_buf)\n        buffer = transform_chain.run()\n        return buffer\n    else:\n        raise ValueError(f\"Unsupported type for transbuf_to_buffer {type(trans_buf)}\")\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils","title":"<code>gsp.utils.unit_utils</code>","text":""},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils","title":"<code>UnitUtils</code>","text":"Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>class UnitUtils:\n\n    @staticmethod\n    def in_to_cm(inches: float) -&gt; float:\n        \"\"\"Convert inches to centimeters.\n\n        Args:\n            inches (float): Length in inches.\n\n        Returns:\n            float: Length in centimeters.\n        \"\"\"\n        return inches * 2.54\n\n    @staticmethod\n    def cm_to_in(cm: float) -&gt; float:\n        \"\"\"Convert centimeters to inches.\n\n        Args:\n            cm (float): Length in centimeters.\n\n        Returns:\n            float: Length in inches.\n        \"\"\"\n        return cm / 2.54\n\n    @staticmethod\n    def device_pixel_ratio() -&gt; float:\n        \"\"\"Get the device pixel ratio for high-DPI displays.\n\n        Returns:\n            float: Device pixel ratio (typically 1.0 for standard displays, &gt;1.0 for high-DPI).\n        \"\"\"\n        # detect if running on a macOS retina display or other high-DPI display\n        # This is a placeholder implementation; actual detection may vary based on the GUI framework used.\n        is_macosx = \"darwin\" in sys.platform\n        if is_macosx:\n            return 2.0  # Common value for retina displays\n        return 1.0\n\n    @staticmethod\n    def pixel_to_point(pixel_size: float, dpi: float) -&gt; float:\n        \"\"\"Convert pixel size to typographic point size based on DPI.\n\n        Args:\n            pixel_size (float): Size in pixels.\n            dpi (float): Dots per inch of the display.\n\n        Returns:\n            float: Size in points.\n        \"\"\"\n        inches_per_pixel = 1.0 / dpi\n        points_per_inch = 72.0\n        point_size = pixel_size * inches_per_pixel * points_per_inch\n        return point_size\n\n    @staticmethod\n    def point_to_pixel(point_size: float, dpi: float) -&gt; float:\n        \"\"\"Convert point size to pixel size based on DPI.\n\n        Args:\n            point_size (float): Size in points.\n            dpi (float): Dots per inch of the display.\n\n        Returns:\n            float: Size in pixels.\n        \"\"\"\n        inches_per_point = 1.0 / 72.0\n        pixels_per_inch = dpi\n        pixel_size = point_size * inches_per_point * pixels_per_inch\n        return pixel_size\n\n    # =============================================================================\n    # numpy array versions\n    # =============================================================================\n\n    @staticmethod\n    def pixel_to_point_numpy(pixel_sizes: np.ndarray, dpi: float) -&gt; np.ndarray:\n        \"\"\"Convert an array of pixel sizes to point sizes based on DPI.\n        Args:\n            pixel_sizes (np.ndarray): Array of sizes in pixels.\n            dpi (float): Dots per inch of the display.\n        Returns:\n            np.ndarray: Array of sizes in points.\n        \"\"\"\n        inches_per_pixel = 1.0 / dpi\n        points_per_inch = 72.0\n        point_sizes = pixel_sizes * inches_per_pixel * points_per_inch\n        return point_sizes\n\n    @staticmethod\n    def point_to_pixel_numpy(point_sizes: np.ndarray, dpi: float) -&gt; np.ndarray:\n        \"\"\"Convert an array of point sizes to pixel sizes based on DPI.\n\n        Args:\n            point_sizes (np.ndarray): Array of sizes in points.\n            dpi (float): Dots per inch of the display.\n\n        Returns:\n            np.ndarray: Array of sizes in pixels.\n        \"\"\"\n        inches_per_point = 1.0 / 72.0\n        pixels_per_inch = dpi\n        pixel_sizes = point_sizes * inches_per_point * pixels_per_inch\n        return pixel_sizes\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.cm_to_in","title":"<code>cm_to_in(cm: float) -&gt; float</code>  <code>staticmethod</code>","text":"<p>Convert centimeters to inches.</p> <p>Parameters:</p> Name Type Description Default <code>cm</code> <code>float</code> <p>Length in centimeters.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length in inches.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef cm_to_in(cm: float) -&gt; float:\n    \"\"\"Convert centimeters to inches.\n\n    Args:\n        cm (float): Length in centimeters.\n\n    Returns:\n        float: Length in inches.\n    \"\"\"\n    return cm / 2.54\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.device_pixel_ratio","title":"<code>device_pixel_ratio() -&gt; float</code>  <code>staticmethod</code>","text":"<p>Get the device pixel ratio for high-DPI displays.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Device pixel ratio (typically 1.0 for standard displays, &gt;1.0 for high-DPI).</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef device_pixel_ratio() -&gt; float:\n    \"\"\"Get the device pixel ratio for high-DPI displays.\n\n    Returns:\n        float: Device pixel ratio (typically 1.0 for standard displays, &gt;1.0 for high-DPI).\n    \"\"\"\n    # detect if running on a macOS retina display or other high-DPI display\n    # This is a placeholder implementation; actual detection may vary based on the GUI framework used.\n    is_macosx = \"darwin\" in sys.platform\n    if is_macosx:\n        return 2.0  # Common value for retina displays\n    return 1.0\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.in_to_cm","title":"<code>in_to_cm(inches: float) -&gt; float</code>  <code>staticmethod</code>","text":"<p>Convert inches to centimeters.</p> <p>Parameters:</p> Name Type Description Default <code>inches</code> <code>float</code> <p>Length in inches.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length in centimeters.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef in_to_cm(inches: float) -&gt; float:\n    \"\"\"Convert inches to centimeters.\n\n    Args:\n        inches (float): Length in inches.\n\n    Returns:\n        float: Length in centimeters.\n    \"\"\"\n    return inches * 2.54\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.pixel_to_point","title":"<code>pixel_to_point(pixel_size: float, dpi: float) -&gt; float</code>  <code>staticmethod</code>","text":"<p>Convert pixel size to typographic point size based on DPI.</p> <p>Parameters:</p> Name Type Description Default <code>pixel_size</code> <code>float</code> <p>Size in pixels.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch of the display.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Size in points.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef pixel_to_point(pixel_size: float, dpi: float) -&gt; float:\n    \"\"\"Convert pixel size to typographic point size based on DPI.\n\n    Args:\n        pixel_size (float): Size in pixels.\n        dpi (float): Dots per inch of the display.\n\n    Returns:\n        float: Size in points.\n    \"\"\"\n    inches_per_pixel = 1.0 / dpi\n    points_per_inch = 72.0\n    point_size = pixel_size * inches_per_pixel * points_per_inch\n    return point_size\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.pixel_to_point_numpy","title":"<code>pixel_to_point_numpy(pixel_sizes: np.ndarray, dpi: float) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Convert an array of pixel sizes to point sizes based on DPI. Args:     pixel_sizes (np.ndarray): Array of sizes in pixels.     dpi (float): Dots per inch of the display. Returns:     np.ndarray: Array of sizes in points.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef pixel_to_point_numpy(pixel_sizes: np.ndarray, dpi: float) -&gt; np.ndarray:\n    \"\"\"Convert an array of pixel sizes to point sizes based on DPI.\n    Args:\n        pixel_sizes (np.ndarray): Array of sizes in pixels.\n        dpi (float): Dots per inch of the display.\n    Returns:\n        np.ndarray: Array of sizes in points.\n    \"\"\"\n    inches_per_pixel = 1.0 / dpi\n    points_per_inch = 72.0\n    point_sizes = pixel_sizes * inches_per_pixel * points_per_inch\n    return point_sizes\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.point_to_pixel","title":"<code>point_to_pixel(point_size: float, dpi: float) -&gt; float</code>  <code>staticmethod</code>","text":"<p>Convert point size to pixel size based on DPI.</p> <p>Parameters:</p> Name Type Description Default <code>point_size</code> <code>float</code> <p>Size in points.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch of the display.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Size in pixels.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef point_to_pixel(point_size: float, dpi: float) -&gt; float:\n    \"\"\"Convert point size to pixel size based on DPI.\n\n    Args:\n        point_size (float): Size in points.\n        dpi (float): Dots per inch of the display.\n\n    Returns:\n        float: Size in pixels.\n    \"\"\"\n    inches_per_point = 1.0 / 72.0\n    pixels_per_inch = dpi\n    pixel_size = point_size * inches_per_point * pixels_per_inch\n    return pixel_size\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.point_to_pixel_numpy","title":"<code>point_to_pixel_numpy(point_sizes: np.ndarray, dpi: float) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Convert an array of point sizes to pixel sizes based on DPI.</p> <p>Parameters:</p> Name Type Description Default <code>point_sizes</code> <code>numpy.ndarray</code> <p>Array of sizes in points.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch of the display.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Array of sizes in pixels.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef point_to_pixel_numpy(point_sizes: np.ndarray, dpi: float) -&gt; np.ndarray:\n    \"\"\"Convert an array of point sizes to pixel sizes based on DPI.\n\n    Args:\n        point_sizes (np.ndarray): Array of sizes in points.\n        dpi (float): Dots per inch of the display.\n\n    Returns:\n        np.ndarray: Array of sizes in pixels.\n    \"\"\"\n    inches_per_point = 1.0 / 72.0\n    pixels_per_inch = dpi\n    pixel_sizes = point_sizes * inches_per_point * pixels_per_inch\n    return pixel_sizes\n</code></pre>"},{"location":"api/gsp/#gsp.utils.uuid_utils","title":"<code>gsp.utils.uuid_utils</code>","text":""},{"location":"api/gsp/#gsp.utils.uuid_utils.UuidUtils","title":"<code>UuidUtils</code>","text":"<p>Utility class for generating UUIDs.</p> Source code in <code>src/gsp/utils/uuid_utils.py</code> <pre><code>class UuidUtils:\n    \"\"\"Utility class for generating UUIDs.\"\"\"\n\n    GSP_UUID_COUNTER: int = 0\n\n    @staticmethod\n    def generate_uuid() -&gt; str:\n        \"\"\"Generate a UUID version 4.\n\n        Returns:\n            str: The generated UUID.\n        \"\"\"\n\n        # if GSP_UUID_COUNTER is set, use a deterministic uuid for testing purposes\n        # - uuid becomes \"uuid-counter-&lt;counter&gt;\"\n        if \"GSP_UUID_COUNTER\" in os.environ:\n            _uuid = UuidUtils.GSP_UUID_COUNTER\n            UuidUtils.GSP_UUID_COUNTER += 1\n            return f\"uuid-counter-{_uuid}\"\n\n        # uuid4 = UuidUtils._generate_uuid_v4_with_uuid()\n        uuid4 = UuidUtils._generate_uuid_v4_with_numpy()\n        return uuid4\n\n    @staticmethod\n    def _generate_uuid_v4_with_numpy() -&gt; str:\n        \"\"\"generate a UUID version 4 using numpy for random byte generation.\n\n        Thus it can be made deterministic by setting the numpy random seed.\n        \"\"\"\n        # 1. Generate 16 random bytes (128 bits) using numpy\n        # We use uint8 for byte representation\n        random_bytes = np.random.randint(0, 256, size=16, dtype=np.uint8)\n\n        # Convert the numpy array of bytes into a standard Python byte string\n        # This is necessary because bit manipulation on numpy arrays is tricky/non-standard\n        byte_string = bytes(random_bytes.tolist())\n\n        # 2. Apply the UUID version 4 (variant 1) rules:\n\n        # Rule 1: Set the four most significant bits of the 7th byte (octet 6) to 0100_2\n        # This sets the UUID version to 4.\n        # The 7th byte is at index 6 (0-indexed).\n        # To set the first four bits to 0100 (4 in hex), we clear the upper 4 bits\n        # and then set them to 4. (byte_string[6] &amp; 0b1111) clears the upper bits,\n        # then | 0x40 is wrong. It should be (byte_string[6] &amp; 0x0F) | 0x40.\n\n        # We must use a mutable structure to modify the bytes.\n        # We'll use a standard Python list of integers (0-255) for easy modification.\n        byte_list = list(byte_string)\n\n        # Set Version (byte 6, index 6): 0x40 (0100xxxx)\n        byte_list[6] = (byte_list[6] &amp; 0x0F) | 0x40\n\n        # Rule 2: Set the two most significant bits of the 9th byte (octet 8) to 10_2\n        # This sets the UUID variant to 'Reserved (RFC 4122)'.\n        # The 9th byte is at index 8.\n        # To set the first two bits to 10 (8 in hex or 0x80), we clear the upper 2 bits\n        # and then set them to 10. (byte_list[8] &amp; 0x3F) clears the upper 2 bits,\n        # then | 0x80 sets them to 10.\n        byte_list[8] = (byte_list[8] &amp; 0x3F) | 0x80\n\n        # 3. Format the bytes into a standard UUID string format (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)\n        # We convert the list back to bytes and then to hexadecimal.\n        final_bytes = bytes(byte_list)\n        hex_str = final_bytes.hex()\n\n        # Insert hyphens\n        uuid_v4 = f\"{hex_str[0:8]}-{hex_str[8:12]}-{hex_str[12:16]}-{hex_str[16:20]}-{hex_str[20:32]}\"\n\n        return uuid_v4\n\n    @staticmethod\n    def _generate_uuid_v4_with_uuid() -&gt; str:\n        \"\"\"Generate a UUID version 4 using the standard library uuid module.\"\"\"\n        import uuid\n\n        uuid_v4 = str(uuid.uuid4())\n\n        return uuid_v4\n</code></pre>"},{"location":"api/gsp/#gsp.utils.uuid_utils.UuidUtils.generate_uuid","title":"<code>generate_uuid() -&gt; str</code>  <code>staticmethod</code>","text":"<p>Generate a UUID version 4.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated UUID.</p> Source code in <code>src/gsp/utils/uuid_utils.py</code> <pre><code>@staticmethod\ndef generate_uuid() -&gt; str:\n    \"\"\"Generate a UUID version 4.\n\n    Returns:\n        str: The generated UUID.\n    \"\"\"\n\n    # if GSP_UUID_COUNTER is set, use a deterministic uuid for testing purposes\n    # - uuid becomes \"uuid-counter-&lt;counter&gt;\"\n    if \"GSP_UUID_COUNTER\" in os.environ:\n        _uuid = UuidUtils.GSP_UUID_COUNTER\n        UuidUtils.GSP_UUID_COUNTER += 1\n        return f\"uuid-counter-{_uuid}\"\n\n    # uuid4 = UuidUtils._generate_uuid_v4_with_uuid()\n    uuid4 = UuidUtils._generate_uuid_v4_with_numpy()\n    return uuid4\n</code></pre>"},{"location":"api/gsp/#constants","title":"Constants","text":""},{"location":"api/gsp/#gsp.constants","title":"<code>gsp.constants</code>","text":""},{"location":"api/gsp/#gsp.constants.Constants","title":"<code>Constants</code>","text":"<p>Common constants in GSP. e.g. colors.</p> Source code in <code>src/gsp/constants.py</code> <pre><code>class Constants:\n    \"\"\"Common constants in GSP. e.g. colors.\"\"\"\n\n    class Color:\n        \"\"\"\n        Common colors as RGBA bytearrays. Each color is represented as a bytearray of four integers\n        corresponding to the red, green, blue, and alpha (opacity) channels, respectively.\n        Each channel value ranges from 0 to 255.\n        \"\"\"\n\n        white = bytearray([255, 255, 255, 255])\n        black = bytearray([0, 0, 0, 255])\n        red = bytearray([255, 0, 0, 255])\n        green = bytearray([0, 255, 0, 255])\n        blue = bytearray([0, 0, 255, 255])\n\n        yellow = bytearray([255, 255, 0, 255])\n        magenta = bytearray([255, 0, 255, 255])\n        cyan = bytearray([0, 255, 255, 255])\n\n        transparent = bytearray([0, 0, 0, 0])\n</code></pre>"},{"location":"api/gsp/#gsp.constants.Constants.Color","title":"<code>Color</code>","text":"<p>Common colors as RGBA bytearrays. Each color is represented as a bytearray of four integers corresponding to the red, green, blue, and alpha (opacity) channels, respectively. Each channel value ranges from 0 to 255.</p> Source code in <code>src/gsp/constants.py</code> <pre><code>class Color:\n    \"\"\"\n    Common colors as RGBA bytearrays. Each color is represented as a bytearray of four integers\n    corresponding to the red, green, blue, and alpha (opacity) channels, respectively.\n    Each channel value ranges from 0 to 255.\n    \"\"\"\n\n    white = bytearray([255, 255, 255, 255])\n    black = bytearray([0, 0, 0, 255])\n    red = bytearray([255, 0, 0, 255])\n    green = bytearray([0, 255, 0, 255])\n    blue = bytearray([0, 0, 255, 255])\n\n    yellow = bytearray([255, 255, 0, 255])\n    magenta = bytearray([255, 0, 255, 255])\n    cyan = bytearray([0, 255, 255, 255])\n\n    transparent = bytearray([0, 0, 0, 0])\n</code></pre>"},{"location":"api/gsp_datoviz/","title":"GSP Datoviz API Reference","text":"<p>The GSP Datoviz backend provides high-performance rendering using the Datoviz library.</p>"},{"location":"api/gsp_datoviz/#overview","title":"Overview","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz","title":"<code>gsp_datoviz</code>","text":""},{"location":"api/gsp_datoviz/#renderer-module","title":"Renderer Module","text":"<p>The renderer module contains the main Datoviz renderer implementation and specialized renderers for different visual types.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer","title":"<code>gsp_datoviz.renderer</code>","text":""},{"location":"api/gsp_datoviz/#datoviz-renderer","title":"Datoviz Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer","title":"<code>gsp_datoviz.renderer.datoviz_renderer</code>","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer","title":"<code>DatovizRenderer</code>","text":"<p>               Bases: <code>gsp.types.renderer_base.RendererBase</code></p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>class DatovizRenderer(RendererBase):\n    def __init__(self, canvas: Canvas, offscreen: bool = False) -&gt; None:\n        self._canvas = canvas\n        self._dvz_app: dvz.App = dvz.App(background=\"white\", offscreen=offscreen)\n        self._dvz_offscreen = offscreen\n        self._dvz_figure: _DvzFigure = self._dvz_app.figure(\n            width=canvas.get_width(),\n            height=canvas.get_height(),\n        )\n        self._dvz_panels: dict[str, _DvzPanel] = {}\n        \"\"\"datoviz panel per gsp viewport UUID\"\"\"\n        self._dvz_visuals: dict[str, _DvzVisual] = {}\n        \"\"\"datoviz visual per gsp visual group UUID\"\"\"\n\n        self._group_count: dict[str, int] = {}\n        \"\"\"group count per visual UUID\"\"\"\n\n    def close(self) -&gt; None:\n        self._dvz_app.destroy()\n\n    def get_canvas(self) -&gt; Canvas:\n        return self._canvas\n\n    def get_dvz_app(self) -&gt; dvz.App:\n        return self._dvz_app\n\n    def get_dvz_figure(self) -&gt; _DvzFigure:\n        return self._dvz_figure\n\n    def show(self) -&gt; None:\n\n        # handle non-interactive mode for tests\n        in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n        if in_test:\n            return\n\n        # listen to keyboard events - if 'q' is pressed, stop the app\n        @self._dvz_app.connect(self._dvz_figure)\n        def on_keyboard(event):\n            # print(f\"{event.key_event()} key {event.key()} ({event.key_name()})\")\n            if event.key_event() == \"press\" and event.key_name() == \"q\":\n                self._dvz_app.stop()\n\n        # run the datoviz app to show the window\n        self._dvz_app.run()\n\n    # =============================================================================\n    # .render() function\n    # =============================================================================\n    def render(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n        return_image: bool = True,  # NOTE: make False by default. datoviz screenshot can cause segmentation fault in some cases\n        image_format: str = \"png\",\n    ) -&gt; bytes:\n        # =============================================================================\n        # Create all viewport if needed\n        # =============================================================================\n\n        for viewport in viewports:\n            _dvz_panel = self._getOrCreateDvzPanel(viewport)\n\n        # =============================================================================\n        # Render all visual\n        # =============================================================================\n\n        for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n            self._render_visual(viewport, visual, model_matrix, camera)\n\n        # =============================================================================\n        # Return an image if needed\n        # =============================================================================\n\n        # sanity check\n        has_offscreen = bool(self._dvz_app.c_flags | dvz.APP_FLAGS_OFFSCREEN)\n        if return_image and not has_offscreen:\n            raise Exception(\"DatovizRenderer.render(): cannot return image when datoviz App is not in offscreen mode\")\n\n        rendered_image = b\"\"\n        if return_image:\n            if self._dvz_offscreen is True:\n                assert image_format in [\"png\"], f\"Unsupported image format: {image_format}\"\n                image_path = pathlib.Path(__file__).parent / \"_datoviz_offscreen_python.png\"\n                self._dvz_app.screenshot(self._dvz_figure, str(image_path))\n                with open(image_path, \"rb\") as file_reader:\n                    rendered_image = file_reader.read()\n                image_path.unlink()\n            else:\n                # NOTE: datoviz requires the datoviz App to be in offscreen mode to capture screenshot\n                # - this is a workaround to init a temporary offscreen datoviz App to capture the image\n\n                # Init a temporary offscreen datoviz renderer to capture the image\n                _renderer_offscreen = DatovizRenderer(self._canvas, offscreen=True)\n                # do render call\n                rendered_image = _renderer_offscreen.render(viewports, visuals, model_matrices, cameras, return_image=True)\n                # close the offscreen renderer\n                _renderer_offscreen.close()\n\n        return rendered_image\n\n    # =============================================================================\n    # ._render_pixels()\n    # =============================================================================\n\n    def _render_visual(self, viewport: Viewport, visual: VisualBase, model_matrix: TransBuf, camera: Camera) -&gt; None:\n        if isinstance(visual, Pixels):\n            from .datoviz_renderer_pixels import DatovizRendererPixels\n\n            DatovizRendererPixels.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Points):\n            from .datoviz_renderer_points import DatovizRendererPoints\n\n            DatovizRendererPoints.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Paths):\n            from .datoviz_renderer_paths import DatovizRendererPaths\n\n            DatovizRendererPaths.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Markers):\n            from .datoviz_renderer_markers import DatovizRendererMarkers\n\n            DatovizRendererMarkers.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Segments):\n            from .datoviz_renderer_segments import DatovizRendererSegments\n\n            DatovizRendererSegments.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Texts):\n            from .datoviz_renderer_texts import DatovizRendererTexts\n\n            DatovizRendererTexts.render(self, viewport, visual, model_matrix, camera)\n        else:\n            raise NotImplementedError(f\"DatovizRenderer.render() does not support visual of type {type(visual)}\")\n\n    # =============================================================================\n    # Get or create datoviz panel for viewport\n    # =============================================================================\n\n    def _getOrCreateDvzPanel(self, viewport: Viewport) -&gt; _DvzPanel:\n        viewport_uuid = viewport.get_uuid()\n        # if it already exists, return it\n        if viewport_uuid in self._dvz_panels:\n            return self._dvz_panels[viewport_uuid]\n\n        # create the datoviz panel\n        dvz_offset = (viewport.get_x(), self.get_canvas().get_height() - viewport.get_y() - viewport.get_height())\n        # dvz_offset = (viewport.get_x(), viewport.get_y())\n        dvz_size = (viewport.get_width(), viewport.get_height())\n        dvz_panel = self._dvz_figure.panel(\n            offset=dvz_offset,\n            size=dvz_size,\n        )\n\n        # store it\n        self._dvz_panels[viewport_uuid] = dvz_panel\n\n        # return newly created panel\n        return dvz_panel\n</code></pre>"},{"location":"api/gsp_datoviz/#markers-renderer","title":"Markers Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_markers","title":"<code>gsp_datoviz.renderer.datoviz_renderer_markers</code>","text":""},{"location":"api/gsp_datoviz/#paths-renderer","title":"Paths Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_paths","title":"<code>gsp_datoviz.renderer.datoviz_renderer_paths</code>","text":""},{"location":"api/gsp_datoviz/#pixels-renderer","title":"Pixels Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_pixels","title":"<code>gsp_datoviz.renderer.datoviz_renderer_pixels</code>","text":""},{"location":"api/gsp_datoviz/#points-renderer","title":"Points Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_points","title":"<code>gsp_datoviz.renderer.datoviz_renderer_points</code>","text":""},{"location":"api/gsp_datoviz/#segments-renderer","title":"Segments Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_segments","title":"<code>gsp_datoviz.renderer.datoviz_renderer_segments</code>","text":""},{"location":"api/gsp_datoviz/#texts-renderer","title":"Texts Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_texts","title":"<code>gsp_datoviz.renderer.datoviz_renderer_texts</code>","text":""},{"location":"api/gsp_datoviz/#utils-module","title":"Utils Module","text":"<p>The utils module provides converter utilities for the Datoviz backend.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils","title":"<code>gsp_datoviz.utils</code>","text":""},{"location":"api/gsp_datoviz/#converter-utils","title":"Converter Utils","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils","title":"<code>gsp_datoviz.utils.converter_utils</code>","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils.ConverterUtils","title":"<code>ConverterUtils</code>","text":"<p>Utility class for converting GSP types to Datoviz types.</p> Source code in <code>src/gsp_datoviz/utils/converter_utils.py</code> <pre><code>class ConverterUtils:\n    \"\"\"Utility class for converting GSP types to Datoviz types.\"\"\"\n\n    @staticmethod\n    def cap_style_gsp_to_dvz(cap_style: CapStyle) -&gt; str:\n        \"\"\"Convert CapStyle enum to Datoviz string.\"\"\"\n\n        if cap_style == CapStyle.BUTT:\n            return \"butt\"\n        elif cap_style == CapStyle.ROUND:\n            return \"round\"\n        elif cap_style == CapStyle.PROJECTING:\n            return \"square\"\n        else:\n            raise ValueError(f\"Unsupported CapStyle: {cap_style}\")\n\n    @staticmethod\n    def join_style_gsp_to_dvz(join_style: JoinStyle) -&gt; str:\n        \"\"\"Convert JoinStyle enum to Datoviz string.\"\"\"\n        if join_style == JoinStyle.MITER:\n            raise ValueError(f\"Unsupported JoinStyle in datoviz: {join_style}\")\n        elif join_style == JoinStyle.ROUND:\n            return \"round\"\n        elif join_style == JoinStyle.BEVEL:\n            return \"square\"\n        else:\n            raise ValueError(f\"Unsupported JoinStyle: {join_style}\")\n\n    @staticmethod\n    def marker_shape_gsp_to_dvz(gsp_marker_shape: MarkerShape) -&gt; str:\n        \"\"\"Convert GSP marker shape to Datoviz marker shape.\"\"\"\n\n        if gsp_marker_shape == MarkerShape.disc:\n            mpl_marker_shape = \"disc\"\n        elif gsp_marker_shape == MarkerShape.square:\n            mpl_marker_shape = \"square\"\n        elif gsp_marker_shape == MarkerShape.club:\n            mpl_marker_shape = \"club\"\n        else:\n            raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n        return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils.ConverterUtils.cap_style_gsp_to_dvz","title":"<code>cap_style_gsp_to_dvz(cap_style: CapStyle) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert CapStyle enum to Datoviz string.</p> Source code in <code>src/gsp_datoviz/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef cap_style_gsp_to_dvz(cap_style: CapStyle) -&gt; str:\n    \"\"\"Convert CapStyle enum to Datoviz string.\"\"\"\n\n    if cap_style == CapStyle.BUTT:\n        return \"butt\"\n    elif cap_style == CapStyle.ROUND:\n        return \"round\"\n    elif cap_style == CapStyle.PROJECTING:\n        return \"square\"\n    else:\n        raise ValueError(f\"Unsupported CapStyle: {cap_style}\")\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils.ConverterUtils.join_style_gsp_to_dvz","title":"<code>join_style_gsp_to_dvz(join_style: JoinStyle) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert JoinStyle enum to Datoviz string.</p> Source code in <code>src/gsp_datoviz/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef join_style_gsp_to_dvz(join_style: JoinStyle) -&gt; str:\n    \"\"\"Convert JoinStyle enum to Datoviz string.\"\"\"\n    if join_style == JoinStyle.MITER:\n        raise ValueError(f\"Unsupported JoinStyle in datoviz: {join_style}\")\n    elif join_style == JoinStyle.ROUND:\n        return \"round\"\n    elif join_style == JoinStyle.BEVEL:\n        return \"square\"\n    else:\n        raise ValueError(f\"Unsupported JoinStyle: {join_style}\")\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils.ConverterUtils.marker_shape_gsp_to_dvz","title":"<code>marker_shape_gsp_to_dvz(gsp_marker_shape: MarkerShape) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert GSP marker shape to Datoviz marker shape.</p> Source code in <code>src/gsp_datoviz/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef marker_shape_gsp_to_dvz(gsp_marker_shape: MarkerShape) -&gt; str:\n    \"\"\"Convert GSP marker shape to Datoviz marker shape.\"\"\"\n\n    if gsp_marker_shape == MarkerShape.disc:\n        mpl_marker_shape = \"disc\"\n    elif gsp_marker_shape == MarkerShape.square:\n        mpl_marker_shape = \"square\"\n    elif gsp_marker_shape == MarkerShape.club:\n        mpl_marker_shape = \"club\"\n    else:\n        raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n    return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_matplotlib/","title":"GSP Matplotlib API Reference","text":"<p>The GSP Matplotlib backend provides rendering using the Matplotlib library, enabling integration with the Python scientific visualization ecosystem.</p>"},{"location":"api/gsp_matplotlib/#overview","title":"Overview","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib","title":"<code>gsp_matplotlib</code>","text":""},{"location":"api/gsp_matplotlib/#renderer-module","title":"Renderer Module","text":"<p>The renderer module contains the main Matplotlib renderer implementation and specialized renderers for different visual types.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer","title":"<code>gsp_matplotlib.renderer</code>","text":""},{"location":"api/gsp_matplotlib/#matplotlib-renderer","title":"Matplotlib Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer</code>","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer","title":"<code>MatplotlibRenderer</code>","text":"<p>               Bases: <code>gsp.types.renderer_base.RendererBase</code></p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>class MatplotlibRenderer(RendererBase):\n\n    def __init__(self, canvas: Canvas):\n        self.canvas = canvas\n        # Store mapping of viewport UUIDs to axes\n        self._axes: dict[str, matplotlib.axes.Axes] = {}\n        # Store mapping of visual UUIDs to matplotlib artists\n        self._artists: dict[str, matplotlib.artist.Artist] = {}\n        # Store group count per visual UUID\n        self._group_count: dict[str, int] = {}\n\n        # Create a figure\n        figure_width = canvas.get_width() / canvas.get_dpi()\n        figure_height = canvas.get_height() / canvas.get_dpi()\n        self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=canvas.get_dpi())\n        assert self._figure.canvas.manager is not None, f\"matplotlib figure canvas manager is None\"\n        self._figure.canvas.manager.set_window_title(\"Matplotlib\")\n\n    def get_canvas(self) -&gt; Canvas:\n        return self.canvas\n\n    def close(self) -&gt; None:\n        # warnings.warn(f\"Closing NetworkRenderer does not release any resources.\", UserWarning)\n        # stop the event loop if any - thus .show(block=True) will return\n        self._figure.canvas.stop_event_loop()\n        # close the figure\n        matplotlib.pyplot.close(self._figure)\n        self._figure = None  # type: ignore\n\n    def show(self) -&gt; None:\n        # handle non-interactive mode for tests\n        in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n        if in_test:\n            return\n\n        matplotlib.pyplot.show()\n\n    def render(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n        return_image: bool = True,\n        image_format: str = \"png\",\n    ) -&gt; bytes:\n\n        # =============================================================================\n        # Sanity checks\n        # =============================================================================\n\n        assert (\n            len(viewports) == len(visuals) == len(model_matrices) == len(cameras)\n        ), f\"All length MUST be equal. Mismatched lengths: {len(viewports)} viewports, {len(visuals)} visuals, {len(model_matrices)} model matrices, {len(cameras)} cameras\"\n\n        # =============================================================================\n        # Create all the axes if needed\n        # =============================================================================\n        for viewport in viewports:\n            if viewport.get_uuid() in self._axes:\n                continue\n            axes_rect = (\n                viewport.get_x() / self.canvas.get_width(),\n                viewport.get_y() / self.canvas.get_height(),\n                viewport.get_width() / self.canvas.get_width(),\n                viewport.get_height() / self.canvas.get_height(),\n            )\n            axes: matplotlib.axes.Axes = matplotlib.pyplot.axes(axes_rect)\n            # this should be -1 to 1 - from normalized device coordinates - https://en.wikipedia.org/wiki/Graphics_pipeline\n            # - https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection\n            axes.set_xlim(-1, 1)\n            axes.set_ylim(-1, 1)\n            # hide the borders\n            axes.axis(\"off\")\n            # store axes for this viewport\n            self._axes[viewport.get_uuid()] = axes\n\n        # =============================================================================\n        # Render each visual\n        # =============================================================================\n\n        for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n            self._render_visual(viewport, visual, model_matrix, camera)\n\n        # =============================================================================\n        # Render the output image\n        # =============================================================================\n        image_png_data = b\"\"\n\n        # honor return_image option\n        if return_image:\n            # Render the image to a PNG buffer\n            image_png_buffer = io.BytesIO()\n            self._figure.savefig(image_png_buffer, format=image_format, dpi=self.canvas.get_dpi())\n\n            image_png_buffer.seek(0)\n            image_png_data = image_png_buffer.getvalue()\n            image_png_buffer.close()\n\n        return image_png_data\n\n    def _render_visual(self, viewport: Viewport, visual: VisualBase, model_matrix: TransBuf, camera: Camera):\n        \"\"\"Render a single visual in a given viewport using the specified camera.\"\"\"\n\n        if isinstance(visual, Pixels):\n            from gsp_matplotlib.renderer.matplotlib_renderer_pixels import RendererPixels\n\n            RendererPixels.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Points):\n            from gsp_matplotlib.renderer.matplotlib_renderer_points import RendererPoints\n\n            RendererPoints.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Paths):\n            from gsp_matplotlib.renderer.matplotlib_renderer_paths import RendererPaths\n\n            RendererPaths.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Markers):\n            from gsp_matplotlib.renderer.matplotlib_renderer_markers import RendererMarkers\n\n            RendererMarkers.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Segments):\n            from gsp_matplotlib.renderer.matplotlib_renderer_segments import RendererSegments\n\n            RendererSegments.render(self, viewport, visual, model_matrix, camera)\n\n        elif isinstance(visual, Texts):\n            from gsp_matplotlib.renderer.matplotlib_renderer_texts import RendererTexts\n\n            RendererTexts.render(self, viewport, visual, model_matrix, camera)\n        else:\n            raise NotImplementedError(f\"Rendering for visual type {type(visual)} is not implemented.\")\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    def get_mpl_axes_for_viewport(self, viewport: Viewport) -&gt; matplotlib.axes.Axes:\n        return self._axes[viewport.get_uuid()]\n\n    def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n        return self._figure\n</code></pre>"},{"location":"api/gsp_matplotlib/#markers-renderer","title":"Markers Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_markers","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_markers</code>","text":""},{"location":"api/gsp_matplotlib/#paths-renderer","title":"Paths Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_paths","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_paths</code>","text":""},{"location":"api/gsp_matplotlib/#pixels-renderer","title":"Pixels Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_pixels</code>","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels.RendererPixels","title":"<code>RendererPixels</code>","text":"Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_pixels.py</code> <pre><code>class RendererPixels:\n    @staticmethod\n    def render(\n        renderer: MatplotlibRenderer,\n        viewport: Viewport,\n        pixels: Pixels,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; list[matplotlib.artist.Artist]:\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(pixels.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 2D - shape (N, 2)\n        vertices_2d = vertices_3d_transformed[:, :2]\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        # Convert all attributes to buffer\n        color_buffer = TransBufUtils.to_buffer(pixels.get_colors())\n\n        # Convert buffers to numpy arrays\n        colors_numpy = Bufferx.to_numpy(color_buffer) / 255.0  # normalize to [0, 1] range\n\n        # Sanity check - check visual attributes\n        Pixels.sanity_check_attribute_buffers(vertices_buffer, color_buffer, pixels.get_groups())\n\n        # =============================================================================\n        #   Compute indices_per_group for groups depending on the type of groups\n        # =============================================================================\n\n        indices_per_group = GroupUtils.compute_indices_per_group(vertices_numpy.__len__(), pixels.get_groups())\n        group_count = GroupUtils.get_group_count(vertices_numpy.__len__(), pixels.get_groups())\n\n        # =============================================================================\n        # Create the artists if needed\n        # =============================================================================\n\n        artist_uuid_prefix = f\"{viewport.get_uuid()}_{pixels.get_uuid()}\"\n\n        # update stored group count\n        old_group_count = None\n        if artist_uuid_prefix in renderer._group_count:\n            old_group_count = renderer._group_count[artist_uuid_prefix]\n        renderer._group_count[artist_uuid_prefix] = group_count\n\n        # If the group count has changed, destroy old artists\n        if old_group_count is not None and old_group_count != group_count:\n            RendererPixels.destroy_artists(renderer, viewport, pixels, old_group_count)\n\n        # Create artists if they do not exist\n        artist_uuid_sample = f\"{artist_uuid_prefix}_group_0\"\n        if artist_uuid_sample not in renderer._artists:\n            RendererPixels.create_artists(renderer, viewport, pixels, group_count)\n\n        # =============================================================================\n        # Update matplotlib for each group\n        # =============================================================================\n\n        changed_artists: list[matplotlib.artist.Artist] = []\n        for group_index in range(group_count):\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n\n            # =============================================================================\n            # Get existing artists\n            # =============================================================================\n\n            mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[group_uuid])\n            mpl_path_collection.set_visible(True)\n            changed_artists.append(mpl_path_collection)\n\n            # =============================================================================\n            # Update artists\n            # =============================================================================\n\n            mpl_path_collection.set_offsets(offsets=vertices_2d[indices_per_group[group_index]])\n            mpl_path_collection.set_facecolor(typing.cast(list, colors_numpy[group_index]))\n\n        # Return the list of artists created/updated\n        return changed_artists\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    @staticmethod\n    def create_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None:\n        \"\"\"Create the artists associated with the given visual and group count.\"\"\"\n\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        artist_uuid_prefix = f\"{viewport.get_uuid()}_{visual.get_uuid()}\"\n        # compute 1 pixel size in points squared for matplotlib sizing\n        assert axes.figure.get_dpi() is not None, \"Canvas DPI must be set for proper pixel sizing\"\n        size_pt = UnitUtils.pixel_to_point(1.0, axes.figure.get_dpi())\n        size_squared_pt = size_pt * size_pt\n\n        for group_index in range(group_count):\n            mpl_path_collection = axes.scatter([], [], s=size_squared_pt, marker=\"o\")\n            mpl_path_collection.set_antialiased(True)\n            mpl_path_collection.set_linewidth(0)\n            mpl_path_collection.set_visible(False)\n            # hide until properly positioned and sized\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n            renderer._artists[group_uuid] = mpl_path_collection\n            axes.add_artist(mpl_path_collection)\n\n    @staticmethod\n    def destroy_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None:\n        \"\"\"Destroy the artists associated with the given visual and group count.\n\n        Trigger a bug in matplotlib where artists are not properly removed from the axes.\n        \"\"\"\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        artist_uuid_prefix = f\"{viewport.get_uuid()}_{visual.get_uuid()}\"\n        for group_index in range(group_count):\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n            mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[group_uuid])\n            del renderer._artists[group_uuid]\n            mpl_path_collection.remove()\n\n            # axes.collections.remove(mpl_path_collection)\n            # axes.collections.remove(axes.collections.index(mpl_path_collection))\n\n            ax = axes\n            artist = mpl_path_collection\n\n            print(\"Artist:\", artist)\n            print(\"In ax.artists?\", artist in ax.artists)\n            print(\"In ax.patches?\", artist in ax.patches)\n            print(\"In ax.lines?\", artist in ax.lines)\n            print(\"In ax.collections?\", artist in ax.collections)\n            print(\"In ax.texts?\", artist in ax.texts)\n            print(\"Figure art?\", artist in getattr(ax.figure, \"artists\", []))\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels.RendererPixels.create_artists","title":"<code>create_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Create the artists associated with the given visual and group count.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_pixels.py</code> <pre><code>@staticmethod\ndef create_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None:\n    \"\"\"Create the artists associated with the given visual and group count.\"\"\"\n\n    axes = renderer.get_mpl_axes_for_viewport(viewport)\n    artist_uuid_prefix = f\"{viewport.get_uuid()}_{visual.get_uuid()}\"\n    # compute 1 pixel size in points squared for matplotlib sizing\n    assert axes.figure.get_dpi() is not None, \"Canvas DPI must be set for proper pixel sizing\"\n    size_pt = UnitUtils.pixel_to_point(1.0, axes.figure.get_dpi())\n    size_squared_pt = size_pt * size_pt\n\n    for group_index in range(group_count):\n        mpl_path_collection = axes.scatter([], [], s=size_squared_pt, marker=\"o\")\n        mpl_path_collection.set_antialiased(True)\n        mpl_path_collection.set_linewidth(0)\n        mpl_path_collection.set_visible(False)\n        # hide until properly positioned and sized\n        group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n        renderer._artists[group_uuid] = mpl_path_collection\n        axes.add_artist(mpl_path_collection)\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels.RendererPixels.destroy_artists","title":"<code>destroy_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Destroy the artists associated with the given visual and group count.</p> <p>Trigger a bug in matplotlib where artists are not properly removed from the axes.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_pixels.py</code> <pre><code>@staticmethod\ndef destroy_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None:\n    \"\"\"Destroy the artists associated with the given visual and group count.\n\n    Trigger a bug in matplotlib where artists are not properly removed from the axes.\n    \"\"\"\n    axes = renderer.get_mpl_axes_for_viewport(viewport)\n    artist_uuid_prefix = f\"{viewport.get_uuid()}_{visual.get_uuid()}\"\n    for group_index in range(group_count):\n        group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n        mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[group_uuid])\n        del renderer._artists[group_uuid]\n        mpl_path_collection.remove()\n\n        # axes.collections.remove(mpl_path_collection)\n        # axes.collections.remove(axes.collections.index(mpl_path_collection))\n\n        ax = axes\n        artist = mpl_path_collection\n\n        print(\"Artist:\", artist)\n        print(\"In ax.artists?\", artist in ax.artists)\n        print(\"In ax.patches?\", artist in ax.patches)\n        print(\"In ax.lines?\", artist in ax.lines)\n        print(\"In ax.collections?\", artist in ax.collections)\n        print(\"In ax.texts?\", artist in ax.texts)\n        print(\"Figure art?\", artist in getattr(ax.figure, \"artists\", []))\n</code></pre>"},{"location":"api/gsp_matplotlib/#points-renderer","title":"Points Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_points","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_points</code>","text":""},{"location":"api/gsp_matplotlib/#segments-renderer","title":"Segments Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_segments","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_segments</code>","text":""},{"location":"api/gsp_matplotlib/#texts-renderer","title":"Texts Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_texts","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_texts</code>","text":""},{"location":"api/gsp_matplotlib/#extra-module","title":"Extra Module","text":"<p>The extra module provides additional utilities and extensions for Matplotlib rendering.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra","title":"<code>gsp_matplotlib.extra</code>","text":""},{"location":"api/gsp_matplotlib/#bufferx","title":"Bufferx","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx","title":"<code>gsp_matplotlib.extra.bufferx</code>","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx.Bufferx","title":"<code>Bufferx</code>","text":"<p>Utility class for Buffer extended functionality using numpy.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>class Bufferx:\n    \"\"\"Utility class for Buffer extended functionality using numpy.\"\"\"\n\n    # =============================================================================\n    # Matrix functions\n    # =============================================================================\n\n    @staticmethod\n    def mat4_identity() -&gt; Buffer:\n        \"\"\"Create a Buffer containing a 4x4 identity matrix.\"\"\"\n        mat4_numpy = np.asarray([np.identity(4, dtype=np.float32)])\n        buffer = Bufferx.from_numpy(mat4_numpy, BufferType.mat4)\n        return buffer\n\n    # =============================================================================\n    # .to_numpy/.from_numpy\n    # =============================================================================\n    @staticmethod\n    def to_numpy(buffer: Buffer) -&gt; np.ndarray:\n        \"\"\"Convert a Buffer to a numpy array.\"\"\"\n        if buffer.get_type() == BufferType.float32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.int8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.int8).reshape((count, 1))\n        elif buffer.get_type() == BufferType.int32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.int32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.uint8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 1))\n        elif buffer.get_type() == BufferType.uint32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.vec2:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 2))\n        elif buffer.get_type() == BufferType.vec3:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 3))\n        elif buffer.get_type() == BufferType.vec4:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4))\n        elif buffer.get_type() == BufferType.mat4:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4, 4))\n        elif buffer.get_type() == BufferType.rgba8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 4))\n        else:\n            raise NotImplementedError(f\"unable to convert buffer {buffer} to numpy array\")\n\n    @staticmethod\n    def from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer:\n        \"\"\"Create a Buffer from a numpy array.\"\"\"\n        if bufferType == BufferType.float32:\n            # sanity check\n            assert array_numpy.dtype == np.float32, \"Numpy array must be of dtype float32\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.uint32:\n            # sanity check\n            assert array_numpy.dtype == np.uint32, \"Numpy array must be of dtype uint32\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.vec2:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 2, \"Numpy array must be of shape (2,)\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.vec3:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 3, \"Numpy array must be of shape (3,)\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.mat4:\n            # sanity check\n            assert array_numpy.shape.__len__() == 3 and array_numpy.shape[1] == 4 and array_numpy.shape[2] == 4, \"Numpy array must be of shape (4, 4)\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, 1)\n            return buffer\n        elif bufferType == BufferType.rgba8:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 4, \"Numpy array must be of shape (4,)\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.uint8).tobytes()), 0, count)\n            return buffer\n        else:\n            raise NotImplementedError(f\"unable to create a {bufferType} buffer from numpy array of shape {array_numpy.shape} and dtype {array_numpy.dtype}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx.Bufferx.from_numpy","title":"<code>from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Create a Buffer from a numpy array.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer:\n    \"\"\"Create a Buffer from a numpy array.\"\"\"\n    if bufferType == BufferType.float32:\n        # sanity check\n        assert array_numpy.dtype == np.float32, \"Numpy array must be of dtype float32\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.uint32:\n        # sanity check\n        assert array_numpy.dtype == np.uint32, \"Numpy array must be of dtype uint32\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.vec2:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 2, \"Numpy array must be of shape (2,)\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.vec3:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 3, \"Numpy array must be of shape (3,)\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.mat4:\n        # sanity check\n        assert array_numpy.shape.__len__() == 3 and array_numpy.shape[1] == 4 and array_numpy.shape[2] == 4, \"Numpy array must be of shape (4, 4)\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, 1)\n        return buffer\n    elif bufferType == BufferType.rgba8:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 4, \"Numpy array must be of shape (4,)\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.uint8).tobytes()), 0, count)\n        return buffer\n    else:\n        raise NotImplementedError(f\"unable to create a {bufferType} buffer from numpy array of shape {array_numpy.shape} and dtype {array_numpy.dtype}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx.Bufferx.mat4_identity","title":"<code>mat4_identity() -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Create a Buffer containing a 4x4 identity matrix.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef mat4_identity() -&gt; Buffer:\n    \"\"\"Create a Buffer containing a 4x4 identity matrix.\"\"\"\n    mat4_numpy = np.asarray([np.identity(4, dtype=np.float32)])\n    buffer = Bufferx.from_numpy(mat4_numpy, BufferType.mat4)\n    return buffer\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx.Bufferx.to_numpy","title":"<code>to_numpy(buffer: Buffer) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Convert a Buffer to a numpy array.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef to_numpy(buffer: Buffer) -&gt; np.ndarray:\n    \"\"\"Convert a Buffer to a numpy array.\"\"\"\n    if buffer.get_type() == BufferType.float32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.int8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.int8).reshape((count, 1))\n    elif buffer.get_type() == BufferType.int32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.int32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.uint8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 1))\n    elif buffer.get_type() == BufferType.uint32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.vec2:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 2))\n    elif buffer.get_type() == BufferType.vec3:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 3))\n    elif buffer.get_type() == BufferType.vec4:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4))\n    elif buffer.get_type() == BufferType.mat4:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4, 4))\n    elif buffer.get_type() == BufferType.rgba8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 4))\n    else:\n        raise NotImplementedError(f\"unable to convert buffer {buffer} to numpy array\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#utils-module","title":"Utils Module","text":"<p>The utils module provides converter utilities for the Matplotlib backend.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils","title":"<code>gsp_matplotlib.utils</code>","text":""},{"location":"api/gsp_matplotlib/#converter-utils","title":"Converter Utils","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils","title":"<code>gsp_matplotlib.utils.converter_utils</code>","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils.ConverterUtils","title":"<code>ConverterUtils</code>","text":"<p>Utility class for converting GSP types to Matplotlib types.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>class ConverterUtils:\n    \"\"\"Utility class for converting GSP types to Matplotlib types.\"\"\"\n\n    @staticmethod\n    def cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal[\"butt\", \"round\", \"projecting\"]:\n        \"\"\"Convert CapStyle enum to Matplotlib string.\"\"\"\n\n        if gsp_cap_style == CapStyle.BUTT:\n            return \"butt\"\n        elif gsp_cap_style == CapStyle.ROUND:\n            return \"round\"\n        elif gsp_cap_style == CapStyle.PROJECTING:\n            return \"projecting\"\n        else:\n            raise ValueError(f\"Unsupported CapStyle: {gsp_cap_style}\")\n\n    @staticmethod\n    def join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal[\"miter\", \"round\", \"bevel\"]:\n        \"\"\"Convert JoinStyle enum to Matplotlib string.\"\"\"\n        if gsp_join_style == JoinStyle.MITER:\n            return \"miter\"\n        elif gsp_join_style == JoinStyle.ROUND:\n            return \"round\"\n        elif gsp_join_style == JoinStyle.BEVEL:\n            return \"bevel\"\n        else:\n            raise ValueError(f\"Unsupported JoinStyle: {gsp_join_style}\")\n\n    @staticmethod\n    def marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str:\n        \"\"\"Convert GSP marker shape to Matplotlib marker shape.\"\"\"\n\n        if gsp_marker_shape == MarkerShape.disc:\n            mpl_marker_shape = \"o\"\n        elif gsp_marker_shape == MarkerShape.square:\n            mpl_marker_shape = \"s\"\n        elif gsp_marker_shape == MarkerShape.club:\n            mpl_marker_shape = r\"$\\clubsuit$\"\n        else:\n            raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n        return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils.ConverterUtils.cap_style_gsp_to_mpl","title":"<code>cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal['butt', 'round', 'projecting']</code>  <code>staticmethod</code>","text":"<p>Convert CapStyle enum to Matplotlib string.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal[\"butt\", \"round\", \"projecting\"]:\n    \"\"\"Convert CapStyle enum to Matplotlib string.\"\"\"\n\n    if gsp_cap_style == CapStyle.BUTT:\n        return \"butt\"\n    elif gsp_cap_style == CapStyle.ROUND:\n        return \"round\"\n    elif gsp_cap_style == CapStyle.PROJECTING:\n        return \"projecting\"\n    else:\n        raise ValueError(f\"Unsupported CapStyle: {gsp_cap_style}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils.ConverterUtils.join_style_gsp_to_mpl","title":"<code>join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal['miter', 'round', 'bevel']</code>  <code>staticmethod</code>","text":"<p>Convert JoinStyle enum to Matplotlib string.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal[\"miter\", \"round\", \"bevel\"]:\n    \"\"\"Convert JoinStyle enum to Matplotlib string.\"\"\"\n    if gsp_join_style == JoinStyle.MITER:\n        return \"miter\"\n    elif gsp_join_style == JoinStyle.ROUND:\n        return \"round\"\n    elif gsp_join_style == JoinStyle.BEVEL:\n        return \"bevel\"\n    else:\n        raise ValueError(f\"Unsupported JoinStyle: {gsp_join_style}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils.ConverterUtils.marker_shape_gsp_to_mpl","title":"<code>marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert GSP marker shape to Matplotlib marker shape.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str:\n    \"\"\"Convert GSP marker shape to Matplotlib marker shape.\"\"\"\n\n    if gsp_marker_shape == MarkerShape.disc:\n        mpl_marker_shape = \"o\"\n    elif gsp_marker_shape == MarkerShape.square:\n        mpl_marker_shape = \"s\"\n    elif gsp_marker_shape == MarkerShape.club:\n        mpl_marker_shape = r\"$\\clubsuit$\"\n    else:\n        raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n    return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_network/","title":"GSP Network API Reference","text":"<p>The GSP Network module provides network-based rendering capabilities, enabling remote visualization and client-server architectures.</p>"},{"location":"api/gsp_network/#overview","title":"Overview","text":""},{"location":"api/gsp_network/#gsp_network","title":"<code>gsp_network</code>","text":"<p>gsp_network provides functionality for rendering graphics over a network using different remote renderers.</p>"},{"location":"api/gsp_network/#renderer-module","title":"Renderer Module","text":"<p>The renderer module contains the network renderer implementation for remote rendering.</p>"},{"location":"api/gsp_network/#gsp_network.renderer","title":"<code>gsp_network.renderer</code>","text":""},{"location":"api/gsp_network/#network-renderer","title":"Network Renderer","text":""},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer","title":"<code>gsp_network.renderer.network_renderer</code>","text":""},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer","title":"<code>NetworkRenderer</code>","text":"<p>               Bases: <code>gsp.types.renderer_base.RendererBase</code></p> <p>Note: this requires a running gsp_network server. See the README for instructions.</p> <p>IMPORTANT: it DOES NOT depend on GSP matplotlib renderer, it only uses pip matplotlib to display the remotely rendered images.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>class NetworkRenderer(RendererBase):\n    \"\"\"\n    **Note**: this requires a running gsp_network server. See the README for instructions.\n\n    **IMPORTANT**: it DOES NOT depend on GSP matplotlib renderer, it only uses pip matplotlib to display the remotely rendered images.\n    \"\"\"\n\n    def __init__(self, canvas: Canvas, server_base_url: str, remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = \"matplotlib\") -&gt; None:\n        \"\"\"Initialize the NetworkRenderer.\n\n        Args:\n            canvas (Canvas): _description_\n            server_base_url (str): _description_\n            remote_renderer_name (Literal[\"matplotlib\", \"datoviz\"], optional): _description_. Defaults to \"matplotlib\".\n        \"\"\"\n        self._canvas = canvas\n        self._server_base_url = server_base_url\n        self._remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = remote_renderer_name\n\n        # Create a figure\n        figure_width = self._canvas.get_width() / self._canvas.get_dpi()\n        figure_height = self._canvas.get_height() / self._canvas.get_dpi()\n        self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=self._canvas.get_dpi())\n        assert self._figure.canvas.manager is not None, f\"matplotlib figure canvas manager is None\"\n        self._figure.canvas.manager.set_window_title(f\"Network ({self._remote_renderer_name})\")\n\n        # get the only axes in the figure\n        self._mpl_axes = self._figure.add_axes((0, 0, 1, 1))\n        # hide the borders\n        self._mpl_axes.axis(\"off\")\n\n        # create an np.array to hold the image\n        image_data_np = np.zeros((self._canvas.get_height(), self._canvas.get_width(), 3), dtype=np.uint8)\n        self._axes_image = self._mpl_axes.imshow(image_data_np, aspect=\"auto\")\n\n    def get_canvas(self) -&gt; Canvas:\n        \"\"\"Get the canvas associated with the network renderer.\n\n        Returns:\n            Canvas: The canvas associated with the network renderer.\n        \"\"\"\n        return self._canvas\n\n    def close(self) -&gt; None:\n        \"\"\"Close the network renderer and release resources.\"\"\"\n        # stop the event loop if any - thus .show(block=True) will return\n        self._figure.canvas.stop_event_loop()\n        # close the figure\n        matplotlib.pyplot.close(self._figure)\n        self._figure = None  # type: ignore\n\n    def get_remote_renderer_name(self) -&gt; Literal[\"matplotlib\", \"datoviz\"]:\n        \"\"\"Get the name of the remote renderer being used.\n\n        Returns:\n            Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.\n        \"\"\"\n        return self._remote_renderer_name\n\n    def render(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n    ) -&gt; bytes:\n        \"\"\"Render the scene remotely and update the matplotlib figure with the rendered image.\n\n        Args:\n            viewports (Sequence[Viewport]): The viewports to render.\n            visuals (Sequence[VisualBase]): The visuals to render.\n            model_matrices (Sequence[TransBuf]): The model matrices for the visuals.\n            cameras (Sequence[Camera]): The cameras to use for rendering.\n\n        Returns:\n            bytes: The rendered image data in PNG format.\n\n        Raises:\n            Exception: If the network request fails.\n        \"\"\"\n\n        # =============================================================================\n        # Serialize the scene and create the payload\n        # =============================================================================\n        pydanticSerializer = PydanticSerializer(self._canvas)\n        pydantic_scene_dict = pydanticSerializer.serialize(\n            viewports=viewports,\n            visuals=visuals,\n            model_matrices=model_matrices,\n            cameras=cameras,\n        )\n\n        payload: NetworkPayload = {\n            \"renderer_name\": self._remote_renderer_name,\n            \"data\": pydantic_scene_dict,\n        }\n\n        # =============================================================================\n        # do network request to send the payload and get the rendered image\n        # =============================================================================\n        # Send the POST request with JSON data\n        call_url = f\"{self._server_base_url}/render\"\n        headers = {\"Content-Type\": \"application/json\"}\n        response = requests.post(call_url, data=json.dumps(payload), headers=headers)\n\n        # Check the response status\n        if response.status_code != HttpStatus.OK:\n            raise Exception(f\"Request failed with status code {response.status_code}\")\n        image_png_data = response.content\n\n        # =============================================================================\n        # Render the image in the matplotlib figure\n        # =============================================================================\n        assert self._axes_image is not None, f\"PANIC self._axes_image is None\"\n        # update the image data\n        image_data_io = io.BytesIO(image_png_data)\n        image_data_np = matplotlib.image.imread(image_data_io, format=\"png\")\n        self._axes_image.set_data(image_data_np)\n\n        # return png data as bytes\n        return image_png_data\n\n    def show(self) -&gt; None:\n        # handle non-interactive mode for tests\n        in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n        if in_test:\n            return\n\n        matplotlib.pyplot.show()\n\n    def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n        return self._figure\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.__init__","title":"<code>__init__(canvas: Canvas, server_base_url: str, remote_renderer_name: Literal['matplotlib', 'datoviz'] = 'matplotlib') -&gt; None</code>","text":"<p>Initialize the NetworkRenderer.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>gsp.core.canvas.Canvas</code> <p>description</p> required <code>server_base_url</code> <code>str</code> <p>description</p> required <code>remote_renderer_name</code> <code>typing.Literal['matplotlib', 'datoviz']</code> <p>description. Defaults to \"matplotlib\".</p> <code>'matplotlib'</code> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def __init__(self, canvas: Canvas, server_base_url: str, remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = \"matplotlib\") -&gt; None:\n    \"\"\"Initialize the NetworkRenderer.\n\n    Args:\n        canvas (Canvas): _description_\n        server_base_url (str): _description_\n        remote_renderer_name (Literal[\"matplotlib\", \"datoviz\"], optional): _description_. Defaults to \"matplotlib\".\n    \"\"\"\n    self._canvas = canvas\n    self._server_base_url = server_base_url\n    self._remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = remote_renderer_name\n\n    # Create a figure\n    figure_width = self._canvas.get_width() / self._canvas.get_dpi()\n    figure_height = self._canvas.get_height() / self._canvas.get_dpi()\n    self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=self._canvas.get_dpi())\n    assert self._figure.canvas.manager is not None, f\"matplotlib figure canvas manager is None\"\n    self._figure.canvas.manager.set_window_title(f\"Network ({self._remote_renderer_name})\")\n\n    # get the only axes in the figure\n    self._mpl_axes = self._figure.add_axes((0, 0, 1, 1))\n    # hide the borders\n    self._mpl_axes.axis(\"off\")\n\n    # create an np.array to hold the image\n    image_data_np = np.zeros((self._canvas.get_height(), self._canvas.get_width(), 3), dtype=np.uint8)\n    self._axes_image = self._mpl_axes.imshow(image_data_np, aspect=\"auto\")\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the network renderer and release resources.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the network renderer and release resources.\"\"\"\n    # stop the event loop if any - thus .show(block=True) will return\n    self._figure.canvas.stop_event_loop()\n    # close the figure\n    matplotlib.pyplot.close(self._figure)\n    self._figure = None  # type: ignore\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.get_canvas","title":"<code>get_canvas() -&gt; Canvas</code>","text":"<p>Get the canvas associated with the network renderer.</p> <p>Returns:</p> Name Type Description <code>Canvas</code> <code>gsp.core.canvas.Canvas</code> <p>The canvas associated with the network renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_canvas(self) -&gt; Canvas:\n    \"\"\"Get the canvas associated with the network renderer.\n\n    Returns:\n        Canvas: The canvas associated with the network renderer.\n    \"\"\"\n    return self._canvas\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.get_remote_renderer_name","title":"<code>get_remote_renderer_name() -&gt; Literal['matplotlib', 'datoviz']</code>","text":"<p>Get the name of the remote renderer being used.</p> <p>Returns:</p> Type Description <code>typing.Literal['matplotlib', 'datoviz']</code> <p>Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_remote_renderer_name(self) -&gt; Literal[\"matplotlib\", \"datoviz\"]:\n    \"\"\"Get the name of the remote renderer being used.\n\n    Returns:\n        Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.\n    \"\"\"\n    return self._remote_renderer_name\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.render","title":"<code>render(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; bytes</code>","text":"<p>Render the scene remotely and update the matplotlib figure with the rendered image.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>The viewports to render.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>The visuals to render.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>The model matrices for the visuals.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>The cameras to use for rendering.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The rendered image data in PNG format.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the network request fails.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def render(\n    self,\n    viewports: Sequence[Viewport],\n    visuals: Sequence[VisualBase],\n    model_matrices: Sequence[TransBuf],\n    cameras: Sequence[Camera],\n) -&gt; bytes:\n    \"\"\"Render the scene remotely and update the matplotlib figure with the rendered image.\n\n    Args:\n        viewports (Sequence[Viewport]): The viewports to render.\n        visuals (Sequence[VisualBase]): The visuals to render.\n        model_matrices (Sequence[TransBuf]): The model matrices for the visuals.\n        cameras (Sequence[Camera]): The cameras to use for rendering.\n\n    Returns:\n        bytes: The rendered image data in PNG format.\n\n    Raises:\n        Exception: If the network request fails.\n    \"\"\"\n\n    # =============================================================================\n    # Serialize the scene and create the payload\n    # =============================================================================\n    pydanticSerializer = PydanticSerializer(self._canvas)\n    pydantic_scene_dict = pydanticSerializer.serialize(\n        viewports=viewports,\n        visuals=visuals,\n        model_matrices=model_matrices,\n        cameras=cameras,\n    )\n\n    payload: NetworkPayload = {\n        \"renderer_name\": self._remote_renderer_name,\n        \"data\": pydantic_scene_dict,\n    }\n\n    # =============================================================================\n    # do network request to send the payload and get the rendered image\n    # =============================================================================\n    # Send the POST request with JSON data\n    call_url = f\"{self._server_base_url}/render\"\n    headers = {\"Content-Type\": \"application/json\"}\n    response = requests.post(call_url, data=json.dumps(payload), headers=headers)\n\n    # Check the response status\n    if response.status_code != HttpStatus.OK:\n        raise Exception(f\"Request failed with status code {response.status_code}\")\n    image_png_data = response.content\n\n    # =============================================================================\n    # Render the image in the matplotlib figure\n    # =============================================================================\n    assert self._axes_image is not None, f\"PANIC self._axes_image is None\"\n    # update the image data\n    image_data_io = io.BytesIO(image_png_data)\n    image_data_np = matplotlib.image.imread(image_data_io, format=\"png\")\n    self._axes_image.set_data(image_data_np)\n\n    # return png data as bytes\n    return image_png_data\n</code></pre>"},{"location":"api/gsp_network/#tools-module","title":"Tools Module","text":"<p>The tools module provides server utilities for network-based rendering.</p>"},{"location":"api/gsp_network/#gsp_network.tools","title":"<code>gsp_network.tools</code>","text":""},{"location":"api/gsp_network/#network-server","title":"Network Server","text":""},{"location":"api/gsp_network/#gsp_network.tools.network_server","title":"<code>gsp_network.tools.network_server</code>","text":"<p>Server example using Flask to render a scene from JSON input.</p> <ul> <li>use Flask to create a simple web server</li> <li>render with matplotlib or datoviz based on environment variable</li> </ul>"},{"location":"api/gsp_network/#gsp_network.tools.network_server.ServerSample","title":"<code>ServerSample</code>","text":"<p>Sample class to demonstrate server functionality.</p> Source code in <code>src/gsp_network/tools/network_server.py</code> <pre><code>class ServerSample:\n    \"\"\"\n    Sample class to demonstrate server functionality.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def run(self):\n        flask_app.run(threaded=False, debug=False)  # Enable debug mode if desired\n</code></pre>"},{"location":"api/gsp_network/#network-server-kill","title":"Network Server Kill","text":""},{"location":"api/gsp_network/#gsp_network.tools.network_server_kill","title":"<code>gsp_network.tools.network_server_kill</code>","text":"<p>Kill any process using port 5000 (commonly used for flask server)</p> <p>in shell: <code>lsof -ti tcp:5000 | xargs kill</code></p>"},{"location":"api/gsp_pydantic/","title":"GSP Pydantic API Reference","text":"<p>The GSP Pydantic module provides serialization and deserialization capabilities using Pydantic models, enabling data validation and JSON schema generation for GSP objects.</p>"},{"location":"api/gsp_pydantic/#overview","title":"Overview","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic","title":"<code>gsp_pydantic</code>","text":""},{"location":"api/gsp_pydantic/#serializer-module","title":"Serializer Module","text":"<p>The serializer module contains the serialization and parsing utilities for converting GSP objects to and from Pydantic models.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer","title":"<code>gsp_pydantic.serializer</code>","text":""},{"location":"api/gsp_pydantic/#pydantic-serializer","title":"Pydantic Serializer","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_serializer","title":"<code>gsp_pydantic.serializer.pydantic_serializer</code>","text":""},{"location":"api/gsp_pydantic/#pydantic-parser","title":"Pydantic Parser","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_parser","title":"<code>gsp_pydantic.serializer.pydantic_parser</code>","text":""},{"location":"api/gsp_pydantic/#types-module","title":"Types Module","text":"<p>The types module defines Pydantic models for GSP data structures, providing validation and schema generation.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types","title":"<code>gsp_pydantic.types</code>","text":""},{"location":"api/gsp_pydantic/#pydantic-dict","title":"Pydantic Dict","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_dict","title":"<code>gsp_pydantic.types.pydantic_dict</code>","text":""},{"location":"api/gsp_pydantic/#pydantic-types","title":"Pydantic Types","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types","title":"<code>gsp_pydantic.types.pydantic_types</code>","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticBuffer","title":"<code>PydanticBuffer</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticBuffer(BaseModel):\n    count: int\n    \"\"\"number of elements in the buffer\"\"\"\n    buffer_type: str\n    \"\"\"type of the buffer elements, corresponds to BufferType enum value\"\"\"\n    data_base64: str\n    \"\"\"data encoded in base64 format\"\"\"\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticBuffer.buffer_type","title":"<code>buffer_type: str</code>  <code>instance-attribute</code>","text":"<p>type of the buffer elements, corresponds to BufferType enum value</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticBuffer.count","title":"<code>count: int</code>  <code>instance-attribute</code>","text":"<p>number of elements in the buffer</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticBuffer.data_base64","title":"<code>data_base64: str</code>  <code>instance-attribute</code>","text":"<p>data encoded in base64 format</p>"}]}
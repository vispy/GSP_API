{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"GSP Documentation","text":"<p>This is your documentation homepage.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#overview","title":"Overview","text":"<p>This page provides information about the project.</p>"},{"location":"about/#description","title":"Description","text":"<p>Add your description here.</p>"},{"location":"about/#contact","title":"Contact","text":"<p>For questions or support, please contact us.</p>"},{"location":"api/gsp/","title":"GSP API Reference","text":"<p>The Graphic Server Protocol (GSP) API provides a unified interface for creating and rendering graphics across different backends.</p>"},{"location":"api/gsp/#core-module","title":"Core Module","text":""},{"location":"api/gsp/#gsp.core.canvas","title":"<code>gsp.core.canvas</code>","text":"<p>Canvas module for the GSP library.</p>"},{"location":"api/gsp/#gsp.core.canvas.Canvas","title":"<code>Canvas</code>","text":"<p>Canvas class representing a drawing surface with specific dimensions and DPI.</p> Source code in <code>src/gsp/core/canvas.py</code> <pre><code>class Canvas:\n    \"\"\"Canvas class representing a drawing surface with specific dimensions and DPI.\"\"\"\n\n    __slots__ = [\"_uuid\", \"_width\", \"_height\", \"_dpi\", \"userData\"]\n\n    def __init__(self, width: int, height: int, dpi: float):\n        \"\"\"Create a new Canvas object with the given width, height, and dpi.\n\n        Args:\n            width (int): Width of the canvas in pixels.\n            height (int): Height of the canvas in pixels.\n            dpi (float): Dots per inch (DPI) of the canvas. If set to the screen PPI, the 'inch' unit in will correspond to one physical inch on the screen.\n        \"\"\"\n        self._uuid: str = UuidUtils.generate_uuid()\n        self._width: int = width\n        self._height: int = height\n        self._dpi: float = dpi\n        self.userData: dict[str, Any] = {}\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return string representation of the Canvas instance.\"\"\"\n        return f\"Canvas(width={self._width}, height={self._height}, dpi={self._dpi})\"\n\n    def get_uuid(self) -&gt; str:\n        \"\"\"Get the UUID of the Canvas instance.\n\n        Returns:\n            str: The UUID of the Canvas.\n        \"\"\"\n        return self._uuid\n\n    def get_width(self) -&gt; int:\n        \"\"\"Get the width of the canvas in pixels.\"\"\"\n        return self._width\n\n    def set_width(self, width: int) -&gt; None:\n        \"\"\"Set the width of the canvas in pixels.\n\n        Args:\n            width (int): The new width in pixels.\n        \"\"\"\n        self._width = width\n\n    def get_height(self) -&gt; int:\n        \"\"\"Get the height of the canvas in pixels.\"\"\"\n        return self._height\n\n    def set_height(self, height: int) -&gt; None:\n        \"\"\"Set the height of the canvas in pixels.\n\n        Args:\n            height (int): The new height in pixels.\n        \"\"\"\n        self._height = height\n\n    def get_dpi(self) -&gt; float:\n        \"\"\"Get the DPI of the canvas.\"\"\"\n        return self._dpi\n\n    def set_dpi(self, dpi: float) -&gt; None:\n        \"\"\"Set the DPI of the canvas.\n\n        Args:\n            dpi (float): The new DPI value.\n        \"\"\"\n        self._dpi = dpi\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.__init__","title":"<code>__init__(width: int, height: int, dpi: float)</code>","text":"<p>Create a new Canvas object with the given width, height, and dpi.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the canvas in pixels.</p> required <code>height</code> <code>int</code> <p>Height of the canvas in pixels.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch (DPI) of the canvas. If set to the screen PPI, the 'inch' unit in will correspond to one physical inch on the screen.</p> required Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def __init__(self, width: int, height: int, dpi: float):\n    \"\"\"Create a new Canvas object with the given width, height, and dpi.\n\n    Args:\n        width (int): Width of the canvas in pixels.\n        height (int): Height of the canvas in pixels.\n        dpi (float): Dots per inch (DPI) of the canvas. If set to the screen PPI, the 'inch' unit in will correspond to one physical inch on the screen.\n    \"\"\"\n    self._uuid: str = UuidUtils.generate_uuid()\n    self._width: int = width\n    self._height: int = height\n    self._dpi: float = dpi\n    self.userData: dict[str, Any] = {}\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return string representation of the Canvas instance.</p> Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return string representation of the Canvas instance.\"\"\"\n    return f\"Canvas(width={self._width}, height={self._height}, dpi={self._dpi})\"\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.get_dpi","title":"<code>get_dpi() -&gt; float</code>","text":"<p>Get the DPI of the canvas.</p> Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def get_dpi(self) -&gt; float:\n    \"\"\"Get the DPI of the canvas.\"\"\"\n    return self._dpi\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.get_height","title":"<code>get_height() -&gt; int</code>","text":"<p>Get the height of the canvas in pixels.</p> Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def get_height(self) -&gt; int:\n    \"\"\"Get the height of the canvas in pixels.\"\"\"\n    return self._height\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.get_uuid","title":"<code>get_uuid() -&gt; str</code>","text":"<p>Get the UUID of the Canvas instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The UUID of the Canvas.</p> Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def get_uuid(self) -&gt; str:\n    \"\"\"Get the UUID of the Canvas instance.\n\n    Returns:\n        str: The UUID of the Canvas.\n    \"\"\"\n    return self._uuid\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.get_width","title":"<code>get_width() -&gt; int</code>","text":"<p>Get the width of the canvas in pixels.</p> Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def get_width(self) -&gt; int:\n    \"\"\"Get the width of the canvas in pixels.\"\"\"\n    return self._width\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.set_dpi","title":"<code>set_dpi(dpi: float) -&gt; None</code>","text":"<p>Set the DPI of the canvas.</p> <p>Parameters:</p> Name Type Description Default <code>dpi</code> <code>float</code> <p>The new DPI value.</p> required Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def set_dpi(self, dpi: float) -&gt; None:\n    \"\"\"Set the DPI of the canvas.\n\n    Args:\n        dpi (float): The new DPI value.\n    \"\"\"\n    self._dpi = dpi\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.set_height","title":"<code>set_height(height: int) -&gt; None</code>","text":"<p>Set the height of the canvas in pixels.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>The new height in pixels.</p> required Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def set_height(self, height: int) -&gt; None:\n    \"\"\"Set the height of the canvas in pixels.\n\n    Args:\n        height (int): The new height in pixels.\n    \"\"\"\n    self._height = height\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.set_width","title":"<code>set_width(width: int) -&gt; None</code>","text":"<p>Set the width of the canvas in pixels.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The new width in pixels.</p> required Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def set_width(self, width: int) -&gt; None:\n    \"\"\"Set the width of the canvas in pixels.\n\n    Args:\n        width (int): The new width in pixels.\n    \"\"\"\n    self._width = width\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport","title":"<code>gsp.core.viewport</code>","text":"<p>Viewport class representing a rectangular area on the canvas.</p>"},{"location":"api/gsp/#gsp.core.viewport.Viewport","title":"<code>Viewport</code>","text":"<p>Viewport class representing a rectangular area on the canvas.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>class Viewport:\n    \"\"\"Viewport class representing a rectangular area on the canvas.\"\"\"\n\n    __slots__ = [\"_uuid\", \"_x\", \"_y\", \"_width\", \"_height\", \"userData\"]\n\n    def __init__(self, x: int, y: int, width: int, height: int):\n        \"\"\"Create a viewport.\n\n        Args:\n            x (int): The x offset (in pixels from left) of the viewport.\n            y (int): The y offset (in pixels from bottom) of the viewport.\n            width (int): The width (in pixels) of the viewport.\n            height (int): The height (in pixels) of the viewport.\n        \"\"\"\n        self._uuid: str = UuidUtils.generate_uuid()\n        self._x: int = x\n        self._y: int = y\n        self._width: int = width\n        self._height: int = height\n        self.userData: dict[str, Any] = {}\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return string representation of the Viewport instance.\"\"\"\n        return f\"Viewport(x={self._x}, y={self._y}, width={self._width}, height={self._height})\"\n\n    def get_uuid(self) -&gt; str:\n        \"\"\"Get the unique identifier of the viewport.\n\n        Returns:\n            str: The unique identifier.\n        \"\"\"\n        return self._uuid\n\n    def get_x(self) -&gt; int:\n        \"\"\"Get the x offset (in pixels from left) of the viewport.\n\n        Returns:\n            int: The x offset.\n        \"\"\"\n        return self._x\n\n    def set_x(self, x: int) -&gt; None:\n        \"\"\"Set the x offset (in pixels from left) of the viewport.\n\n        Args:\n            x (int): The new x offset.\n        \"\"\"\n        self._x = x\n\n    def get_y(self) -&gt; int:\n        \"\"\"Get the y offset (in pixels from bottom) of the viewport.\n\n        Returns:\n            int: The y offset.\n        \"\"\"\n        return self._y\n\n    def set_y(self, y: int) -&gt; None:\n        \"\"\"Set the y offset (in pixels from bottom) of the viewport.\n\n        Args:\n            y (int): The new y offset.\n        \"\"\"\n        self._y = y\n\n    def get_width(self) -&gt; int:\n        \"\"\"Get the width (in pixels) of the viewport.\n\n        Returns:\n            int: The width.\n        \"\"\"\n        return self._width\n\n    def set_width(self, width: int) -&gt; None:\n        \"\"\"Set the width (in pixels) of the viewport.\n\n        Args:\n            width (int): The new width.\n        \"\"\"\n        self._width = width\n\n    def get_height(self) -&gt; int:\n        \"\"\"Get the height (in pixels) of the viewport.\n\n        Returns:\n            int: The height.\n        \"\"\"\n        return self._height\n\n    def set_height(self, height: int) -&gt; None:\n        \"\"\"Set the height (in pixels) of the viewport.\n\n        Args:\n            height (int): The new height.\n        \"\"\"\n        self._height = height\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.__init__","title":"<code>__init__(x: int, y: int, width: int, height: int)</code>","text":"<p>Create a viewport.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The x offset (in pixels from left) of the viewport.</p> required <code>y</code> <code>int</code> <p>The y offset (in pixels from bottom) of the viewport.</p> required <code>width</code> <code>int</code> <p>The width (in pixels) of the viewport.</p> required <code>height</code> <code>int</code> <p>The height (in pixels) of the viewport.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def __init__(self, x: int, y: int, width: int, height: int):\n    \"\"\"Create a viewport.\n\n    Args:\n        x (int): The x offset (in pixels from left) of the viewport.\n        y (int): The y offset (in pixels from bottom) of the viewport.\n        width (int): The width (in pixels) of the viewport.\n        height (int): The height (in pixels) of the viewport.\n    \"\"\"\n    self._uuid: str = UuidUtils.generate_uuid()\n    self._x: int = x\n    self._y: int = y\n    self._width: int = width\n    self._height: int = height\n    self.userData: dict[str, Any] = {}\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return string representation of the Viewport instance.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return string representation of the Viewport instance.\"\"\"\n    return f\"Viewport(x={self._x}, y={self._y}, width={self._width}, height={self._height})\"\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_height","title":"<code>get_height() -&gt; int</code>","text":"<p>Get the height (in pixels) of the viewport.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The height.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_height(self) -&gt; int:\n    \"\"\"Get the height (in pixels) of the viewport.\n\n    Returns:\n        int: The height.\n    \"\"\"\n    return self._height\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_uuid","title":"<code>get_uuid() -&gt; str</code>","text":"<p>Get the unique identifier of the viewport.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_uuid(self) -&gt; str:\n    \"\"\"Get the unique identifier of the viewport.\n\n    Returns:\n        str: The unique identifier.\n    \"\"\"\n    return self._uuid\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_width","title":"<code>get_width() -&gt; int</code>","text":"<p>Get the width (in pixels) of the viewport.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The width.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_width(self) -&gt; int:\n    \"\"\"Get the width (in pixels) of the viewport.\n\n    Returns:\n        int: The width.\n    \"\"\"\n    return self._width\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_x","title":"<code>get_x() -&gt; int</code>","text":"<p>Get the x offset (in pixels from left) of the viewport.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The x offset.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_x(self) -&gt; int:\n    \"\"\"Get the x offset (in pixels from left) of the viewport.\n\n    Returns:\n        int: The x offset.\n    \"\"\"\n    return self._x\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_y","title":"<code>get_y() -&gt; int</code>","text":"<p>Get the y offset (in pixels from bottom) of the viewport.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The y offset.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_y(self) -&gt; int:\n    \"\"\"Get the y offset (in pixels from bottom) of the viewport.\n\n    Returns:\n        int: The y offset.\n    \"\"\"\n    return self._y\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.set_height","title":"<code>set_height(height: int) -&gt; None</code>","text":"<p>Set the height (in pixels) of the viewport.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>The new height.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def set_height(self, height: int) -&gt; None:\n    \"\"\"Set the height (in pixels) of the viewport.\n\n    Args:\n        height (int): The new height.\n    \"\"\"\n    self._height = height\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.set_width","title":"<code>set_width(width: int) -&gt; None</code>","text":"<p>Set the width (in pixels) of the viewport.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The new width.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def set_width(self, width: int) -&gt; None:\n    \"\"\"Set the width (in pixels) of the viewport.\n\n    Args:\n        width (int): The new width.\n    \"\"\"\n    self._width = width\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.set_x","title":"<code>set_x(x: int) -&gt; None</code>","text":"<p>Set the x offset (in pixels from left) of the viewport.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The new x offset.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def set_x(self, x: int) -&gt; None:\n    \"\"\"Set the x offset (in pixels from left) of the viewport.\n\n    Args:\n        x (int): The new x offset.\n    \"\"\"\n    self._x = x\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.set_y","title":"<code>set_y(y: int) -&gt; None</code>","text":"<p>Set the y offset (in pixels from bottom) of the viewport.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>int</code> <p>The new y offset.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def set_y(self, y: int) -&gt; None:\n    \"\"\"Set the y offset (in pixels from bottom) of the viewport.\n\n    Args:\n        y (int): The new y offset.\n    \"\"\"\n    self._y = y\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera","title":"<code>gsp.core.camera</code>","text":"<p>Camera module for the GSP library.</p>"},{"location":"api/gsp/#gsp.core.camera.Camera","title":"<code>Camera</code>","text":"<p>Camera class representing a view and projection matrix for 3D rendering.</p> Source code in <code>src/gsp/core/camera.py</code> <pre><code>class Camera:\n    \"\"\"Camera class representing a view and projection matrix for 3D rendering.\"\"\"\n    __slots__ = [\"_uuid\", \"_view_matrix\", \"_projection_matrix\", \"userData\"]\n\n    def __init__(self, view_matrix: TransBuf, projection_matrix: TransBuf):\n        \"\"\"Initialize a Camera instance. Just a container for view and projection matrices.\n\n        Args:\n            view_matrix (TransBuf): View matrix - [view-matrix](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-view-matrix)\n            projection_matrix (TransBuf): Projection matrix - [projection-matrix](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-projection-matrix)\n        \"\"\"\n        self._uuid: str = UuidUtils.generate_uuid()\n        self._view_matrix: TransBuf = view_matrix\n        self._projection_matrix: TransBuf = projection_matrix\n        self.userData: dict[str, Any] = {}\n        \"\"\"A dictionary for storing custom user data associated with the Camera instance.\"\"\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return string representation of the Camera instance.\"\"\"\n        return f\"Camera(uuid={self._uuid})\"\n\n    def get_uuid(self) -&gt; str:\n        \"\"\"Get the UUID of the Camera instance.\n\n        Returns:\n            str: The UUID of the Camera.\n        \"\"\"\n        return self._uuid\n\n    def set_view_matrix(self, view_matrix: TransBuf):\n        \"\"\"Set the view matrix of the Camera.\n\n        Args:\n            view_matrix (TransBuf): The new view matrix.\n        \"\"\"\n        self._view_matrix = view_matrix\n\n    def get_view_matrix(self) -&gt; TransBuf:\n        \"\"\"Get the view matrix of the Camera.\n\n        Returns:\n            TransBuf: The view matrix.\n        \"\"\"\n        return self._view_matrix\n\n    def set_projection_matrix(self, projection_matrix: TransBuf):\n        \"\"\"Set the projection matrix of the Camera.\n\n        Args:\n            projection_matrix (TransBuf): The new projection matrix.\n        \"\"\"\n        self._projection_matrix = projection_matrix\n\n    def get_projection_matrix(self) -&gt; TransBuf:\n        \"\"\"Get the projection matrix of the Camera.\n\n        Returns:\n            TransBuf: The projection matrix.\n        \"\"\"\n        return self._projection_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.userData","title":"<code>userData: dict[str, Any] = {}</code>  <code>instance-attribute</code>","text":"<p>A dictionary for storing custom user data associated with the Camera instance.</p>"},{"location":"api/gsp/#gsp.core.camera.Camera.__init__","title":"<code>__init__(view_matrix: TransBuf, projection_matrix: TransBuf)</code>","text":"<p>Initialize a Camera instance. Just a container for view and projection matrices.</p> <p>Parameters:</p> Name Type Description Default <code>view_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>View matrix - view-matrix</p> required <code>projection_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>Projection matrix - projection-matrix</p> required Source code in <code>src/gsp/core/camera.py</code> <pre><code>def __init__(self, view_matrix: TransBuf, projection_matrix: TransBuf):\n    \"\"\"Initialize a Camera instance. Just a container for view and projection matrices.\n\n    Args:\n        view_matrix (TransBuf): View matrix - [view-matrix](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-view-matrix)\n        projection_matrix (TransBuf): Projection matrix - [projection-matrix](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-projection-matrix)\n    \"\"\"\n    self._uuid: str = UuidUtils.generate_uuid()\n    self._view_matrix: TransBuf = view_matrix\n    self._projection_matrix: TransBuf = projection_matrix\n    self.userData: dict[str, Any] = {}\n    \"\"\"A dictionary for storing custom user data associated with the Camera instance.\"\"\"\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return string representation of the Camera instance.</p> Source code in <code>src/gsp/core/camera.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return string representation of the Camera instance.\"\"\"\n    return f\"Camera(uuid={self._uuid})\"\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.get_projection_matrix","title":"<code>get_projection_matrix() -&gt; TransBuf</code>","text":"<p>Get the projection matrix of the Camera.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The projection matrix.</p> Source code in <code>src/gsp/core/camera.py</code> <pre><code>def get_projection_matrix(self) -&gt; TransBuf:\n    \"\"\"Get the projection matrix of the Camera.\n\n    Returns:\n        TransBuf: The projection matrix.\n    \"\"\"\n    return self._projection_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.get_uuid","title":"<code>get_uuid() -&gt; str</code>","text":"<p>Get the UUID of the Camera instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The UUID of the Camera.</p> Source code in <code>src/gsp/core/camera.py</code> <pre><code>def get_uuid(self) -&gt; str:\n    \"\"\"Get the UUID of the Camera instance.\n\n    Returns:\n        str: The UUID of the Camera.\n    \"\"\"\n    return self._uuid\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.get_view_matrix","title":"<code>get_view_matrix() -&gt; TransBuf</code>","text":"<p>Get the view matrix of the Camera.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The view matrix.</p> Source code in <code>src/gsp/core/camera.py</code> <pre><code>def get_view_matrix(self) -&gt; TransBuf:\n    \"\"\"Get the view matrix of the Camera.\n\n    Returns:\n        TransBuf: The view matrix.\n    \"\"\"\n    return self._view_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.set_projection_matrix","title":"<code>set_projection_matrix(projection_matrix: TransBuf)</code>","text":"<p>Set the projection matrix of the Camera.</p> <p>Parameters:</p> Name Type Description Default <code>projection_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new projection matrix.</p> required Source code in <code>src/gsp/core/camera.py</code> <pre><code>def set_projection_matrix(self, projection_matrix: TransBuf):\n    \"\"\"Set the projection matrix of the Camera.\n\n    Args:\n        projection_matrix (TransBuf): The new projection matrix.\n    \"\"\"\n    self._projection_matrix = projection_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.set_view_matrix","title":"<code>set_view_matrix(view_matrix: TransBuf)</code>","text":"<p>Set the view matrix of the Camera.</p> <p>Parameters:</p> Name Type Description Default <code>view_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new view matrix.</p> required Source code in <code>src/gsp/core/camera.py</code> <pre><code>def set_view_matrix(self, view_matrix: TransBuf):\n    \"\"\"Set the view matrix of the Camera.\n\n    Args:\n        view_matrix (TransBuf): The new view matrix.\n    \"\"\"\n    self._view_matrix = view_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.event","title":"<code>gsp.core.event</code>","text":"<p>A simple, standalone event implementation with subscribe and dispatch methods.</p>"},{"location":"api/gsp/#gsp.core.event.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>typing.Generic[gsp.core.event.Callback]</code></p> <p>A simple, standalone event implementation with subscribe and dispatch methods.</p> <p>This class allows for a \"one-to-many\" communication pattern where a single event can notify multiple listeners (subscribers) that an action has occurred.</p> <p>The generic type <code>Callback</code> allows the event to be type-hinted with the specific signature of the functions it will dispatch to, ensuring type safety.</p> Source code in <code>src/gsp/core/event.py</code> <pre><code>class Event(Generic[Callback]):\n    \"\"\"A simple, standalone event implementation with subscribe and dispatch methods.\n\n    This class allows for a \"one-to-many\" communication pattern where a single event\n    can notify multiple listeners (subscribers) that an action has occurred.\n\n    The generic type `Callback` allows the event to be type-hinted with the\n    specific signature of the functions it will dispatch to, ensuring type safety.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initialize the Event with an empty list of callbacks.\"\"\"\n        # A list to store the subscribed callback functions.\n        self._callbacks: list[Callback] = []\n\n    def subscribe(self, callback: Callback) -&gt; None:\n        \"\"\"Subscribes a callback to the event.\n\n        Args:\n            callback (Callback): The function to be called when the event is dispatched.\n                      Its signature should match the event's generic type.\n        \"\"\"\n        self._callbacks.append(callback)\n\n    def unsubscribe(self, callback: Callback) -&gt; None:\n        \"\"\"Unsubscribes a previously subscribed callback from the event.\n\n        Args:\n            callback (Callback): The function to be removed from the event's subscribers.\n        \"\"\"\n        self._callbacks.remove(callback)\n\n    def dispatch(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Dispatches the event, calling all subscribed callbacks with the given arguments.\n\n        Args:\n            *args (Any): Positional arguments to pass to the callbacks.\n            **kwargs (Any): Keyword arguments to pass to the callbacks.\n        \"\"\"\n        for callback in self._callbacks:\n            callback(*args, **kwargs)\n\n    def event_listener(self, callback: Callback) -&gt; Callback:\n        \"\"\"Decorator to subscribe a function to the event. This is a convenience method.\n\n        It still ensure static type checking on the decorated function.\n        **NOTE**: it is possible to unsubscribe the function later using `event.unsubscribe(handler)`.\n\n        Usage:\n            @event.subscriber\n            def handler(...): ...\n\n        Args:\n            callback (Callback): The function to be subscribed.\n\n        Returns:\n            Callback: The same function that was passed in.\n        \"\"\"\n        self.subscribe(callback)\n        return callback\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the Event with an empty list of callbacks.</p> Source code in <code>src/gsp/core/event.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the Event with an empty list of callbacks.\"\"\"\n    # A list to store the subscribed callback functions.\n    self._callbacks: list[Callback] = []\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.dispatch","title":"<code>dispatch(*args: Any, **kwargs: Any) -&gt; None</code>","text":"<p>Dispatches the event, calling all subscribed callbacks with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>typing.Any</code> <p>Positional arguments to pass to the callbacks.</p> <code>()</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments to pass to the callbacks.</p> <code>{}</code> Source code in <code>src/gsp/core/event.py</code> <pre><code>def dispatch(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Dispatches the event, calling all subscribed callbacks with the given arguments.\n\n    Args:\n        *args (Any): Positional arguments to pass to the callbacks.\n        **kwargs (Any): Keyword arguments to pass to the callbacks.\n    \"\"\"\n    for callback in self._callbacks:\n        callback(*args, **kwargs)\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.event_listener","title":"<code>event_listener(callback: Callback) -&gt; Callback</code>","text":"<p>Decorator to subscribe a function to the event. This is a convenience method.</p> <p>It still ensure static type checking on the decorated function. NOTE: it is possible to unsubscribe the function later using <code>event.unsubscribe(handler)</code>.</p> Usage <p>@event.subscriber def handler(...): ...</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>gsp.core.event.Callback</code> <p>The function to be subscribed.</p> required <p>Returns:</p> Name Type Description <code>Callback</code> <code>gsp.core.event.Callback</code> <p>The same function that was passed in.</p> Source code in <code>src/gsp/core/event.py</code> <pre><code>def event_listener(self, callback: Callback) -&gt; Callback:\n    \"\"\"Decorator to subscribe a function to the event. This is a convenience method.\n\n    It still ensure static type checking on the decorated function.\n    **NOTE**: it is possible to unsubscribe the function later using `event.unsubscribe(handler)`.\n\n    Usage:\n        @event.subscriber\n        def handler(...): ...\n\n    Args:\n        callback (Callback): The function to be subscribed.\n\n    Returns:\n        Callback: The same function that was passed in.\n    \"\"\"\n    self.subscribe(callback)\n    return callback\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.subscribe","title":"<code>subscribe(callback: Callback) -&gt; None</code>","text":"<p>Subscribes a callback to the event.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>gsp.core.event.Callback</code> <p>The function to be called when the event is dispatched.       Its signature should match the event's generic type.</p> required Source code in <code>src/gsp/core/event.py</code> <pre><code>def subscribe(self, callback: Callback) -&gt; None:\n    \"\"\"Subscribes a callback to the event.\n\n    Args:\n        callback (Callback): The function to be called when the event is dispatched.\n                  Its signature should match the event's generic type.\n    \"\"\"\n    self._callbacks.append(callback)\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.unsubscribe","title":"<code>unsubscribe(callback: Callback) -&gt; None</code>","text":"<p>Unsubscribes a previously subscribed callback from the event.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>gsp.core.event.Callback</code> <p>The function to be removed from the event's subscribers.</p> required Source code in <code>src/gsp/core/event.py</code> <pre><code>def unsubscribe(self, callback: Callback) -&gt; None:\n    \"\"\"Unsubscribes a previously subscribed callback from the event.\n\n    Args:\n        callback (Callback): The function to be removed from the event's subscribers.\n    \"\"\"\n    self._callbacks.remove(callback)\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.main","title":"<code>main() -&gt; None</code>","text":"<p>Example usage of the Event class.</p> Source code in <code>src/gsp/core/event.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Example usage of the Event class.\"\"\"\n    from typing import Protocol\n\n    # We can define the expected function signature using a Protocol for clarity.\n    class UserLoginCallback(Protocol):\n        def __call__(self, username: str, user_id: int) -&gt; None: ...\n\n    # Create an instance of our Event, typed with the protocol.\n    on_user_login = Event[UserLoginCallback]()\n\n    def welcome_user(username: str, user_id: int) -&gt; None:\n        print(f\"Welcome, {username}! Your user ID is {user_id}.\")\n\n    def log_login_event(username: str, user_id: float) -&gt; None:\n        print(f\"[{username}] logged in with ID [{user_id}] at the database level.\")\n\n    # Subscribe the functions\n    on_user_login.subscribe(welcome_user)\n    on_user_login.subscribe(log_login_event)\n\n    # Dispatch the event\n    print(\"Dispatching event for user 'Alice'...\")\n    on_user_login.dispatch(\"Alice\", \"ddd\")\n</code></pre>"},{"location":"api/gsp/#types-module","title":"Types Module","text":""},{"location":"api/gsp/#gsp.types.buffer","title":"<code>gsp.types.buffer</code>","text":"<p>Buffer module for typed array with single dimension.</p>"},{"location":"api/gsp/#gsp.types.buffer.Buffer","title":"<code>Buffer</code>","text":"<p>Typed array with single dimension.</p> <p>It is immutable in count and type, but mutable in content.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>class Buffer:\n    \"\"\"Typed array with single dimension.\n\n    It is immutable in count and type, but mutable in content.\n    \"\"\"\n\n    def __init__(self, count: int, buffer_type: BufferType) -&gt; None:\n        \"\"\"Initialize a Buffer instance.\n\n        Args:\n            count (int): The number of elements in the buffer.\n            buffer_type (BufferType): The type of elements in the buffer.\n        \"\"\"\n        item_size = BufferType.get_item_size(buffer_type)\n        self._count: int = count\n        self._type: BufferType = buffer_type\n        self._bytearray: bytearray = bytearray(count * item_size)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the Buffer.\n\n        Returns:\n            str: A string representation showing count and type.\n        \"\"\"\n        return f\"Buffer(count={self._count}, type={self._type})\"\n\n    def get_count(self) -&gt; int:\n        \"\"\"Return the number of elements in the buffer.\n\n        Returns:\n            int: The number of elements.\n        \"\"\"\n        return self._count\n\n    def get_type(self) -&gt; BufferType:\n        \"\"\"Return the type of each element in the buffer.\n\n        Returns:\n            BufferType: The buffer type.\n        \"\"\"\n        return self._type\n\n    # =============================================================================\n    # .get_data/.set_data\n    # =============================================================================\n\n    def get_data(self, offset: int, count: int) -&gt; \"Buffer\":\n        \"\"\"Return a buffer of count elements starting from offset.\n\n        Args:\n            offset (int): The starting index.\n            count (int): The number of elements to retrieve.\n\n        Returns:\n            Buffer: A new Buffer containing the requested data.\n        \"\"\"\n        item_size = BufferType.get_item_size(self._type)\n        start = offset * item_size\n        end = start + count * item_size\n\n        new_buffer = Buffer(count, self._type)\n        new_buffer.set_data(self._bytearray[start:end], 0, count)\n        return new_buffer\n\n    def set_data(self, _bytearray: bytearray, offset: int, count: int) -&gt; None:\n        \"\"\"Copy count elements starting from offset in the source bytearray.\n\n        Args:\n            _bytearray (bytearray): The source bytearray containing data to copy.\n            offset (int): The starting index in the buffer where data will be copied.\n            count (int): The number of elements to copy.\n        \"\"\"\n        item_size = BufferType.get_item_size(self._type)\n\n        # sanity check\n        assert offset + count &lt;= self._count, f\"Invalid offset {offset} and count {count} for buffer of size {self._count}\"\n\n        start = offset * item_size\n        end = start + count * item_size\n        self._bytearray = self._bytearray[:start] + _bytearray[0 : count * item_size] + self._bytearray[end:]\n\n    # =============================================================================\n    # .to_bytearray/from_bytearray\n    # =============================================================================\n\n    def to_bytearray(self) -&gt; bytearray:\n        \"\"\"Return the content of the Buffer as a bytearray.\n\n        Returns:\n            bytearray: The bytearray representation of the Buffer.\n        \"\"\"\n        return bytearray(self._bytearray)\n\n    @staticmethod\n    def from_bytearray(_bytearray: bytearray, buffer_type: BufferType) -&gt; \"Buffer\":\n        \"\"\"Create a Buffer from a bytearray and a specified BufferType.\n\n        Args:\n            _bytearray (bytearray): The source bytearray.\n            buffer_type (BufferType): The type of elements in the buffer.\n\n        Returns:\n            Buffer: The created Buffer instance.\n        \"\"\"\n        item_size = BufferType.get_item_size(buffer_type)\n        # sanity check\n        assert len(_bytearray) % item_size == 0, f\"data size {len(_bytearray)} is not aligned with buffer type item size {item_size}\"\n\n        # create buffer\n        buffer = Buffer(len(_bytearray) // item_size, buffer_type)\n        buffer.set_data(_bytearray, 0, buffer.get_count())\n        return buffer\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.__init__","title":"<code>__init__(count: int, buffer_type: BufferType) -&gt; None</code>","text":"<p>Initialize a Buffer instance.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements in the buffer.</p> required <code>buffer_type</code> <code>gsp.types.buffer_type.BufferType</code> <p>The type of elements in the buffer.</p> required Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def __init__(self, count: int, buffer_type: BufferType) -&gt; None:\n    \"\"\"Initialize a Buffer instance.\n\n    Args:\n        count (int): The number of elements in the buffer.\n        buffer_type (BufferType): The type of elements in the buffer.\n    \"\"\"\n    item_size = BufferType.get_item_size(buffer_type)\n    self._count: int = count\n    self._type: BufferType = buffer_type\n    self._bytearray: bytearray = bytearray(count * item_size)\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return a string representation of the Buffer.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation showing count and type.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the Buffer.\n\n    Returns:\n        str: A string representation showing count and type.\n    \"\"\"\n    return f\"Buffer(count={self._count}, type={self._type})\"\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.from_bytearray","title":"<code>from_bytearray(_bytearray: bytearray, buffer_type: BufferType) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Create a Buffer from a bytearray and a specified BufferType.</p> <p>Parameters:</p> Name Type Description Default <code>_bytearray</code> <code>bytearray</code> <p>The source bytearray.</p> required <code>buffer_type</code> <code>gsp.types.buffer_type.BufferType</code> <p>The type of elements in the buffer.</p> required <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.buffer.Buffer</code> <p>The created Buffer instance.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>@staticmethod\ndef from_bytearray(_bytearray: bytearray, buffer_type: BufferType) -&gt; \"Buffer\":\n    \"\"\"Create a Buffer from a bytearray and a specified BufferType.\n\n    Args:\n        _bytearray (bytearray): The source bytearray.\n        buffer_type (BufferType): The type of elements in the buffer.\n\n    Returns:\n        Buffer: The created Buffer instance.\n    \"\"\"\n    item_size = BufferType.get_item_size(buffer_type)\n    # sanity check\n    assert len(_bytearray) % item_size == 0, f\"data size {len(_bytearray)} is not aligned with buffer type item size {item_size}\"\n\n    # create buffer\n    buffer = Buffer(len(_bytearray) // item_size, buffer_type)\n    buffer.set_data(_bytearray, 0, buffer.get_count())\n    return buffer\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.get_count","title":"<code>get_count() -&gt; int</code>","text":"<p>Return the number of elements in the buffer.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def get_count(self) -&gt; int:\n    \"\"\"Return the number of elements in the buffer.\n\n    Returns:\n        int: The number of elements.\n    \"\"\"\n    return self._count\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.get_data","title":"<code>get_data(offset: int, count: int) -&gt; Buffer</code>","text":"<p>Return a buffer of count elements starting from offset.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The starting index.</p> required <code>count</code> <code>int</code> <p>The number of elements to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.buffer.Buffer</code> <p>A new Buffer containing the requested data.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def get_data(self, offset: int, count: int) -&gt; \"Buffer\":\n    \"\"\"Return a buffer of count elements starting from offset.\n\n    Args:\n        offset (int): The starting index.\n        count (int): The number of elements to retrieve.\n\n    Returns:\n        Buffer: A new Buffer containing the requested data.\n    \"\"\"\n    item_size = BufferType.get_item_size(self._type)\n    start = offset * item_size\n    end = start + count * item_size\n\n    new_buffer = Buffer(count, self._type)\n    new_buffer.set_data(self._bytearray[start:end], 0, count)\n    return new_buffer\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.get_type","title":"<code>get_type() -&gt; BufferType</code>","text":"<p>Return the type of each element in the buffer.</p> <p>Returns:</p> Name Type Description <code>BufferType</code> <code>gsp.types.buffer_type.BufferType</code> <p>The buffer type.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def get_type(self) -&gt; BufferType:\n    \"\"\"Return the type of each element in the buffer.\n\n    Returns:\n        BufferType: The buffer type.\n    \"\"\"\n    return self._type\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.set_data","title":"<code>set_data(_bytearray: bytearray, offset: int, count: int) -&gt; None</code>","text":"<p>Copy count elements starting from offset in the source bytearray.</p> <p>Parameters:</p> Name Type Description Default <code>_bytearray</code> <code>bytearray</code> <p>The source bytearray containing data to copy.</p> required <code>offset</code> <code>int</code> <p>The starting index in the buffer where data will be copied.</p> required <code>count</code> <code>int</code> <p>The number of elements to copy.</p> required Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def set_data(self, _bytearray: bytearray, offset: int, count: int) -&gt; None:\n    \"\"\"Copy count elements starting from offset in the source bytearray.\n\n    Args:\n        _bytearray (bytearray): The source bytearray containing data to copy.\n        offset (int): The starting index in the buffer where data will be copied.\n        count (int): The number of elements to copy.\n    \"\"\"\n    item_size = BufferType.get_item_size(self._type)\n\n    # sanity check\n    assert offset + count &lt;= self._count, f\"Invalid offset {offset} and count {count} for buffer of size {self._count}\"\n\n    start = offset * item_size\n    end = start + count * item_size\n    self._bytearray = self._bytearray[:start] + _bytearray[0 : count * item_size] + self._bytearray[end:]\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.to_bytearray","title":"<code>to_bytearray() -&gt; bytearray</code>","text":"<p>Return the content of the Buffer as a bytearray.</p> <p>Returns:</p> Name Type Description <code>bytearray</code> <code>bytearray</code> <p>The bytearray representation of the Buffer.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def to_bytearray(self) -&gt; bytearray:\n    \"\"\"Return the content of the Buffer as a bytearray.\n\n    Returns:\n        bytearray: The bytearray representation of the Buffer.\n    \"\"\"\n    return bytearray(self._bytearray)\n</code></pre>"},{"location":"api/gsp/#gsp.types.group","title":"<code>gsp.types.group</code>","text":"<p>Group type definitions for GSP.</p> <p>This module defines types used to represent groups of elements in various forms.</p>"},{"location":"api/gsp/#gsp.types.group.Groups","title":"<code>Groups = Union[int, list[int], list[list[int]]]</code>  <code>module-attribute</code>","text":"<p>A type that can represent group IDs in various forms.</p> The Groups type supports three different formats <ul> <li>int: Represents the size of a single group.</li> <li>list[int]: Each int represents the size of each subgroup.</li> <li>list[list[int]]: Each sublist represents element indices in a group.<ul> <li>len(groups) represents the number of groups.</li> <li>groups[0] contains element indices of the first group.</li> <li>groups[1] contains element indices of the second group.</li> </ul> </li> </ul>"},{"location":"api/gsp/#gsp.types.visual_base","title":"<code>gsp.types.visual_base</code>","text":"<p>Base class for visual objects in GSP.</p> <p>This module provides the foundational VisualBase class that all visual objects inherit from, providing common functionality like UUID generation and user data storage.</p>"},{"location":"api/gsp/#gsp.types.visual_base.VisualBase","title":"<code>VisualBase</code>","text":"<p>Base class for all visual objects in the GSP library.</p> <p>This class provides fundamental functionality for visual objects including automatic UUID generation and a userData dictionary for storing custom metadata.</p> Source code in <code>src/gsp/types/visual_base.py</code> <pre><code>class VisualBase:\n    \"\"\"Base class for all visual objects in the GSP library.\n\n    This class provides fundamental functionality for visual objects including\n    automatic UUID generation and a userData dictionary for storing custom\n    metadata.\n    \"\"\"\n\n    __slots__ = [\"_uuid\", \"userData\"]\n\n    def __init__(self):\n        \"\"\"Initialize a new VisualBase instance.\n\n        Creates a new visual object with a unique identifier and an empty\n        userData dictionary.\n        \"\"\"\n        self._uuid: str = UuidUtils.generate_uuid()\n        self.userData: dict[str, Any] = {}\n\n    def get_uuid(self) -&gt; str:\n        \"\"\"Get the unique identifier of the visual object.\n\n        Returns:\n            str: The unique identifier.\n        \"\"\"\n        return self._uuid\n\n    def set_uuid(self, uuid: str) -&gt; None:\n        \"\"\"Set the unique identifier of the visual object.\n\n        Args:\n            uuid: The new unique identifier.\n        \"\"\"\n        self._uuid = uuid\n</code></pre>"},{"location":"api/gsp/#gsp.types.visual_base.VisualBase.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a new VisualBase instance.</p> <p>Creates a new visual object with a unique identifier and an empty userData dictionary.</p> Source code in <code>src/gsp/types/visual_base.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a new VisualBase instance.\n\n    Creates a new visual object with a unique identifier and an empty\n    userData dictionary.\n    \"\"\"\n    self._uuid: str = UuidUtils.generate_uuid()\n    self.userData: dict[str, Any] = {}\n</code></pre>"},{"location":"api/gsp/#gsp.types.visual_base.VisualBase.get_uuid","title":"<code>get_uuid() -&gt; str</code>","text":"<p>Get the unique identifier of the visual object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier.</p> Source code in <code>src/gsp/types/visual_base.py</code> <pre><code>def get_uuid(self) -&gt; str:\n    \"\"\"Get the unique identifier of the visual object.\n\n    Returns:\n        str: The unique identifier.\n    \"\"\"\n    return self._uuid\n</code></pre>"},{"location":"api/gsp/#gsp.types.visual_base.VisualBase.set_uuid","title":"<code>set_uuid(uuid: str) -&gt; None</code>","text":"<p>Set the unique identifier of the visual object.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>The new unique identifier.</p> required Source code in <code>src/gsp/types/visual_base.py</code> <pre><code>def set_uuid(self, uuid: str) -&gt; None:\n    \"\"\"Set the unique identifier of the visual object.\n\n    Args:\n        uuid: The new unique identifier.\n    \"\"\"\n    self._uuid = uuid\n</code></pre>"},{"location":"api/gsp/#gsp.types.animator_base","title":"<code>gsp.types.animator_base</code>","text":"<p>Abstract base class for GSP scene animators.</p>"},{"location":"api/gsp/#gsp.types.animator_base.AnimatorBase","title":"<code>AnimatorBase</code>","text":"<p>               Bases: <code>abc.ABC</code></p> <p>Abstract base class for GSP scene animators.</p> <p>Defines the interface for animator implementations that handle frame-by-frame updates of GSP visualizations. Concrete implementations should provide renderer-specific animation loop mechanisms.</p> Source code in <code>src/gsp/types/animator_base.py</code> <pre><code>class AnimatorBase(ABC):\n    \"\"\"Abstract base class for GSP scene animators.\n\n    Defines the interface for animator implementations that handle frame-by-frame\n    updates of GSP visualizations. Concrete implementations should provide\n    renderer-specific animation loop mechanisms.\n    \"\"\"\n\n    __slots__ = ()\n\n    on_video_saved: Event[VideoSavedCalledback]\n    \"\"\"Event triggered when the video is saved.\"\"\"\n\n    @abstractmethod\n    def add_callback(self, func: AnimatorFunc) -&gt; None:\n        \"\"\"Add a callback to the animation loop.\n\n        Args:\n            func: The callback function to add. It should accept a delta_time float\n                  and return a sequence of VisualBase objects that were modified.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def remove_callback(self, func: AnimatorFunc) -&gt; None:\n        \"\"\"Remove a callback from the animation loop.\n\n        Args:\n            func: The callback function to remove. Must be the same function\n                  object that was previously added.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def event_listener(self, func: AnimatorFunc) -&gt; AnimatorFunc:\n        \"\"\"Decorator to register a callback function to the animation loop.\n\n        This method should be implemented to allow decorator-style registration\n        of animation callbacks.\n\n        Args:\n            func: The callback function to decorate and add to the animation loop.\n                  Should accept delta_time (float) and return a sequence of modified VisualBase objects.\n\n        Returns:\n            The wrapper function that will be called on each animation frame.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def start(self, viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; None:\n        \"\"\"Start the animation loop.\n\n        Begins animating the scene using the provided viewports, visuals, model matrices,\n        and cameras. The registered callbacks will be invoked on each frame to update\n        the scene.\n\n        Args:\n            viewports: Sequence of viewports to render.\n            visuals: Sequence of visual objects to animate.\n            model_matrices: Sequence of transformation buffers for the visuals.\n            cameras: Sequence of cameras for each viewport.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def stop(self) -&gt; None:\n        \"\"\"Stop the animation loop.\n\n        Cleans up animation state and stops any ongoing animation.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.types.animator_base.AnimatorBase.on_video_saved","title":"<code>on_video_saved: Event[VideoSavedCalledback]</code>  <code>instance-attribute</code>","text":"<p>Event triggered when the video is saved.</p>"},{"location":"api/gsp/#gsp.types.animator_base.AnimatorBase.add_callback","title":"<code>add_callback(func: AnimatorFunc) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Add a callback to the animation loop.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>gsp.types.animator_types.AnimatorFunc</code> <p>The callback function to add. It should accept a delta_time float   and return a sequence of VisualBase objects that were modified.</p> required Source code in <code>src/gsp/types/animator_base.py</code> <pre><code>@abstractmethod\ndef add_callback(self, func: AnimatorFunc) -&gt; None:\n    \"\"\"Add a callback to the animation loop.\n\n    Args:\n        func: The callback function to add. It should accept a delta_time float\n              and return a sequence of VisualBase objects that were modified.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.types.animator_base.AnimatorBase.event_listener","title":"<code>event_listener(func: AnimatorFunc) -&gt; AnimatorFunc</code>  <code>abstractmethod</code>","text":"<p>Decorator to register a callback function to the animation loop.</p> <p>This method should be implemented to allow decorator-style registration of animation callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>gsp.types.animator_types.AnimatorFunc</code> <p>The callback function to decorate and add to the animation loop.   Should accept delta_time (float) and return a sequence of modified VisualBase objects.</p> required <p>Returns:</p> Type Description <code>gsp.types.animator_types.AnimatorFunc</code> <p>The wrapper function that will be called on each animation frame.</p> Source code in <code>src/gsp/types/animator_base.py</code> <pre><code>@abstractmethod\ndef event_listener(self, func: AnimatorFunc) -&gt; AnimatorFunc:\n    \"\"\"Decorator to register a callback function to the animation loop.\n\n    This method should be implemented to allow decorator-style registration\n    of animation callbacks.\n\n    Args:\n        func: The callback function to decorate and add to the animation loop.\n              Should accept delta_time (float) and return a sequence of modified VisualBase objects.\n\n    Returns:\n        The wrapper function that will be called on each animation frame.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.types.animator_base.AnimatorBase.remove_callback","title":"<code>remove_callback(func: AnimatorFunc) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Remove a callback from the animation loop.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>gsp.types.animator_types.AnimatorFunc</code> <p>The callback function to remove. Must be the same function   object that was previously added.</p> required Source code in <code>src/gsp/types/animator_base.py</code> <pre><code>@abstractmethod\ndef remove_callback(self, func: AnimatorFunc) -&gt; None:\n    \"\"\"Remove a callback from the animation loop.\n\n    Args:\n        func: The callback function to remove. Must be the same function\n              object that was previously added.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.types.animator_base.AnimatorBase.start","title":"<code>start(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Start the animation loop.</p> <p>Begins animating the scene using the provided viewports, visuals, model matrices, and cameras. The registered callbacks will be invoked on each frame to update the scene.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>Sequence of viewports to render.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>Sequence of visual objects to animate.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>Sequence of transformation buffers for the visuals.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>Sequence of cameras for each viewport.</p> required Source code in <code>src/gsp/types/animator_base.py</code> <pre><code>@abstractmethod\ndef start(self, viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; None:\n    \"\"\"Start the animation loop.\n\n    Begins animating the scene using the provided viewports, visuals, model matrices,\n    and cameras. The registered callbacks will be invoked on each frame to update\n    the scene.\n\n    Args:\n        viewports: Sequence of viewports to render.\n        visuals: Sequence of visual objects to animate.\n        model_matrices: Sequence of transformation buffers for the visuals.\n        cameras: Sequence of cameras for each viewport.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.types.animator_base.AnimatorBase.stop","title":"<code>stop() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Stop the animation loop.</p> <p>Cleans up animation state and stops any ongoing animation.</p> Source code in <code>src/gsp/types/animator_base.py</code> <pre><code>@abstractmethod\ndef stop(self) -&gt; None:\n    \"\"\"Stop the animation loop.\n\n    Cleans up animation state and stops any ongoing animation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.types.animator_types","title":"<code>gsp.types.animator_types</code>","text":"<p>Type definitions for the animator module.</p> <p>This module defines callback protocols and type aliases used by the animator for managing animation loops and video saving operations.</p>"},{"location":"api/gsp/#gsp.types.animator_types.AnimatorFunc","title":"<code>AnimatorFunc = Callable[[float], Sequence[VisualBase]]</code>  <code>module-attribute</code>","text":"<p>Type alias for animation callback functions.</p> <p>An animator function is called on each frame of the animation with the elapsed time since the last frame in milliseconds, and returns a sequence of VisualBase objects to render in the current frame.</p>"},{"location":"api/gsp/#gsp.types.animator_types.VideoSavedCalledback","title":"<code>VideoSavedCalledback</code>","text":"<p>               Bases: <code>typing.Protocol</code></p> <p>Callback protocol for video saved event.</p> Source code in <code>src/gsp/types/animator_types.py</code> <pre><code>class VideoSavedCalledback(Protocol):\n    \"\"\"Callback protocol for video saved event.\"\"\"\n\n    def __call__(self) -&gt; None:\n        \"\"\"Called when the video has been successfully saved.\"\"\"\n        ...\n</code></pre>"},{"location":"api/gsp/#gsp.types.animator_types.VideoSavedCalledback.__call__","title":"<code>__call__() -&gt; None</code>","text":"<p>Called when the video has been successfully saved.</p> Source code in <code>src/gsp/types/animator_types.py</code> <pre><code>def __call__(self) -&gt; None:\n    \"\"\"Called when the video has been successfully saved.\"\"\"\n    ...\n</code></pre>"},{"location":"api/gsp/#gsp.types.viewport_events_base","title":"<code>gsp.types.viewport_events_base</code>","text":"<p>Base class for viewport event handlers.</p>"},{"location":"api/gsp/#gsp.types.viewport_events_base.ViewportEventsBase","title":"<code>ViewportEventsBase</code>","text":"<p>               Bases: <code>abc.ABC</code></p> <p>Base class for window event handlers for camera controls.</p> Source code in <code>src/gsp/types/viewport_events_base.py</code> <pre><code>class ViewportEventsBase(ABC):\n    \"\"\"Base class for window event handlers for camera controls.\"\"\"\n\n    __slots__ = [\n        \"key_press_event\",\n        \"key_release_event\",\n        \"button_press_event\",\n        \"button_release_event\",\n        \"mouse_move_event\",\n        \"mouse_scroll_event\",\n        \"canvas_resize_event\",\n    ]\n\n    key_press_event: Event[KeyboardEventCallback]\n    \"\"\"Event triggered on key press\"\"\"\n    key_release_event: Event[KeyboardEventCallback]\n    \"\"\"Event triggered on key release\"\"\"\n    button_press_event: Event[MouseEventCallback]\n    \"\"\"Event triggered on mouse button press\"\"\"\n    button_release_event: Event[MouseEventCallback]\n    \"\"\"Event triggered on mouse button release\"\"\"\n    mouse_move_event: Event[MouseEventCallback]\n    \"\"\"Event triggered on mouse move\"\"\"\n    mouse_scroll_event: Event[MouseEventCallback]\n    \"\"\"Event triggered on mouse scroll\"\"\"\n    mouse_scroll_event: Event[MouseEventCallback]\n    \"\"\"Event triggered on mouse scroll\"\"\"\n    canvas_resize_event: Event[CanvasResizeEventCallback]\n    \"\"\"Event triggered on canvas resize\"\"\"\n</code></pre>"},{"location":"api/gsp/#gsp.types.viewport_events_base.ViewportEventsBase.button_press_event","title":"<code>button_press_event: Event[MouseEventCallback]</code>  <code>instance-attribute</code>","text":"<p>Event triggered on mouse button press</p>"},{"location":"api/gsp/#gsp.types.viewport_events_base.ViewportEventsBase.button_release_event","title":"<code>button_release_event: Event[MouseEventCallback]</code>  <code>instance-attribute</code>","text":"<p>Event triggered on mouse button release</p>"},{"location":"api/gsp/#gsp.types.viewport_events_base.ViewportEventsBase.canvas_resize_event","title":"<code>canvas_resize_event: Event[CanvasResizeEventCallback]</code>  <code>instance-attribute</code>","text":"<p>Event triggered on canvas resize</p>"},{"location":"api/gsp/#gsp.types.viewport_events_base.ViewportEventsBase.key_press_event","title":"<code>key_press_event: Event[KeyboardEventCallback]</code>  <code>instance-attribute</code>","text":"<p>Event triggered on key press</p>"},{"location":"api/gsp/#gsp.types.viewport_events_base.ViewportEventsBase.key_release_event","title":"<code>key_release_event: Event[KeyboardEventCallback]</code>  <code>instance-attribute</code>","text":"<p>Event triggered on key release</p>"},{"location":"api/gsp/#gsp.types.viewport_events_base.ViewportEventsBase.mouse_move_event","title":"<code>mouse_move_event: Event[MouseEventCallback]</code>  <code>instance-attribute</code>","text":"<p>Event triggered on mouse move</p>"},{"location":"api/gsp/#gsp.types.viewport_events_base.ViewportEventsBase.mouse_scroll_event","title":"<code>mouse_scroll_event: Event[MouseEventCallback]</code>  <code>instance-attribute</code>","text":"<p>Event triggered on mouse scroll</p>"},{"location":"api/gsp/#gsp.types.viewport_events_types","title":"<code>gsp.types.viewport_events_types</code>","text":"<p>Viewport Event Types and Callback Protocols.</p>"},{"location":"api/gsp/#gsp.types.viewport_events_types.CanvasResizeEvent","title":"<code>CanvasResizeEvent</code>  <code>dataclass</code>","text":"<p>Represents a canvas resize event.</p> <p>Attributes:</p> Name Type Description <code>viewport_uuid</code> <code>str</code> <p>The unique identifier of the viewport affected by the resize.</p> <code>event_type</code> <code>gsp.types.viewport_events_types.EventType</code> <p>The type of event (CANVAS_RESIZE).</p> <code>canvas_width_px</code> <code>int</code> <p>The new width of the canvas in pixels.</p> <code>canvas_height_px</code> <code>int</code> <p>The new height of the canvas in pixels.</p> Source code in <code>src/gsp/types/viewport_events_types.py</code> <pre><code>@dataclass\nclass CanvasResizeEvent:\n    \"\"\"Represents a canvas resize event.\n\n    Attributes:\n        viewport_uuid: The unique identifier of the viewport affected by the resize.\n        event_type: The type of event (CANVAS_RESIZE).\n        canvas_width_px: The new width of the canvas in pixels.\n        canvas_height_px: The new height of the canvas in pixels.\n    \"\"\"\n\n    viewport_uuid: str\n    event_type: EventType\n    canvas_width_px: int\n    canvas_height_px: int\n</code></pre>"},{"location":"api/gsp/#gsp.types.viewport_events_types.CanvasResizeEventCallback","title":"<code>CanvasResizeEventCallback</code>","text":"<p>               Bases: <code>typing.Protocol</code></p> <p>Protocol for canvas resize event callback functions.</p> <p>Defines the signature for functions that handle canvas resize events.</p> Source code in <code>src/gsp/types/viewport_events_types.py</code> <pre><code>class CanvasResizeEventCallback(Protocol):\n    \"\"\"Protocol for canvas resize event callback functions.\n\n    Defines the signature for functions that handle canvas resize events.\n    \"\"\"\n\n    def __call__(self, canvas_resize_event: CanvasResizeEvent) -&gt; None:\n        \"\"\"Handle a canvas resize event.\"\"\"\n        ...\n</code></pre>"},{"location":"api/gsp/#gsp.types.viewport_events_types.CanvasResizeEventCallback.__call__","title":"<code>__call__(canvas_resize_event: CanvasResizeEvent) -&gt; None</code>","text":"<p>Handle a canvas resize event.</p> Source code in <code>src/gsp/types/viewport_events_types.py</code> <pre><code>def __call__(self, canvas_resize_event: CanvasResizeEvent) -&gt; None:\n    \"\"\"Handle a canvas resize event.\"\"\"\n    ...\n</code></pre>"},{"location":"api/gsp/#gsp.types.viewport_events_types.EventType","title":"<code>EventType</code>","text":"<p>               Bases: <code>enum.StrEnum</code></p> <p>Enumeration of viewport event types.</p> <p>Defines the different types of user interaction events that can occur in a viewport, including keyboard, mouse, and canvas events.</p> Source code in <code>src/gsp/types/viewport_events_types.py</code> <pre><code>class EventType(StrEnum):\n    \"\"\"Enumeration of viewport event types.\n\n    Defines the different types of user interaction events that can occur\n    in a viewport, including keyboard, mouse, and canvas events.\n    \"\"\"\n\n    KEY_PRESS = \"key_press\"\n    KEY_RELEASE = \"key_release\"\n    BUTTON_PRESS = \"button_press\"\n    BUTTON_RELEASE = \"button_release\"\n    MOUSE_MOVE = \"mouse_move\"\n    MOUSE_SCROLL = \"mouse_scroll\"\n    CANVAS_RESIZE = \"canvas_resize\"\n</code></pre>"},{"location":"api/gsp/#gsp.types.viewport_events_types.KeyEvent","title":"<code>KeyEvent</code>  <code>dataclass</code>","text":"<p>Represents a keyboard event in a viewport.</p> <p>Attributes:</p> Name Type Description <code>viewport_uuid</code> <code>str</code> <p>The unique identifier of the viewport where the event occurred.</p> <code>event_type</code> <code>gsp.types.viewport_events_types.EventType</code> <p>The type of keyboard event (KEY_PRESS or KEY_RELEASE).</p> <code>key_name</code> <code>str</code> <p>The name of the key that was pressed or released.</p> Source code in <code>src/gsp/types/viewport_events_types.py</code> <pre><code>@dataclass\nclass KeyEvent:\n    \"\"\"Represents a keyboard event in a viewport.\n\n    Attributes:\n        viewport_uuid: The unique identifier of the viewport where the event occurred.\n        event_type: The type of keyboard event (KEY_PRESS or KEY_RELEASE).\n        key_name: The name of the key that was pressed or released.\n    \"\"\"\n\n    viewport_uuid: str\n    event_type: EventType\n    key_name: str\n</code></pre>"},{"location":"api/gsp/#gsp.types.viewport_events_types.KeyboardEventCallback","title":"<code>KeyboardEventCallback</code>","text":"<p>               Bases: <code>typing.Protocol</code></p> <p>Protocol for keyboard event callback functions.</p> <p>Defines the signature for functions that handle keyboard events.</p> Source code in <code>src/gsp/types/viewport_events_types.py</code> <pre><code>class KeyboardEventCallback(Protocol):\n    \"\"\"Protocol for keyboard event callback functions.\n\n    Defines the signature for functions that handle keyboard events.\n    \"\"\"\n\n    def __call__(self, key_event: KeyEvent) -&gt; None:\n        \"\"\"Handle a keyboard event.\"\"\"\n</code></pre>"},{"location":"api/gsp/#gsp.types.viewport_events_types.KeyboardEventCallback.__call__","title":"<code>__call__(key_event: KeyEvent) -&gt; None</code>","text":"<p>Handle a keyboard event.</p> Source code in <code>src/gsp/types/viewport_events_types.py</code> <pre><code>def __call__(self, key_event: KeyEvent) -&gt; None:\n    \"\"\"Handle a keyboard event.\"\"\"\n</code></pre>"},{"location":"api/gsp/#gsp.types.viewport_events_types.MouseEvent","title":"<code>MouseEvent</code>  <code>dataclass</code>","text":"<p>Represents a mouse event in a viewport.</p> Source code in <code>src/gsp/types/viewport_events_types.py</code> <pre><code>@dataclass\nclass MouseEvent:\n    \"\"\"Represents a mouse event in a viewport.\"\"\"\n\n    viewport_uuid: str\n    \"\"\"The unique identifier of the viewport where the event occurred.\"\"\"\n    event_type: EventType\n    \"\"\"The type of mouse event (BUTTON_PRESS, BUTTON_RELEASE, MOUSE_MOVE, or MOUSE_SCROLL)\"\"\"\n    x_ndc: float\n    \"\"\"The x-coordinate of the mouse position in the viewport in NDC units.\"\"\"\n    y_ndc: float\n    \"\"\"The y-coordinate of the mouse position in the viewport in NDC units.\"\"\"\n    left_button: bool = False\n    \"\"\"Whether the left mouse button is pressed.\"\"\"\n    middle_button: bool = False\n    \"\"\"Whether the middle mouse button is pressed.\"\"\"\n    right_button: bool = False\n    \"\"\"Whether the right mouse button is pressed.\"\"\"\n    scroll_steps: float = 0.0\n    \"\"\"The number of scroll steps (positive for up, negative for down).\"\"\"\n</code></pre>"},{"location":"api/gsp/#gsp.types.viewport_events_types.MouseEvent.event_type","title":"<code>event_type: EventType</code>  <code>instance-attribute</code>","text":"<p>The type of mouse event (BUTTON_PRESS, BUTTON_RELEASE, MOUSE_MOVE, or MOUSE_SCROLL)</p>"},{"location":"api/gsp/#gsp.types.viewport_events_types.MouseEvent.left_button","title":"<code>left_button: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the left mouse button is pressed.</p>"},{"location":"api/gsp/#gsp.types.viewport_events_types.MouseEvent.middle_button","title":"<code>middle_button: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the middle mouse button is pressed.</p>"},{"location":"api/gsp/#gsp.types.viewport_events_types.MouseEvent.right_button","title":"<code>right_button: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the right mouse button is pressed.</p>"},{"location":"api/gsp/#gsp.types.viewport_events_types.MouseEvent.scroll_steps","title":"<code>scroll_steps: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of scroll steps (positive for up, negative for down).</p>"},{"location":"api/gsp/#gsp.types.viewport_events_types.MouseEvent.viewport_uuid","title":"<code>viewport_uuid: str</code>  <code>instance-attribute</code>","text":"<p>The unique identifier of the viewport where the event occurred.</p>"},{"location":"api/gsp/#gsp.types.viewport_events_types.MouseEvent.x_ndc","title":"<code>x_ndc: float</code>  <code>instance-attribute</code>","text":"<p>The x-coordinate of the mouse position in the viewport in NDC units.</p>"},{"location":"api/gsp/#gsp.types.viewport_events_types.MouseEvent.y_ndc","title":"<code>y_ndc: float</code>  <code>instance-attribute</code>","text":"<p>The y-coordinate of the mouse position in the viewport in NDC units.</p>"},{"location":"api/gsp/#gsp.types.viewport_events_types.MouseEventCallback","title":"<code>MouseEventCallback</code>","text":"<p>               Bases: <code>typing.Protocol</code></p> <p>Protocol for mouse event callback functions.</p> <p>Defines the signature for functions that handle mouse events.</p> Source code in <code>src/gsp/types/viewport_events_types.py</code> <pre><code>class MouseEventCallback(Protocol):\n    \"\"\"Protocol for mouse event callback functions.\n\n    Defines the signature for functions that handle mouse events.\n    \"\"\"\n\n    def __call__(self, mouse_event: MouseEvent) -&gt; None:\n        \"\"\"Handle a mouse event.\"\"\"\n        ...\n</code></pre>"},{"location":"api/gsp/#gsp.types.viewport_events_types.MouseEventCallback.__call__","title":"<code>__call__(mouse_event: MouseEvent) -&gt; None</code>","text":"<p>Handle a mouse event.</p> Source code in <code>src/gsp/types/viewport_events_types.py</code> <pre><code>def __call__(self, mouse_event: MouseEvent) -&gt; None:\n    \"\"\"Handle a mouse event.\"\"\"\n    ...\n</code></pre>"},{"location":"api/gsp/#visuals-module","title":"Visuals Module","text":""},{"location":"api/gsp/#gsp.visuals.points","title":"<code>gsp.visuals.points</code>","text":"<p>Points visual module.</p>"},{"location":"api/gsp/#gsp.visuals.points.Points","title":"<code>Points</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> <p>Points visual for rendering point markers.</p> <p>This visual represents a collection of points with configurable positions, sizes, face colors, edge colors, and edge widths.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>class Points(VisualBase):\n    \"\"\"Points visual for rendering point markers.\n\n    This visual represents a collection of points with configurable positions,\n    sizes, face colors, edge colors, and edge widths.\n    \"\"\"\n    __slots__ = [\"_positions\", \"_sizes\", \"_face_colors\", \"_edge_colors\", \"_edge_widths\"]\n\n    def __init__(self, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf):\n        \"\"\"Initialize Points visual.\n\n        Args:\n            positions: Positions of the points.\n            sizes: Sizes of the points.\n            face_colors: Face colors of the points.\n            edge_colors: Edge colors of the points.\n            edge_widths: Edge widths of the points.\n        \"\"\"\n        super().__init__()\n\n        self._positions: TransBuf = positions\n        self._sizes: TransBuf = sizes\n        self._face_colors: TransBuf = face_colors\n        self._edge_colors: TransBuf = edge_colors\n        self._edge_widths: TransBuf = edge_widths\n\n        self.check_attributes()\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        \"\"\"Get positions of the points.\"\"\"\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        \"\"\"Set positions of the points.\n\n        Args:\n            positions: New positions for the points.\n        \"\"\"\n        self._positions = positions\n        self.check_attributes()\n\n    def get_sizes(self) -&gt; TransBuf:\n        \"\"\"Get sizes of the points.\"\"\"\n        return self._sizes\n\n    def set_sizes(self, sizes: TransBuf) -&gt; None:\n        \"\"\"Set sizes of the points.\n\n        Args:\n            sizes: New sizes for the points.\n        \"\"\"\n        self._sizes = sizes\n        self.check_attributes()\n\n    def get_face_colors(self) -&gt; TransBuf:\n        \"\"\"Get face colors of the points.\"\"\"\n        return self._face_colors\n\n    def set_face_colors(self, face_colors: TransBuf) -&gt; None:\n        \"\"\"Set face colors of the points.\n\n        Args:\n            face_colors: New face colors for the points.\n        \"\"\"\n        self._face_colors = face_colors\n        self.check_attributes()\n\n    def get_edge_colors(self) -&gt; TransBuf:\n        \"\"\"Get edge colors of the points.\"\"\"\n        return self._edge_colors\n\n    def set_edge_colors(self, edge_colors: TransBuf) -&gt; None:\n        \"\"\"Set edge colors of the points.\n\n        Args:\n            edge_colors: New edge colors for the points.\n        \"\"\"\n        self._edge_colors = edge_colors\n        self.check_attributes()\n\n    def get_edge_widths(self) -&gt; TransBuf:\n        \"\"\"Get edge widths of the points.\"\"\"\n        return self._edge_widths\n\n    def set_edge_widths(self, edge_widths: TransBuf) -&gt; None:\n        \"\"\"Set edge widths of the points.\n\n        Args:\n            edge_widths: New edge widths for the points.\n        \"\"\"\n        self._edge_widths = edge_widths\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        positions: TransBuf | None = None,\n        sizes: TransBuf | None = None,\n        face_colors: TransBuf | None = None,\n        edge_colors: TransBuf | None = None,\n        edge_widths: TransBuf | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if positions is not None:\n            self._positions = positions\n        if sizes is not None:\n            self._sizes = sizes\n        if face_colors is not None:\n            self._face_colors = face_colors\n        if edge_colors is not None:\n            self._edge_colors = edge_colors\n        if edge_widths is not None:\n            self._edge_widths = edge_widths\n\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._positions, self._sizes, self._face_colors, self._edge_colors, self._edge_widths)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer):\n        \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(sizes, Buffer), \"Sizes must be a Buffer\"\n        assert isinstance(face_colors, Buffer), \"Face colors must be a Buffer\"\n        assert isinstance(edge_colors, Buffer), \"Edge colors must be a Buffer\"\n        assert isinstance(edge_widths, Buffer), \"Edge widths must be a Buffer\"\n\n        Points.sanity_check_attributes(positions, sizes, face_colors, edge_colors, edge_widths)\n\n    @staticmethod\n    def sanity_check_attributes(\n        positions: TransBuf,\n        sizes: TransBuf,\n        face_colors: TransBuf,\n        edge_colors: TransBuf,\n        edge_widths: TransBuf,\n    ) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\n\n        Args:\n            positions: Positions of the points.\n            sizes: Sizes of the points.\n            face_colors: Face colors of the points.\n            edge_colors: Edge colors of the points.\n            edge_widths: Edge widths of the points.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.__init__","title":"<code>__init__(positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf)</code>","text":"<p>Initialize Points visual.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the points.</p> required <code>sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Sizes of the points.</p> required <code>face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Face colors of the points.</p> required <code>edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Edge colors of the points.</p> required <code>edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Edge widths of the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def __init__(self, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf):\n    \"\"\"Initialize Points visual.\n\n    Args:\n        positions: Positions of the points.\n        sizes: Sizes of the points.\n        face_colors: Face colors of the points.\n        edge_colors: Edge colors of the points.\n        edge_widths: Edge widths of the points.\n    \"\"\"\n    super().__init__()\n\n    self._positions: TransBuf = positions\n    self._sizes: TransBuf = sizes\n    self._face_colors: TransBuf = face_colors\n    self._edge_colors: TransBuf = edge_colors\n    self._edge_widths: TransBuf = edge_widths\n\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._positions, self._sizes, self._face_colors, self._edge_colors, self._edge_widths)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.get_edge_colors","title":"<code>get_edge_colors() -&gt; TransBuf</code>","text":"<p>Get edge colors of the points.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def get_edge_colors(self) -&gt; TransBuf:\n    \"\"\"Get edge colors of the points.\"\"\"\n    return self._edge_colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.get_edge_widths","title":"<code>get_edge_widths() -&gt; TransBuf</code>","text":"<p>Get edge widths of the points.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def get_edge_widths(self) -&gt; TransBuf:\n    \"\"\"Get edge widths of the points.\"\"\"\n    return self._edge_widths\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.get_face_colors","title":"<code>get_face_colors() -&gt; TransBuf</code>","text":"<p>Get face colors of the points.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def get_face_colors(self) -&gt; TransBuf:\n    \"\"\"Get face colors of the points.\"\"\"\n    return self._face_colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.get_positions","title":"<code>get_positions() -&gt; TransBuf</code>","text":"<p>Get positions of the points.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def get_positions(self) -&gt; TransBuf:\n    \"\"\"Get positions of the points.\"\"\"\n    return self._positions\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.get_sizes","title":"<code>get_sizes() -&gt; TransBuf</code>","text":"<p>Get sizes of the points.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def get_sizes(self) -&gt; TransBuf:\n    \"\"\"Get sizes of the points.\"\"\"\n    return self._sizes\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.sanity_check_attributes","title":"<code>sanity_check_attributes(positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Check that the attributes are valid and consistent.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the points.</p> required <code>sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Sizes of the points.</p> required <code>face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Face colors of the points.</p> required <code>edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Edge colors of the points.</p> required <code>edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Edge widths of the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes(\n    positions: TransBuf,\n    sizes: TransBuf,\n    face_colors: TransBuf,\n    edge_colors: TransBuf,\n    edge_widths: TransBuf,\n) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\n\n    Args:\n        positions: Positions of the points.\n        sizes: Sizes of the points.\n        face_colors: Face colors of the points.\n        edge_colors: Edge colors of the points.\n        edge_widths: Edge widths of the points.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer)</code>  <code>staticmethod</code>","text":"<p>Same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer):\n    \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(sizes, Buffer), \"Sizes must be a Buffer\"\n    assert isinstance(face_colors, Buffer), \"Face colors must be a Buffer\"\n    assert isinstance(edge_colors, Buffer), \"Edge colors must be a Buffer\"\n    assert isinstance(edge_widths, Buffer), \"Edge widths must be a Buffer\"\n\n    Points.sanity_check_attributes(positions, sizes, face_colors, edge_colors, edge_widths)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, sizes: TransBuf | None = None, face_colors: TransBuf | None = None, edge_colors: TransBuf | None = None, edge_widths: TransBuf | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def set_attributes(\n    self,\n    positions: TransBuf | None = None,\n    sizes: TransBuf | None = None,\n    face_colors: TransBuf | None = None,\n    edge_colors: TransBuf | None = None,\n    edge_widths: TransBuf | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if positions is not None:\n        self._positions = positions\n    if sizes is not None:\n        self._sizes = sizes\n    if face_colors is not None:\n        self._face_colors = face_colors\n    if edge_colors is not None:\n        self._edge_colors = edge_colors\n    if edge_widths is not None:\n        self._edge_widths = edge_widths\n\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.set_edge_colors","title":"<code>set_edge_colors(edge_colors: TransBuf) -&gt; None</code>","text":"<p>Set edge colors of the points.</p> <p>Parameters:</p> Name Type Description Default <code>edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>New edge colors for the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def set_edge_colors(self, edge_colors: TransBuf) -&gt; None:\n    \"\"\"Set edge colors of the points.\n\n    Args:\n        edge_colors: New edge colors for the points.\n    \"\"\"\n    self._edge_colors = edge_colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.set_edge_widths","title":"<code>set_edge_widths(edge_widths: TransBuf) -&gt; None</code>","text":"<p>Set edge widths of the points.</p> <p>Parameters:</p> Name Type Description Default <code>edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>New edge widths for the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def set_edge_widths(self, edge_widths: TransBuf) -&gt; None:\n    \"\"\"Set edge widths of the points.\n\n    Args:\n        edge_widths: New edge widths for the points.\n    \"\"\"\n    self._edge_widths = edge_widths\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.set_face_colors","title":"<code>set_face_colors(face_colors: TransBuf) -&gt; None</code>","text":"<p>Set face colors of the points.</p> <p>Parameters:</p> Name Type Description Default <code>face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>New face colors for the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def set_face_colors(self, face_colors: TransBuf) -&gt; None:\n    \"\"\"Set face colors of the points.\n\n    Args:\n        face_colors: New face colors for the points.\n    \"\"\"\n    self._face_colors = face_colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.set_positions","title":"<code>set_positions(positions: TransBuf) -&gt; None</code>","text":"<p>Set positions of the points.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>New positions for the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def set_positions(self, positions: TransBuf) -&gt; None:\n    \"\"\"Set positions of the points.\n\n    Args:\n        positions: New positions for the points.\n    \"\"\"\n    self._positions = positions\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.set_sizes","title":"<code>set_sizes(sizes: TransBuf) -&gt; None</code>","text":"<p>Set sizes of the points.</p> <p>Parameters:</p> Name Type Description Default <code>sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>New sizes for the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def set_sizes(self, sizes: TransBuf) -&gt; None:\n    \"\"\"Set sizes of the points.\n\n    Args:\n        sizes: New sizes for the points.\n    \"\"\"\n    self._sizes = sizes\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers","title":"<code>gsp.visuals.markers</code>","text":"<p>Marker visual for rendering 2D/3D markers with customizable shapes, sizes, and colors.</p>"},{"location":"api/gsp/#gsp.visuals.markers.Markers","title":"<code>Markers</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> <p>Visual representation of markers with configurable properties.</p> <p>This class manages marker visualization with properties including shape, positions, sizes, face colors, edge colors, and edge widths.</p> <p>Attributes:</p> Name Type Description <code>_marker_shape</code> <code>gsp.types.marker_shape.MarkerShape</code> <p>The shape of the markers.</p> <code>_positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>The positions of the markers.</p> <code>_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>The sizes of the markers.</p> <code>_face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The face colors of the markers.</p> <code>_edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The edge colors of the markers.</p> <code>_edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>The edge widths of the markers.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>class Markers(VisualBase):\n    \"\"\"Visual representation of markers with configurable properties.\n\n    This class manages marker visualization with properties including shape,\n    positions, sizes, face colors, edge colors, and edge widths.\n\n    Attributes:\n        _marker_shape (MarkerShape): The shape of the markers.\n        _positions (TransBuf): The positions of the markers.\n        _sizes (TransBuf): The sizes of the markers.\n        _face_colors (TransBuf): The face colors of the markers.\n        _edge_colors (TransBuf): The edge colors of the markers.\n        _edge_widths (TransBuf): The edge widths of the markers.\n    \"\"\"\n    __slots__ = [\"_marker_shape\", \"_positions\", \"_sizes\", \"_face_colors\", \"_edge_colors\", \"_edge_widths\"]\n\n    def __init__(self, marker_shape: MarkerShape, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf):\n        \"\"\"Initialize a Markers visual.\n\n        Args:\n            marker_shape (MarkerShape): The shape of the markers.\n            positions (TransBuf): The positions of the markers.\n            sizes (TransBuf): The sizes of the markers.\n            face_colors (TransBuf): The face colors of the markers.\n            edge_colors (TransBuf): The edge colors of the markers.\n            edge_widths (TransBuf): The edge widths of the markers.\n        \"\"\"\n        super().__init__()\n\n        self._marker_shape: MarkerShape = marker_shape\n        self._positions: TransBuf = positions\n        self._sizes: TransBuf = sizes\n        self._face_colors: TransBuf = face_colors\n        self._edge_colors: TransBuf = edge_colors\n        self._edge_widths: TransBuf = edge_widths\n\n        self.check_attributes()\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_marker_shape(self) -&gt; MarkerShape:\n        \"\"\"Get the marker shape.\n\n        Returns:\n            MarkerShape: The marker shape.\n        \"\"\"\n        return self._marker_shape\n\n    def set_marker_shape(self, marker_shape: MarkerShape) -&gt; None:\n        \"\"\"Set the marker shape.\n\n        Args:\n            marker_shape (MarkerShape): The new marker shape.\n        \"\"\"\n        self._marker_shape = marker_shape\n        self.check_attributes()\n\n    def get_positions(self) -&gt; TransBuf:\n        \"\"\"Get the marker positions.\n\n        Returns:\n            TransBuf: The marker positions.\n        \"\"\"\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        \"\"\"Set the marker positions.\n\n        Args:\n            positions (TransBuf): The new marker positions.\n        \"\"\"\n        self._positions = positions\n        self.check_attributes()\n\n    def get_sizes(self) -&gt; TransBuf:\n        \"\"\"Get the marker sizes.\n\n        Returns:\n            TransBuf: The marker sizes.\n        \"\"\"\n        return self._sizes\n\n    def set_sizes(self, sizes: TransBuf) -&gt; None:\n        \"\"\"Set the marker sizes.\n\n        Args:\n            sizes (TransBuf): The new marker sizes.\n        \"\"\"\n        self._sizes = sizes\n        self.check_attributes()\n\n    def get_face_colors(self) -&gt; TransBuf:\n        \"\"\"Get the marker face colors.\n\n        Returns:\n            TransBuf: The marker face colors.\n        \"\"\"\n        return self._face_colors\n\n    def set_face_colors(self, face_colors: TransBuf) -&gt; None:\n        \"\"\"Set the marker face colors.\n\n        Args:\n            face_colors (TransBuf): The new marker face colors.\n        \"\"\"\n        self._face_colors = face_colors\n        self.check_attributes()\n\n    def get_edge_colors(self) -&gt; TransBuf:\n        \"\"\"Get the marker edge colors.\n\n        Returns:\n            TransBuf: The marker edge colors.\n        \"\"\"\n        return self._edge_colors\n\n    def set_edge_colors(self, edge_colors: TransBuf) -&gt; None:\n        \"\"\"Set the marker edge colors.\n\n        Args:\n            edge_colors (TransBuf): The new marker edge colors.\n        \"\"\"\n        self._edge_colors = edge_colors\n        self.check_attributes()\n\n    def get_edge_widths(self) -&gt; TransBuf:\n        \"\"\"Get the marker edge widths.\n\n        Returns:\n            TransBuf: The marker edge widths.\n        \"\"\"\n        return self._edge_widths\n\n    def set_edge_widths(self, edge_widths: TransBuf) -&gt; None:\n        \"\"\"Set the marker edge widths.\n\n        Args:\n            edge_widths (TransBuf): The new marker edge widths.\n        \"\"\"\n        self._edge_widths = edge_widths\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        marker_shape: MarkerShape | None = None,\n        positions: TransBuf | None = None,\n        sizes: TransBuf | None = None,\n        face_colors: TransBuf | None = None,\n        edge_colors: TransBuf | None = None,\n        edge_widths: TransBuf | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if marker_shape is not None:\n            self._marker_shape = marker_shape\n        if positions is not None:\n            self._positions = positions\n        if sizes is not None:\n            self._sizes = sizes\n        if face_colors is not None:\n            self._face_colors = face_colors\n        if edge_colors is not None:\n            self._edge_colors = edge_colors\n        if edge_widths is not None:\n            self._edge_widths = edge_widths\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._marker_shape, self._positions, self._sizes, self._face_colors, self._edge_colors, self._edge_widths)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(\n        marker_shape: MarkerShape, positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer\n    ):\n        \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n        This method is meant to be used after converting TransBuf to Buffer.\n\n        Args:\n            marker_shape (MarkerShape): The marker shape.\n            positions (Buffer): The marker positions as a Buffer.\n            sizes (Buffer): The marker sizes as a Buffer.\n            face_colors (Buffer): The marker face colors as a Buffer.\n            edge_colors (Buffer): The marker edge colors as a Buffer.\n            edge_widths (Buffer): The marker edge widths as a Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(sizes, Buffer), \"Sizes must be a Buffer\"\n        assert isinstance(face_colors, Buffer), \"Face colors must be a Buffer\"\n        assert isinstance(edge_colors, Buffer), \"Edge colors must be a Buffer\"\n        assert isinstance(edge_widths, Buffer), \"Edge widths must be a Buffer\"\n\n        Markers.sanity_check_attributes(marker_shape, positions, sizes, face_colors, edge_colors, edge_widths)\n\n    @staticmethod\n    def sanity_check_attributes(\n        marker_shape: MarkerShape,\n        positions: TransBuf,\n        sizes: TransBuf,\n        face_colors: TransBuf,\n        edge_colors: TransBuf,\n        edge_widths: TransBuf,\n    ) -&gt; None:\n        \"\"\"Check that the marker attributes are valid and consistent.\n\n        Args:\n            marker_shape (MarkerShape): The marker shape.\n            positions (TransBuf): The marker positions.\n            sizes (TransBuf): The marker sizes.\n            face_colors (TransBuf): The marker face colors.\n            edge_colors (TransBuf): The marker edge colors.\n            edge_widths (TransBuf): The marker edge widths.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.__init__","title":"<code>__init__(marker_shape: MarkerShape, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf)</code>","text":"<p>Initialize a Markers visual.</p> <p>Parameters:</p> Name Type Description Default <code>marker_shape</code> <code>gsp.types.marker_shape.MarkerShape</code> <p>The shape of the markers.</p> required <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>The positions of the markers.</p> required <code>sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>The sizes of the markers.</p> required <code>face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The face colors of the markers.</p> required <code>edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The edge colors of the markers.</p> required <code>edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>The edge widths of the markers.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def __init__(self, marker_shape: MarkerShape, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf):\n    \"\"\"Initialize a Markers visual.\n\n    Args:\n        marker_shape (MarkerShape): The shape of the markers.\n        positions (TransBuf): The positions of the markers.\n        sizes (TransBuf): The sizes of the markers.\n        face_colors (TransBuf): The face colors of the markers.\n        edge_colors (TransBuf): The edge colors of the markers.\n        edge_widths (TransBuf): The edge widths of the markers.\n    \"\"\"\n    super().__init__()\n\n    self._marker_shape: MarkerShape = marker_shape\n    self._positions: TransBuf = positions\n    self._sizes: TransBuf = sizes\n    self._face_colors: TransBuf = face_colors\n    self._edge_colors: TransBuf = edge_colors\n    self._edge_widths: TransBuf = edge_widths\n\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._marker_shape, self._positions, self._sizes, self._face_colors, self._edge_colors, self._edge_widths)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.get_edge_colors","title":"<code>get_edge_colors() -&gt; TransBuf</code>","text":"<p>Get the marker edge colors.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker edge colors.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def get_edge_colors(self) -&gt; TransBuf:\n    \"\"\"Get the marker edge colors.\n\n    Returns:\n        TransBuf: The marker edge colors.\n    \"\"\"\n    return self._edge_colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.get_edge_widths","title":"<code>get_edge_widths() -&gt; TransBuf</code>","text":"<p>Get the marker edge widths.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker edge widths.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def get_edge_widths(self) -&gt; TransBuf:\n    \"\"\"Get the marker edge widths.\n\n    Returns:\n        TransBuf: The marker edge widths.\n    \"\"\"\n    return self._edge_widths\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.get_face_colors","title":"<code>get_face_colors() -&gt; TransBuf</code>","text":"<p>Get the marker face colors.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker face colors.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def get_face_colors(self) -&gt; TransBuf:\n    \"\"\"Get the marker face colors.\n\n    Returns:\n        TransBuf: The marker face colors.\n    \"\"\"\n    return self._face_colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.get_marker_shape","title":"<code>get_marker_shape() -&gt; MarkerShape</code>","text":"<p>Get the marker shape.</p> <p>Returns:</p> Name Type Description <code>MarkerShape</code> <code>gsp.types.marker_shape.MarkerShape</code> <p>The marker shape.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def get_marker_shape(self) -&gt; MarkerShape:\n    \"\"\"Get the marker shape.\n\n    Returns:\n        MarkerShape: The marker shape.\n    \"\"\"\n    return self._marker_shape\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.get_positions","title":"<code>get_positions() -&gt; TransBuf</code>","text":"<p>Get the marker positions.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker positions.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def get_positions(self) -&gt; TransBuf:\n    \"\"\"Get the marker positions.\n\n    Returns:\n        TransBuf: The marker positions.\n    \"\"\"\n    return self._positions\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.get_sizes","title":"<code>get_sizes() -&gt; TransBuf</code>","text":"<p>Get the marker sizes.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker sizes.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def get_sizes(self) -&gt; TransBuf:\n    \"\"\"Get the marker sizes.\n\n    Returns:\n        TransBuf: The marker sizes.\n    \"\"\"\n    return self._sizes\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.sanity_check_attributes","title":"<code>sanity_check_attributes(marker_shape: MarkerShape, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Check that the marker attributes are valid and consistent.</p> <p>Parameters:</p> Name Type Description Default <code>marker_shape</code> <code>gsp.types.marker_shape.MarkerShape</code> <p>The marker shape.</p> required <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker positions.</p> required <code>sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker sizes.</p> required <code>face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker face colors.</p> required <code>edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker edge colors.</p> required <code>edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker edge widths.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes(\n    marker_shape: MarkerShape,\n    positions: TransBuf,\n    sizes: TransBuf,\n    face_colors: TransBuf,\n    edge_colors: TransBuf,\n    edge_widths: TransBuf,\n) -&gt; None:\n    \"\"\"Check that the marker attributes are valid and consistent.\n\n    Args:\n        marker_shape (MarkerShape): The marker shape.\n        positions (TransBuf): The marker positions.\n        sizes (TransBuf): The marker sizes.\n        face_colors (TransBuf): The marker face colors.\n        edge_colors (TransBuf): The marker edge colors.\n        edge_widths (TransBuf): The marker edge widths.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(marker_shape: MarkerShape, positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer)</code>  <code>staticmethod</code>","text":"<p>Same as .sanity_check_attributes() but accept only Buffers.</p> <p>This method is meant to be used after converting TransBuf to Buffer.</p> <p>Parameters:</p> Name Type Description Default <code>marker_shape</code> <code>gsp.types.marker_shape.MarkerShape</code> <p>The marker shape.</p> required <code>positions</code> <code>gsp.types.buffer.Buffer</code> <p>The marker positions as a Buffer.</p> required <code>sizes</code> <code>gsp.types.buffer.Buffer</code> <p>The marker sizes as a Buffer.</p> required <code>face_colors</code> <code>gsp.types.buffer.Buffer</code> <p>The marker face colors as a Buffer.</p> required <code>edge_colors</code> <code>gsp.types.buffer.Buffer</code> <p>The marker edge colors as a Buffer.</p> required <code>edge_widths</code> <code>gsp.types.buffer.Buffer</code> <p>The marker edge widths as a Buffer.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(\n    marker_shape: MarkerShape, positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer\n):\n    \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n    This method is meant to be used after converting TransBuf to Buffer.\n\n    Args:\n        marker_shape (MarkerShape): The marker shape.\n        positions (Buffer): The marker positions as a Buffer.\n        sizes (Buffer): The marker sizes as a Buffer.\n        face_colors (Buffer): The marker face colors as a Buffer.\n        edge_colors (Buffer): The marker edge colors as a Buffer.\n        edge_widths (Buffer): The marker edge widths as a Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(sizes, Buffer), \"Sizes must be a Buffer\"\n    assert isinstance(face_colors, Buffer), \"Face colors must be a Buffer\"\n    assert isinstance(edge_colors, Buffer), \"Edge colors must be a Buffer\"\n    assert isinstance(edge_widths, Buffer), \"Edge widths must be a Buffer\"\n\n    Markers.sanity_check_attributes(marker_shape, positions, sizes, face_colors, edge_colors, edge_widths)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_attributes","title":"<code>set_attributes(marker_shape: MarkerShape | None = None, positions: TransBuf | None = None, sizes: TransBuf | None = None, face_colors: TransBuf | None = None, edge_colors: TransBuf | None = None, edge_widths: TransBuf | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_attributes(\n    self,\n    marker_shape: MarkerShape | None = None,\n    positions: TransBuf | None = None,\n    sizes: TransBuf | None = None,\n    face_colors: TransBuf | None = None,\n    edge_colors: TransBuf | None = None,\n    edge_widths: TransBuf | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if marker_shape is not None:\n        self._marker_shape = marker_shape\n    if positions is not None:\n        self._positions = positions\n    if sizes is not None:\n        self._sizes = sizes\n    if face_colors is not None:\n        self._face_colors = face_colors\n    if edge_colors is not None:\n        self._edge_colors = edge_colors\n    if edge_widths is not None:\n        self._edge_widths = edge_widths\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_edge_colors","title":"<code>set_edge_colors(edge_colors: TransBuf) -&gt; None</code>","text":"<p>Set the marker edge colors.</p> <p>Parameters:</p> Name Type Description Default <code>edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new marker edge colors.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_edge_colors(self, edge_colors: TransBuf) -&gt; None:\n    \"\"\"Set the marker edge colors.\n\n    Args:\n        edge_colors (TransBuf): The new marker edge colors.\n    \"\"\"\n    self._edge_colors = edge_colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_edge_widths","title":"<code>set_edge_widths(edge_widths: TransBuf) -&gt; None</code>","text":"<p>Set the marker edge widths.</p> <p>Parameters:</p> Name Type Description Default <code>edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new marker edge widths.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_edge_widths(self, edge_widths: TransBuf) -&gt; None:\n    \"\"\"Set the marker edge widths.\n\n    Args:\n        edge_widths (TransBuf): The new marker edge widths.\n    \"\"\"\n    self._edge_widths = edge_widths\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_face_colors","title":"<code>set_face_colors(face_colors: TransBuf) -&gt; None</code>","text":"<p>Set the marker face colors.</p> <p>Parameters:</p> Name Type Description Default <code>face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new marker face colors.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_face_colors(self, face_colors: TransBuf) -&gt; None:\n    \"\"\"Set the marker face colors.\n\n    Args:\n        face_colors (TransBuf): The new marker face colors.\n    \"\"\"\n    self._face_colors = face_colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_marker_shape","title":"<code>set_marker_shape(marker_shape: MarkerShape) -&gt; None</code>","text":"<p>Set the marker shape.</p> <p>Parameters:</p> Name Type Description Default <code>marker_shape</code> <code>gsp.types.marker_shape.MarkerShape</code> <p>The new marker shape.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_marker_shape(self, marker_shape: MarkerShape) -&gt; None:\n    \"\"\"Set the marker shape.\n\n    Args:\n        marker_shape (MarkerShape): The new marker shape.\n    \"\"\"\n    self._marker_shape = marker_shape\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_positions","title":"<code>set_positions(positions: TransBuf) -&gt; None</code>","text":"<p>Set the marker positions.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new marker positions.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_positions(self, positions: TransBuf) -&gt; None:\n    \"\"\"Set the marker positions.\n\n    Args:\n        positions (TransBuf): The new marker positions.\n    \"\"\"\n    self._positions = positions\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_sizes","title":"<code>set_sizes(sizes: TransBuf) -&gt; None</code>","text":"<p>Set the marker sizes.</p> <p>Parameters:</p> Name Type Description Default <code>sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new marker sizes.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_sizes(self, sizes: TransBuf) -&gt; None:\n    \"\"\"Set the marker sizes.\n\n    Args:\n        sizes (TransBuf): The new marker sizes.\n    \"\"\"\n    self._sizes = sizes\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments","title":"<code>gsp.visuals.segments</code>","text":"<p>Segments visual module.</p>"},{"location":"api/gsp/#gsp.visuals.segments.Segments","title":"<code>Segments</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> <p>Segments visual for rendering line segments.</p> <p>This visual represents a collection of line segments with configurable positions, line widths, cap styles, and colors.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>class Segments(VisualBase):\n    \"\"\"Segments visual for rendering line segments.\n\n    This visual represents a collection of line segments with configurable\n    positions, line widths, cap styles, and colors.\n    \"\"\"\n    __slots__ = [\"_positions\", \"_colors\", \"_line_widths\", \"_cap_style\"]\n\n    def __init__(self, positions: TransBuf, line_widths: TransBuf, cap_style: CapStyle, colors: TransBuf) -&gt; None:\n        \"\"\"Initialize Segments visual.\n\n        Args:\n            positions: Positions of the segment endpoints.\n            line_widths: Widths of the line segments.\n            cap_style: Cap style for the line segments.\n            colors: Colors of the segments.\n        \"\"\"\n        super().__init__()\n\n        self._positions: TransBuf = positions\n        self._line_widths: TransBuf = line_widths\n        self._cap_style: CapStyle = cap_style\n        self._colors: TransBuf = colors\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        \"\"\"Get positions of the segment endpoints.\"\"\"\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        \"\"\"Set positions of the segment endpoints.\n\n        Args:\n            positions: New positions for the segments.\n        \"\"\"\n        self._positions = positions\n        self.check_attributes()\n\n    def get_line_widths(self) -&gt; TransBuf:\n        \"\"\"Get line widths of the segments.\"\"\"\n        return self._line_widths\n\n    def set_line_widths(self, line_widths: TransBuf) -&gt; None:\n        \"\"\"Set line widths of the segments.\n\n        Args:\n            line_widths: New line widths for the segments.\n        \"\"\"\n        self._line_widths = line_widths\n        self.check_attributes()\n\n    def get_cap_style(self) -&gt; CapStyle:\n        \"\"\"Get cap style of the segments.\"\"\"\n        return self._cap_style\n\n    def set_cap_style(self, cap_style: CapStyle) -&gt; None:\n        \"\"\"Set cap style of the segments.\n\n        Args:\n            cap_style: New cap style for the segments.\n        \"\"\"\n        self._cap_style = cap_style\n        self.check_attributes()\n\n    def get_colors(self) -&gt; TransBuf:\n        \"\"\"Get colors of the segments.\"\"\"\n        return self._colors\n\n    def set_colors(self, colors: TransBuf) -&gt; None:\n        \"\"\"Set colors of the segments.\n\n        Args:\n            colors: New colors for the segments.\n        \"\"\"\n        self._colors = colors\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        positions: TransBuf | None = None,\n        line_widths: TransBuf | None = None,\n        cap_style: CapStyle | None = None,\n        colors: TransBuf | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if positions is not None:\n            self._positions = positions\n        if line_widths is not None:\n            self._line_widths = line_widths\n        if cap_style is not None:\n            self._cap_style = cap_style\n        if colors is not None:\n            self._colors = colors\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._positions, self._line_widths, self._cap_style, self._colors)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(positions: Buffer, line_widths: Buffer, cap_style: CapStyle, colors: Buffer) -&gt; None:\n        \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(line_widths, Buffer), \"Line widths must be a Buffer\"\n        assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n\n        Segments.sanity_check_attributes(positions, line_widths, cap_style, colors)\n\n    @staticmethod\n    def sanity_check_attributes(\n        positions: TransBuf,\n        line_widths: TransBuf,\n        cap_style: CapStyle,\n        colors: TransBuf,\n    ) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\n\n        Args:\n            positions: Positions of the segment endpoints.\n            line_widths: Widths of the line segments.\n            cap_style: Cap style for the line segments.\n            colors: Colors of the segments.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.__init__","title":"<code>__init__(positions: TransBuf, line_widths: TransBuf, cap_style: CapStyle, colors: TransBuf) -&gt; None</code>","text":"<p>Initialize Segments visual.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the segment endpoints.</p> required <code>line_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Widths of the line segments.</p> required <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>Cap style for the line segments.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Colors of the segments.</p> required Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def __init__(self, positions: TransBuf, line_widths: TransBuf, cap_style: CapStyle, colors: TransBuf) -&gt; None:\n    \"\"\"Initialize Segments visual.\n\n    Args:\n        positions: Positions of the segment endpoints.\n        line_widths: Widths of the line segments.\n        cap_style: Cap style for the line segments.\n        colors: Colors of the segments.\n    \"\"\"\n    super().__init__()\n\n    self._positions: TransBuf = positions\n    self._line_widths: TransBuf = line_widths\n    self._cap_style: CapStyle = cap_style\n    self._colors: TransBuf = colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._positions, self._line_widths, self._cap_style, self._colors)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.get_cap_style","title":"<code>get_cap_style() -&gt; CapStyle</code>","text":"<p>Get cap style of the segments.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def get_cap_style(self) -&gt; CapStyle:\n    \"\"\"Get cap style of the segments.\"\"\"\n    return self._cap_style\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.get_colors","title":"<code>get_colors() -&gt; TransBuf</code>","text":"<p>Get colors of the segments.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def get_colors(self) -&gt; TransBuf:\n    \"\"\"Get colors of the segments.\"\"\"\n    return self._colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.get_line_widths","title":"<code>get_line_widths() -&gt; TransBuf</code>","text":"<p>Get line widths of the segments.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def get_line_widths(self) -&gt; TransBuf:\n    \"\"\"Get line widths of the segments.\"\"\"\n    return self._line_widths\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.get_positions","title":"<code>get_positions() -&gt; TransBuf</code>","text":"<p>Get positions of the segment endpoints.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def get_positions(self) -&gt; TransBuf:\n    \"\"\"Get positions of the segment endpoints.\"\"\"\n    return self._positions\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.sanity_check_attributes","title":"<code>sanity_check_attributes(positions: TransBuf, line_widths: TransBuf, cap_style: CapStyle, colors: TransBuf) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Check that the attributes are valid and consistent.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the segment endpoints.</p> required <code>line_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Widths of the line segments.</p> required <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>Cap style for the line segments.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Colors of the segments.</p> required Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes(\n    positions: TransBuf,\n    line_widths: TransBuf,\n    cap_style: CapStyle,\n    colors: TransBuf,\n) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\n\n    Args:\n        positions: Positions of the segment endpoints.\n        line_widths: Widths of the line segments.\n        cap_style: Cap style for the line segments.\n        colors: Colors of the segments.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(positions: Buffer, line_widths: Buffer, cap_style: CapStyle, colors: Buffer) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(positions: Buffer, line_widths: Buffer, cap_style: CapStyle, colors: Buffer) -&gt; None:\n    \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(line_widths, Buffer), \"Line widths must be a Buffer\"\n    assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n\n    Segments.sanity_check_attributes(positions, line_widths, cap_style, colors)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, line_widths: TransBuf | None = None, cap_style: CapStyle | None = None, colors: TransBuf | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def set_attributes(\n    self,\n    positions: TransBuf | None = None,\n    line_widths: TransBuf | None = None,\n    cap_style: CapStyle | None = None,\n    colors: TransBuf | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if positions is not None:\n        self._positions = positions\n    if line_widths is not None:\n        self._line_widths = line_widths\n    if cap_style is not None:\n        self._cap_style = cap_style\n    if colors is not None:\n        self._colors = colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.set_cap_style","title":"<code>set_cap_style(cap_style: CapStyle) -&gt; None</code>","text":"<p>Set cap style of the segments.</p> <p>Parameters:</p> Name Type Description Default <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>New cap style for the segments.</p> required Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def set_cap_style(self, cap_style: CapStyle) -&gt; None:\n    \"\"\"Set cap style of the segments.\n\n    Args:\n        cap_style: New cap style for the segments.\n    \"\"\"\n    self._cap_style = cap_style\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.set_colors","title":"<code>set_colors(colors: TransBuf) -&gt; None</code>","text":"<p>Set colors of the segments.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>New colors for the segments.</p> required Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def set_colors(self, colors: TransBuf) -&gt; None:\n    \"\"\"Set colors of the segments.\n\n    Args:\n        colors: New colors for the segments.\n    \"\"\"\n    self._colors = colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.set_line_widths","title":"<code>set_line_widths(line_widths: TransBuf) -&gt; None</code>","text":"<p>Set line widths of the segments.</p> <p>Parameters:</p> Name Type Description Default <code>line_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>New line widths for the segments.</p> required Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def set_line_widths(self, line_widths: TransBuf) -&gt; None:\n    \"\"\"Set line widths of the segments.\n\n    Args:\n        line_widths: New line widths for the segments.\n    \"\"\"\n    self._line_widths = line_widths\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.set_positions","title":"<code>set_positions(positions: TransBuf) -&gt; None</code>","text":"<p>Set positions of the segment endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>New positions for the segments.</p> required Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def set_positions(self, positions: TransBuf) -&gt; None:\n    \"\"\"Set positions of the segment endpoints.\n\n    Args:\n        positions: New positions for the segments.\n    \"\"\"\n    self._positions = positions\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths","title":"<code>gsp.visuals.paths</code>","text":"<p>Path rendering visual for drawing connected line segments.</p> <p>This module provides the Paths visual class for rendering continuous paths with customizable line widths, colors, cap styles, and join styles.</p>"},{"location":"api/gsp/#gsp.visuals.paths.Paths","title":"<code>Paths</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> <p>Visual for rendering continuous paths with customizable styling.</p> <p>Paths are sequences of connected line segments that can have varying colors, line widths, and end/join styling.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>class Paths(VisualBase):\n    \"\"\"Visual for rendering continuous paths with customizable styling.\n\n    Paths are sequences of connected line segments that can have varying\n    colors, line widths, and end/join styling.\n    \"\"\"\n\n    __slots__ = [\"_positions\", \"_path_sizes\", \"_colors\", \"_line_widths\", \"_cap_style\", \"_join_style\"]\n\n    def __init__(self, positions: TransBuf, path_sizes: TransBuf, colors: TransBuf, line_widths: TransBuf, cap_style: CapStyle, join_style: JoinStyle) -&gt; None:\n        \"\"\"Initialize the Paths visual.\n\n        Args:\n            positions (TransBuf): 3D positions for all path vertices.\n            path_sizes (TransBuf): Number of vertices in each path.\n            colors (TransBuf): RGBA colors for each path.\n            line_widths (TransBuf): Line widths for each path.\n            cap_style (CapStyle): Style for line endings (round, square, butt).\n            join_style (JoinStyle): Style for line joins (miter, bevel, round).\n        \"\"\"\n        super().__init__()\n\n        self._positions: TransBuf = positions\n        self._path_sizes: TransBuf = path_sizes\n        self._colors: TransBuf = colors\n        self._line_widths: TransBuf = line_widths\n        self._cap_style: CapStyle = cap_style\n        self._join_style: JoinStyle = join_style\n        self.check_attributes()\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        \"\"\"Get the positions buffer.\n\n        Returns:\n            TransBuf: 3D positions for all path vertices.\n        \"\"\"\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        \"\"\"Set the positions buffer.\n\n        Args:\n            positions (TransBuf): 3D positions for all path vertices.\n        \"\"\"\n        self._positions = positions\n        self.check_attributes()\n\n    def get_path_sizes(self) -&gt; TransBuf:\n        \"\"\"Get the path sizes buffer.\n\n        Returns:\n            TransBuf: Number of vertices in each path.\n        \"\"\"\n        return self._path_sizes\n\n    def set_path_sizes(self, path_sizes: TransBuf) -&gt; None:\n        \"\"\"Set the path sizes buffer.\n\n        Args:\n            path_sizes (TransBuf): Number of vertices in each path.\n        \"\"\"\n        self._path_sizes = path_sizes\n        self.check_attributes()\n\n    def get_colors(self) -&gt; TransBuf:\n        \"\"\"Get the colors buffer.\n\n        Returns:\n            TransBuf: RGBA colors for each path.\n        \"\"\"\n        return self._colors\n\n    def set_colors(self, colors: TransBuf) -&gt; None:\n        \"\"\"Set the colors buffer.\n\n        Args:\n            colors (TransBuf): RGBA colors for each path.\n        \"\"\"\n        self._colors = colors\n        self.check_attributes()\n\n    def get_line_widths(self) -&gt; TransBuf:\n        \"\"\"Get the line widths buffer.\n\n        Returns:\n            TransBuf: Line widths for each path.\n        \"\"\"\n        return self._line_widths\n\n    def set_line_widths(self, line_widths: TransBuf) -&gt; None:\n        \"\"\"Set the line widths buffer.\n\n        Args:\n            line_widths (TransBuf): Line widths for each path.\n        \"\"\"\n        self._line_widths = line_widths\n        self.check_attributes()\n\n    def get_join_style(self) -&gt; JoinStyle:\n        \"\"\"Get the join style.\n\n        Returns:\n            JoinStyle: Style for line joins (miter, bevel, round).\n        \"\"\"\n        return self._join_style\n\n    def set_join_style(self, join_style: JoinStyle) -&gt; None:\n        \"\"\"Set the join style.\n\n        Args:\n            join_style (JoinStyle): Style for line joins (miter, bevel, round).\n        \"\"\"\n        self._join_style = join_style\n        self.check_attributes()\n\n    def get_cap_style(self) -&gt; CapStyle:\n        \"\"\"Get the cap style.\n\n        Returns:\n            CapStyle: Style for line endings (round, square, butt).\n        \"\"\"\n        return self._cap_style\n\n    def set_cap_style(self, cap_style: CapStyle) -&gt; None:\n        \"\"\"Set the cap style.\n\n        Args:\n            cap_style (CapStyle): Style for line endings (round, square, butt).\n        \"\"\"\n        self._cap_style = cap_style\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        positions: TransBuf | None = None,\n        path_sizes: TransBuf | None = None,\n        colors: TransBuf | None = None,\n        line_widths: TransBuf | None = None,\n        cap_style: CapStyle | None = None,\n        join_style: JoinStyle | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\n\n        Args:\n            positions (TransBuf | None, optional): 3D positions for all path vertices.\n            path_sizes (TransBuf | None, optional): Number of vertices in each path.\n            colors (TransBuf | None, optional): RGBA colors for each path.\n            line_widths (TransBuf | None, optional): Line widths for each path.\n            cap_style (CapStyle | None, optional): Style for line endings (round, square, butt).\n            join_style (JoinStyle | None, optional): Style for line joins (miter, bevel, round).\n        \"\"\"\n        if positions is not None:\n            self._positions = positions\n        if path_sizes is not None:\n            self._path_sizes = path_sizes\n        if colors is not None:\n            self._colors = colors\n        if line_widths is not None:\n            self._line_widths = line_widths\n        if cap_style is not None:\n            self._cap_style = cap_style\n        if join_style is not None:\n            self._join_style = join_style\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._positions, self._path_sizes, self._colors, self._line_widths, self._cap_style, self._join_style)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(\n        positions: Buffer, path_sizes: Buffer, colors: Buffer, line_widths: Buffer, cap_style: CapStyle, join_style: JoinStyle\n    ) -&gt; None:\n        \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n        It is meant to be used after converting TransBuf to Buffer.\n\n        Args:\n            positions (Buffer): 3D positions for all path vertices.\n            path_sizes (Buffer): Number of vertices in each path.\n            colors (Buffer): RGBA colors for each path.\n            line_widths (Buffer): Line widths for each path.\n            cap_style (CapStyle): Style for line endings.\n            join_style (JoinStyle): Style for line joins.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(path_sizes, Buffer), \"Path sizes must be a Buffer\"\n        assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n        assert isinstance(line_widths, Buffer), \"Line widths must be a Buffer\"\n\n        Paths.sanity_check_attributes(positions, path_sizes, colors, line_widths, cap_style, join_style)\n\n    @staticmethod\n    def sanity_check_attributes(\n        positions: TransBuf,\n        path_sizes: TransBuf,\n        colors: TransBuf,\n        line_widths: TransBuf,\n        cap_style: CapStyle,\n        join_style: JoinStyle,\n    ) -&gt; None:\n        \"\"\"Validate attribute dimensions and compatibility.\n\n        Args:\n            positions (TransBuf): 3D positions for all path vertices.\n            path_sizes (TransBuf): Number of vertices in each path.\n            colors (TransBuf): RGBA colors for each path.\n            line_widths (TransBuf): Line widths for each path.\n            cap_style (CapStyle): Style for line endings.\n            join_style (JoinStyle): Style for line joins.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.__init__","title":"<code>__init__(positions: TransBuf, path_sizes: TransBuf, colors: TransBuf, line_widths: TransBuf, cap_style: CapStyle, join_style: JoinStyle) -&gt; None</code>","text":"<p>Initialize the Paths visual.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>3D positions for all path vertices.</p> required <code>path_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Number of vertices in each path.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>RGBA colors for each path.</p> required <code>line_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Line widths for each path.</p> required <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>Style for line endings (round, square, butt).</p> required <code>join_style</code> <code>gsp.types.join_style.JoinStyle</code> <p>Style for line joins (miter, bevel, round).</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def __init__(self, positions: TransBuf, path_sizes: TransBuf, colors: TransBuf, line_widths: TransBuf, cap_style: CapStyle, join_style: JoinStyle) -&gt; None:\n    \"\"\"Initialize the Paths visual.\n\n    Args:\n        positions (TransBuf): 3D positions for all path vertices.\n        path_sizes (TransBuf): Number of vertices in each path.\n        colors (TransBuf): RGBA colors for each path.\n        line_widths (TransBuf): Line widths for each path.\n        cap_style (CapStyle): Style for line endings (round, square, butt).\n        join_style (JoinStyle): Style for line joins (miter, bevel, round).\n    \"\"\"\n    super().__init__()\n\n    self._positions: TransBuf = positions\n    self._path_sizes: TransBuf = path_sizes\n    self._colors: TransBuf = colors\n    self._line_widths: TransBuf = line_widths\n    self._cap_style: CapStyle = cap_style\n    self._join_style: JoinStyle = join_style\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._positions, self._path_sizes, self._colors, self._line_widths, self._cap_style, self._join_style)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.get_cap_style","title":"<code>get_cap_style() -&gt; CapStyle</code>","text":"<p>Get the cap style.</p> <p>Returns:</p> Name Type Description <code>CapStyle</code> <code>gsp.types.cap_style.CapStyle</code> <p>Style for line endings (round, square, butt).</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def get_cap_style(self) -&gt; CapStyle:\n    \"\"\"Get the cap style.\n\n    Returns:\n        CapStyle: Style for line endings (round, square, butt).\n    \"\"\"\n    return self._cap_style\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.get_colors","title":"<code>get_colors() -&gt; TransBuf</code>","text":"<p>Get the colors buffer.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>RGBA colors for each path.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def get_colors(self) -&gt; TransBuf:\n    \"\"\"Get the colors buffer.\n\n    Returns:\n        TransBuf: RGBA colors for each path.\n    \"\"\"\n    return self._colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.get_join_style","title":"<code>get_join_style() -&gt; JoinStyle</code>","text":"<p>Get the join style.</p> <p>Returns:</p> Name Type Description <code>JoinStyle</code> <code>gsp.types.join_style.JoinStyle</code> <p>Style for line joins (miter, bevel, round).</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def get_join_style(self) -&gt; JoinStyle:\n    \"\"\"Get the join style.\n\n    Returns:\n        JoinStyle: Style for line joins (miter, bevel, round).\n    \"\"\"\n    return self._join_style\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.get_line_widths","title":"<code>get_line_widths() -&gt; TransBuf</code>","text":"<p>Get the line widths buffer.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>Line widths for each path.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def get_line_widths(self) -&gt; TransBuf:\n    \"\"\"Get the line widths buffer.\n\n    Returns:\n        TransBuf: Line widths for each path.\n    \"\"\"\n    return self._line_widths\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.get_path_sizes","title":"<code>get_path_sizes() -&gt; TransBuf</code>","text":"<p>Get the path sizes buffer.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>Number of vertices in each path.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def get_path_sizes(self) -&gt; TransBuf:\n    \"\"\"Get the path sizes buffer.\n\n    Returns:\n        TransBuf: Number of vertices in each path.\n    \"\"\"\n    return self._path_sizes\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.get_positions","title":"<code>get_positions() -&gt; TransBuf</code>","text":"<p>Get the positions buffer.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>3D positions for all path vertices.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def get_positions(self) -&gt; TransBuf:\n    \"\"\"Get the positions buffer.\n\n    Returns:\n        TransBuf: 3D positions for all path vertices.\n    \"\"\"\n    return self._positions\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.sanity_check_attributes","title":"<code>sanity_check_attributes(positions: TransBuf, path_sizes: TransBuf, colors: TransBuf, line_widths: TransBuf, cap_style: CapStyle, join_style: JoinStyle) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Validate attribute dimensions and compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>3D positions for all path vertices.</p> required <code>path_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Number of vertices in each path.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>RGBA colors for each path.</p> required <code>line_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Line widths for each path.</p> required <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>Style for line endings.</p> required <code>join_style</code> <code>gsp.types.join_style.JoinStyle</code> <p>Style for line joins.</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes(\n    positions: TransBuf,\n    path_sizes: TransBuf,\n    colors: TransBuf,\n    line_widths: TransBuf,\n    cap_style: CapStyle,\n    join_style: JoinStyle,\n) -&gt; None:\n    \"\"\"Validate attribute dimensions and compatibility.\n\n    Args:\n        positions (TransBuf): 3D positions for all path vertices.\n        path_sizes (TransBuf): Number of vertices in each path.\n        colors (TransBuf): RGBA colors for each path.\n        line_widths (TransBuf): Line widths for each path.\n        cap_style (CapStyle): Style for line endings.\n        join_style (JoinStyle): Style for line joins.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(positions: Buffer, path_sizes: Buffer, colors: Buffer, line_widths: Buffer, cap_style: CapStyle, join_style: JoinStyle) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Same as .sanity_check_attributes() but accept only Buffers.</p> <p>It is meant to be used after converting TransBuf to Buffer.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.buffer.Buffer</code> <p>3D positions for all path vertices.</p> required <code>path_sizes</code> <code>gsp.types.buffer.Buffer</code> <p>Number of vertices in each path.</p> required <code>colors</code> <code>gsp.types.buffer.Buffer</code> <p>RGBA colors for each path.</p> required <code>line_widths</code> <code>gsp.types.buffer.Buffer</code> <p>Line widths for each path.</p> required <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>Style for line endings.</p> required <code>join_style</code> <code>gsp.types.join_style.JoinStyle</code> <p>Style for line joins.</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(\n    positions: Buffer, path_sizes: Buffer, colors: Buffer, line_widths: Buffer, cap_style: CapStyle, join_style: JoinStyle\n) -&gt; None:\n    \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n    It is meant to be used after converting TransBuf to Buffer.\n\n    Args:\n        positions (Buffer): 3D positions for all path vertices.\n        path_sizes (Buffer): Number of vertices in each path.\n        colors (Buffer): RGBA colors for each path.\n        line_widths (Buffer): Line widths for each path.\n        cap_style (CapStyle): Style for line endings.\n        join_style (JoinStyle): Style for line joins.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(path_sizes, Buffer), \"Path sizes must be a Buffer\"\n    assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n    assert isinstance(line_widths, Buffer), \"Line widths must be a Buffer\"\n\n    Paths.sanity_check_attributes(positions, path_sizes, colors, line_widths, cap_style, join_style)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, path_sizes: TransBuf | None = None, colors: TransBuf | None = None, line_widths: TransBuf | None = None, cap_style: CapStyle | None = None, join_style: JoinStyle | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf | None</code> <p>3D positions for all path vertices.</p> <code>None</code> <code>path_sizes</code> <code>gsp.types.transbuf.TransBuf | None</code> <p>Number of vertices in each path.</p> <code>None</code> <code>colors</code> <code>gsp.types.transbuf.TransBuf | None</code> <p>RGBA colors for each path.</p> <code>None</code> <code>line_widths</code> <code>gsp.types.transbuf.TransBuf | None</code> <p>Line widths for each path.</p> <code>None</code> <code>cap_style</code> <code>gsp.types.cap_style.CapStyle | None</code> <p>Style for line endings (round, square, butt).</p> <code>None</code> <code>join_style</code> <code>gsp.types.join_style.JoinStyle | None</code> <p>Style for line joins (miter, bevel, round).</p> <code>None</code> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_attributes(\n    self,\n    positions: TransBuf | None = None,\n    path_sizes: TransBuf | None = None,\n    colors: TransBuf | None = None,\n    line_widths: TransBuf | None = None,\n    cap_style: CapStyle | None = None,\n    join_style: JoinStyle | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\n\n    Args:\n        positions (TransBuf | None, optional): 3D positions for all path vertices.\n        path_sizes (TransBuf | None, optional): Number of vertices in each path.\n        colors (TransBuf | None, optional): RGBA colors for each path.\n        line_widths (TransBuf | None, optional): Line widths for each path.\n        cap_style (CapStyle | None, optional): Style for line endings (round, square, butt).\n        join_style (JoinStyle | None, optional): Style for line joins (miter, bevel, round).\n    \"\"\"\n    if positions is not None:\n        self._positions = positions\n    if path_sizes is not None:\n        self._path_sizes = path_sizes\n    if colors is not None:\n        self._colors = colors\n    if line_widths is not None:\n        self._line_widths = line_widths\n    if cap_style is not None:\n        self._cap_style = cap_style\n    if join_style is not None:\n        self._join_style = join_style\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_cap_style","title":"<code>set_cap_style(cap_style: CapStyle) -&gt; None</code>","text":"<p>Set the cap style.</p> <p>Parameters:</p> Name Type Description Default <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>Style for line endings (round, square, butt).</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_cap_style(self, cap_style: CapStyle) -&gt; None:\n    \"\"\"Set the cap style.\n\n    Args:\n        cap_style (CapStyle): Style for line endings (round, square, butt).\n    \"\"\"\n    self._cap_style = cap_style\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_colors","title":"<code>set_colors(colors: TransBuf) -&gt; None</code>","text":"<p>Set the colors buffer.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>RGBA colors for each path.</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_colors(self, colors: TransBuf) -&gt; None:\n    \"\"\"Set the colors buffer.\n\n    Args:\n        colors (TransBuf): RGBA colors for each path.\n    \"\"\"\n    self._colors = colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_join_style","title":"<code>set_join_style(join_style: JoinStyle) -&gt; None</code>","text":"<p>Set the join style.</p> <p>Parameters:</p> Name Type Description Default <code>join_style</code> <code>gsp.types.join_style.JoinStyle</code> <p>Style for line joins (miter, bevel, round).</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_join_style(self, join_style: JoinStyle) -&gt; None:\n    \"\"\"Set the join style.\n\n    Args:\n        join_style (JoinStyle): Style for line joins (miter, bevel, round).\n    \"\"\"\n    self._join_style = join_style\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_line_widths","title":"<code>set_line_widths(line_widths: TransBuf) -&gt; None</code>","text":"<p>Set the line widths buffer.</p> <p>Parameters:</p> Name Type Description Default <code>line_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Line widths for each path.</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_line_widths(self, line_widths: TransBuf) -&gt; None:\n    \"\"\"Set the line widths buffer.\n\n    Args:\n        line_widths (TransBuf): Line widths for each path.\n    \"\"\"\n    self._line_widths = line_widths\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_path_sizes","title":"<code>set_path_sizes(path_sizes: TransBuf) -&gt; None</code>","text":"<p>Set the path sizes buffer.</p> <p>Parameters:</p> Name Type Description Default <code>path_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Number of vertices in each path.</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_path_sizes(self, path_sizes: TransBuf) -&gt; None:\n    \"\"\"Set the path sizes buffer.\n\n    Args:\n        path_sizes (TransBuf): Number of vertices in each path.\n    \"\"\"\n    self._path_sizes = path_sizes\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_positions","title":"<code>set_positions(positions: TransBuf) -&gt; None</code>","text":"<p>Set the positions buffer.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>3D positions for all path vertices.</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_positions(self, positions: TransBuf) -&gt; None:\n    \"\"\"Set the positions buffer.\n\n    Args:\n        positions (TransBuf): 3D positions for all path vertices.\n    \"\"\"\n    self._positions = positions\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels","title":"<code>gsp.visuals.pixels</code>","text":"<p>Pixels visual module.</p>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels","title":"<code>Pixels</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> <p>Pixels visual for rendering individual colored pixels.</p> <p>This visual represents a collection of pixels with configurable positions, colors, and groups for efficient rendering.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>class Pixels(VisualBase):\n    \"\"\"Pixels visual for rendering individual colored pixels.\n\n    This visual represents a collection of pixels with configurable positions,\n    colors, and groups for efficient rendering.\n    \"\"\"\n\n    __slots__ = [\"__positions\", \"__colors\", \"__groups\"]\n\n    def __init__(self, positions: TransBuf, colors: TransBuf, groups: Groups):\n        \"\"\"Initialize Pixels visual.\n\n        Args:\n            positions: Positions of the pixels.\n            colors: Colors of the pixels.\n            groups: Groups for organizing pixels.\n        \"\"\"\n        super().__init__()\n\n        self.__positions: TransBuf = positions\n        self.__colors: TransBuf = colors\n        self.__groups: Groups = groups\n\n        self.check_attributes()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return string representation of the Pixels visual.\"\"\"\n        return f\"Pixels(positions={self.__positions}, colors={self.__colors}, groups={self.__groups})\"\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        \"\"\"Get positions of the pixels.\"\"\"\n        return self.__positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        \"\"\"Set positions of the pixels.\n\n        Args:\n            positions: New positions for the pixels.\n        \"\"\"\n        self.__positions = positions\n        self.check_attributes()\n\n    def get_colors(self) -&gt; TransBuf:\n        \"\"\"Get colors of the pixels.\"\"\"\n        return self.__colors\n\n    def set_colors(self, colors: TransBuf) -&gt; None:\n        \"\"\"Set colors of the pixels.\n\n        Args:\n            colors: New colors for the pixels.\n        \"\"\"\n        self.__colors = colors\n        self.check_attributes()\n\n    def get_groups(self) -&gt; Groups:\n        \"\"\"Get groups for organizing pixels.\"\"\"\n        return self.__groups\n\n    def set_groups(self, groups: Groups) -&gt; None:\n        \"\"\"Set groups for organizing pixels.\n\n        Args:\n            groups: New groups for the pixels.\n        \"\"\"\n        self.__groups = groups\n        self.check_attributes()\n\n    def set_attributes(self, positions: TransBuf | None = None, colors: TransBuf | None = None, groups: Groups | None = None) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if positions is not None:\n            self.__positions = positions\n        if colors is not None:\n            self.__colors = colors\n        if groups is not None:\n            self.__groups = groups\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self.__positions, self.__colors, self.__groups)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(positions: Buffer, colors: Buffer, groups: Groups):\n        \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n\n        Pixels.sanity_check_attributes(positions, colors, groups)\n\n    @staticmethod\n    def sanity_check_attributes(positions: TransBuf, colors: TransBuf, groups: Groups):\n        \"\"\"Check that the attributes are valid and consistent.\n\n        Args:\n            positions: Positions of the pixels.\n            colors: Colors of the pixels.\n            groups: Groups for organizing pixels.\n        \"\"\"\n        # =============================================================================\n        # if any of the attributes is a TransformChain not fully defined, skip the sanity check\n        # =============================================================================\n\n        if isinstance(positions, TransformChain) and not positions.is_fully_defined():\n            return\n        if isinstance(colors, TransformChain) and not colors.is_fully_defined():\n            return\n\n        # =============================================================================\n        # Check groups\n        # =============================================================================\n\n        # get position_count and group_count\n        position_count = positions.get_count() if isinstance(positions, Buffer) else positions.get_buffer_count()\n        group_count = GroupUtils.get_group_count(position_count, groups)\n\n        # Check groups matches position count\n        GroupUtils.sanity_check(position_count, groups)\n\n        # =============================================================================\n        # Check each attributes\n        # =============================================================================\n\n        # Check colors attribute\n        color_count = colors.get_count() if isinstance(colors, Buffer) else colors.get_buffer_count()\n        assert color_count == group_count, f\"Colors count {color_count} must match group count {group_count}\"\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.__init__","title":"<code>__init__(positions: TransBuf, colors: TransBuf, groups: Groups)</code>","text":"<p>Initialize Pixels visual.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the pixels.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Colors of the pixels.</p> required <code>groups</code> <code>gsp.types.group.Groups</code> <p>Groups for organizing pixels.</p> required Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def __init__(self, positions: TransBuf, colors: TransBuf, groups: Groups):\n    \"\"\"Initialize Pixels visual.\n\n    Args:\n        positions: Positions of the pixels.\n        colors: Colors of the pixels.\n        groups: Groups for organizing pixels.\n    \"\"\"\n    super().__init__()\n\n    self.__positions: TransBuf = positions\n    self.__colors: TransBuf = colors\n    self.__groups: Groups = groups\n\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return string representation of the Pixels visual.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return string representation of the Pixels visual.\"\"\"\n    return f\"Pixels(positions={self.__positions}, colors={self.__colors}, groups={self.__groups})\"\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self.__positions, self.__colors, self.__groups)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.get_colors","title":"<code>get_colors() -&gt; TransBuf</code>","text":"<p>Get colors of the pixels.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def get_colors(self) -&gt; TransBuf:\n    \"\"\"Get colors of the pixels.\"\"\"\n    return self.__colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.get_groups","title":"<code>get_groups() -&gt; Groups</code>","text":"<p>Get groups for organizing pixels.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def get_groups(self) -&gt; Groups:\n    \"\"\"Get groups for organizing pixels.\"\"\"\n    return self.__groups\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.get_positions","title":"<code>get_positions() -&gt; TransBuf</code>","text":"<p>Get positions of the pixels.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def get_positions(self) -&gt; TransBuf:\n    \"\"\"Get positions of the pixels.\"\"\"\n    return self.__positions\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.sanity_check_attributes","title":"<code>sanity_check_attributes(positions: TransBuf, colors: TransBuf, groups: Groups)</code>  <code>staticmethod</code>","text":"<p>Check that the attributes are valid and consistent.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the pixels.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Colors of the pixels.</p> required <code>groups</code> <code>gsp.types.group.Groups</code> <p>Groups for organizing pixels.</p> required Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes(positions: TransBuf, colors: TransBuf, groups: Groups):\n    \"\"\"Check that the attributes are valid and consistent.\n\n    Args:\n        positions: Positions of the pixels.\n        colors: Colors of the pixels.\n        groups: Groups for organizing pixels.\n    \"\"\"\n    # =============================================================================\n    # if any of the attributes is a TransformChain not fully defined, skip the sanity check\n    # =============================================================================\n\n    if isinstance(positions, TransformChain) and not positions.is_fully_defined():\n        return\n    if isinstance(colors, TransformChain) and not colors.is_fully_defined():\n        return\n\n    # =============================================================================\n    # Check groups\n    # =============================================================================\n\n    # get position_count and group_count\n    position_count = positions.get_count() if isinstance(positions, Buffer) else positions.get_buffer_count()\n    group_count = GroupUtils.get_group_count(position_count, groups)\n\n    # Check groups matches position count\n    GroupUtils.sanity_check(position_count, groups)\n\n    # =============================================================================\n    # Check each attributes\n    # =============================================================================\n\n    # Check colors attribute\n    color_count = colors.get_count() if isinstance(colors, Buffer) else colors.get_buffer_count()\n    assert color_count == group_count, f\"Colors count {color_count} must match group count {group_count}\"\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(positions: Buffer, colors: Buffer, groups: Groups)</code>  <code>staticmethod</code>","text":"<p>Same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(positions: Buffer, colors: Buffer, groups: Groups):\n    \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n\n    Pixels.sanity_check_attributes(positions, colors, groups)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, colors: TransBuf | None = None, groups: Groups | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def set_attributes(self, positions: TransBuf | None = None, colors: TransBuf | None = None, groups: Groups | None = None) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if positions is not None:\n        self.__positions = positions\n    if colors is not None:\n        self.__colors = colors\n    if groups is not None:\n        self.__groups = groups\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.set_colors","title":"<code>set_colors(colors: TransBuf) -&gt; None</code>","text":"<p>Set colors of the pixels.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>New colors for the pixels.</p> required Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def set_colors(self, colors: TransBuf) -&gt; None:\n    \"\"\"Set colors of the pixels.\n\n    Args:\n        colors: New colors for the pixels.\n    \"\"\"\n    self.__colors = colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.set_groups","title":"<code>set_groups(groups: Groups) -&gt; None</code>","text":"<p>Set groups for organizing pixels.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>gsp.types.group.Groups</code> <p>New groups for the pixels.</p> required Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def set_groups(self, groups: Groups) -&gt; None:\n    \"\"\"Set groups for organizing pixels.\n\n    Args:\n        groups: New groups for the pixels.\n    \"\"\"\n    self.__groups = groups\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.set_positions","title":"<code>set_positions(positions: TransBuf) -&gt; None</code>","text":"<p>Set positions of the pixels.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>New positions for the pixels.</p> required Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def set_positions(self, positions: TransBuf) -&gt; None:\n    \"\"\"Set positions of the pixels.\n\n    Args:\n        positions: New positions for the pixels.\n    \"\"\"\n    self.__positions = positions\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts","title":"<code>gsp.visuals.texts</code>","text":"<p>Texts visual module.</p>"},{"location":"api/gsp/#gsp.visuals.texts.Texts","title":"<code>Texts</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> <p>Texts visual.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>class Texts(VisualBase):\n    \"\"\"Texts visual.\"\"\"\n\n    __slots__ = [\"_positions\", \"_strings\", \"_colors\", \"_font_sizes\", \"_anchors\", \"_angles\", \"_font_name\"]\n\n    def __init__(\n        self,\n        positions: TransBuf,\n        strings: list[str],\n        colors: TransBuf,\n        font_sizes: TransBuf,\n        anchors: TransBuf,\n        angles: TransBuf,\n        font_name: str,\n    ) -&gt; None:\n        \"\"\"Initialize Texts visual.\n\n        Args:\n            positions (TransBuf): Positions of the texts.\n            strings (list[str]): List of text strings.\n            colors (TransBuf): Colors of the texts.\n            font_sizes (TransBuf): Font sizes of the texts.\n            anchors (TransBuf): Anchor positions of the texts.\n            angles (TransBuf): Rotation angles of the texts.\n            font_name (str): Font name for the texts.\n        \"\"\"\n        super().__init__()\n\n        self._positions: TransBuf = positions\n        self._strings: list[str] = strings\n        self._colors: TransBuf = colors\n        self._font_sizes: TransBuf = font_sizes\n        self._anchors: TransBuf = anchors\n        self._angles: TransBuf = angles\n        self._font_name: str = font_name\n        self.check_attributes()\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        \"\"\"Get positions of the texts.\"\"\"\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        \"\"\"Set positions of the texts.\n\n        Args:\n            positions: New positions for the texts.\n        \"\"\"\n        self._positions = positions\n        self.check_attributes()\n\n    def get_strings(self) -&gt; list[str]:\n        \"\"\"Get text strings.\"\"\"\n        return self._strings\n\n    def set_strings(self, strings: list[str]) -&gt; None:\n        \"\"\"Set text strings.\n\n        Args:\n            strings: New text strings.\n        \"\"\"\n        self._strings = strings\n        self.check_attributes()\n\n    def get_colors(self) -&gt; TransBuf:\n        \"\"\"Get colors of the texts.\"\"\"\n        return self._colors\n\n    def set_colors(self, colors: TransBuf) -&gt; None:\n        \"\"\"Set colors of the texts.\n\n        Args:\n            colors: New colors for the texts.\n        \"\"\"\n        self._colors = colors\n        self.check_attributes()\n\n    def get_font_sizes(self) -&gt; TransBuf:\n        \"\"\"Get font sizes of the texts.\"\"\"\n        return self._font_sizes\n\n    def set_font_sizes(self, font_sizes: TransBuf) -&gt; None:\n        \"\"\"Set font sizes of the texts.\n\n        Args:\n            font_sizes: New font sizes for the texts.\n        \"\"\"\n        self._font_sizes = font_sizes\n        self.check_attributes()\n\n    def get_anchors(self) -&gt; TransBuf:\n        \"\"\"Get anchor positions of the texts.\"\"\"\n        return self._anchors\n\n    def set_anchors(self, anchors: TransBuf) -&gt; None:\n        \"\"\"Set anchor positions of the texts.\n\n        Args:\n            anchors: New anchor positions for the texts.\n        \"\"\"\n        self._anchors = anchors\n        self.check_attributes()\n\n    def get_angles(self) -&gt; TransBuf:\n        \"\"\"Get rotation angles of the texts.\"\"\"\n        return self._angles\n\n    def set_angles(self, angles: TransBuf) -&gt; None:\n        \"\"\"Set rotation angles of the texts.\n\n        Args:\n            angles: New rotation angles for the texts.\n        \"\"\"\n        self._angles = angles\n        self.check_attributes()\n\n    def get_font_name(self) -&gt; str:\n        \"\"\"Get font name used for the texts.\"\"\"\n        return self._font_name\n\n    def set_font_name(self, font_name: str) -&gt; None:\n        \"\"\"Set font name for the texts.\n\n        Args:\n            font_name: New font name for the texts.\n        \"\"\"\n        self._font_name = font_name\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        positions: TransBuf | None = None,\n        strings: list[str] | None = None,\n        colors: TransBuf | None = None,\n        font_sizes: TransBuf | None = None,\n        anchors: TransBuf | None = None,\n        angles: TransBuf | None = None,\n        font_name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if positions is not None:\n            self._positions = positions\n        if strings is not None:\n            self._strings = strings\n        if colors is not None:\n            self._colors = colors\n        if font_sizes is not None:\n            self._font_sizes = font_sizes\n        if anchors is not None:\n            self._anchors = anchors\n        if angles is not None:\n            self._angles = angles\n        if font_name is not None:\n            self._font_name = font_name\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._positions, self._strings, self._colors, self._font_sizes, self._anchors, self._angles, self._font_name)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(\n        positions: Buffer, strings: list[str], colors: Buffer, font_sizes: Buffer, anchors: Buffer, angles: Buffer, font_name: str\n    ) -&gt; None:\n        \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(strings, list), \"Texts must be a list of strings\"\n        assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n        assert isinstance(font_sizes, Buffer), \"Font sizes must be a Buffer\"\n        assert isinstance(anchors, Buffer), \"Anchors must be a Buffer\"\n        assert isinstance(angles, Buffer), \"Angles must be a Buffer\"\n        assert isinstance(font_name, str), \"Font name must be a string\"\n\n        # check positions, colors, font_sizes, anchors, angles have the same length as strings\n        assert positions.get_count() == len(\n            strings\n        ), f\"Positions length must match number of strings. Got {positions.get_count()} positions vs {len(strings)} strings\"\n        assert colors.get_count() == len(strings), f\"Colors length must match number of strings. Got {colors.get_count()} colors vs {len(strings)} strings\"\n        assert font_sizes.get_count() == len(\n            strings\n        ), f\"Font sizes length must match number of strings. Got {font_sizes.get_count()} font sizes vs {len(strings)} strings\"\n        assert anchors.get_count() == len(strings), f\"Anchors length must match number of strings. Got {anchors.get_count()} anchors vs {len(strings)} strings\"\n        assert angles.get_count() == len(strings), f\"Angles length must match number of strings. Got {angles.get_count()} angles vs {len(strings)} strings\"\n\n        # check font_name is not empty and is a string\n        assert len(font_name) &gt; 0, \"Font name must be a non-empty string\"\n        assert isinstance(font_name, str), \"Font name must be a string\"\n\n        # check all strings are indeed strings\n        for string in strings:\n            assert isinstance(string, str), \"All elements in strings must be of type str\"\n\n    @staticmethod\n    def sanity_check_attributes(\n        positions: TransBuf,\n        strings: list[str],\n        colors: TransBuf,\n        font_sizes: TransBuf,\n        anchors: TransBuf,\n        angles: TransBuf,\n        font_name: str,\n    ) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\n\n        Args:\n            positions: Positions of the texts.\n            strings: List of text strings.\n            colors: Colors of the texts.\n            font_sizes: Font sizes of the texts.\n            anchors: Anchor positions of the texts.\n            angles: Rotation angles of the texts.\n            font_name: Font name for the texts.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.__init__","title":"<code>__init__(positions: TransBuf, strings: list[str], colors: TransBuf, font_sizes: TransBuf, anchors: TransBuf, angles: TransBuf, font_name: str) -&gt; None</code>","text":"<p>Initialize Texts visual.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the texts.</p> required <code>strings</code> <code>list[str]</code> <p>List of text strings.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Colors of the texts.</p> required <code>font_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Font sizes of the texts.</p> required <code>anchors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Anchor positions of the texts.</p> required <code>angles</code> <code>gsp.types.transbuf.TransBuf</code> <p>Rotation angles of the texts.</p> required <code>font_name</code> <code>str</code> <p>Font name for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def __init__(\n    self,\n    positions: TransBuf,\n    strings: list[str],\n    colors: TransBuf,\n    font_sizes: TransBuf,\n    anchors: TransBuf,\n    angles: TransBuf,\n    font_name: str,\n) -&gt; None:\n    \"\"\"Initialize Texts visual.\n\n    Args:\n        positions (TransBuf): Positions of the texts.\n        strings (list[str]): List of text strings.\n        colors (TransBuf): Colors of the texts.\n        font_sizes (TransBuf): Font sizes of the texts.\n        anchors (TransBuf): Anchor positions of the texts.\n        angles (TransBuf): Rotation angles of the texts.\n        font_name (str): Font name for the texts.\n    \"\"\"\n    super().__init__()\n\n    self._positions: TransBuf = positions\n    self._strings: list[str] = strings\n    self._colors: TransBuf = colors\n    self._font_sizes: TransBuf = font_sizes\n    self._anchors: TransBuf = anchors\n    self._angles: TransBuf = angles\n    self._font_name: str = font_name\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._positions, self._strings, self._colors, self._font_sizes, self._anchors, self._angles, self._font_name)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_anchors","title":"<code>get_anchors() -&gt; TransBuf</code>","text":"<p>Get anchor positions of the texts.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_anchors(self) -&gt; TransBuf:\n    \"\"\"Get anchor positions of the texts.\"\"\"\n    return self._anchors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_angles","title":"<code>get_angles() -&gt; TransBuf</code>","text":"<p>Get rotation angles of the texts.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_angles(self) -&gt; TransBuf:\n    \"\"\"Get rotation angles of the texts.\"\"\"\n    return self._angles\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_colors","title":"<code>get_colors() -&gt; TransBuf</code>","text":"<p>Get colors of the texts.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_colors(self) -&gt; TransBuf:\n    \"\"\"Get colors of the texts.\"\"\"\n    return self._colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_font_name","title":"<code>get_font_name() -&gt; str</code>","text":"<p>Get font name used for the texts.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_font_name(self) -&gt; str:\n    \"\"\"Get font name used for the texts.\"\"\"\n    return self._font_name\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_font_sizes","title":"<code>get_font_sizes() -&gt; TransBuf</code>","text":"<p>Get font sizes of the texts.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_font_sizes(self) -&gt; TransBuf:\n    \"\"\"Get font sizes of the texts.\"\"\"\n    return self._font_sizes\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_positions","title":"<code>get_positions() -&gt; TransBuf</code>","text":"<p>Get positions of the texts.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_positions(self) -&gt; TransBuf:\n    \"\"\"Get positions of the texts.\"\"\"\n    return self._positions\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_strings","title":"<code>get_strings() -&gt; list[str]</code>","text":"<p>Get text strings.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_strings(self) -&gt; list[str]:\n    \"\"\"Get text strings.\"\"\"\n    return self._strings\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.sanity_check_attributes","title":"<code>sanity_check_attributes(positions: TransBuf, strings: list[str], colors: TransBuf, font_sizes: TransBuf, anchors: TransBuf, angles: TransBuf, font_name: str) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Check that the attributes are valid and consistent.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the texts.</p> required <code>strings</code> <code>list[str]</code> <p>List of text strings.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Colors of the texts.</p> required <code>font_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Font sizes of the texts.</p> required <code>anchors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Anchor positions of the texts.</p> required <code>angles</code> <code>gsp.types.transbuf.TransBuf</code> <p>Rotation angles of the texts.</p> required <code>font_name</code> <code>str</code> <p>Font name for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes(\n    positions: TransBuf,\n    strings: list[str],\n    colors: TransBuf,\n    font_sizes: TransBuf,\n    anchors: TransBuf,\n    angles: TransBuf,\n    font_name: str,\n) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\n\n    Args:\n        positions: Positions of the texts.\n        strings: List of text strings.\n        colors: Colors of the texts.\n        font_sizes: Font sizes of the texts.\n        anchors: Anchor positions of the texts.\n        angles: Rotation angles of the texts.\n        font_name: Font name for the texts.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(positions: Buffer, strings: list[str], colors: Buffer, font_sizes: Buffer, anchors: Buffer, angles: Buffer, font_name: str) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(\n    positions: Buffer, strings: list[str], colors: Buffer, font_sizes: Buffer, anchors: Buffer, angles: Buffer, font_name: str\n) -&gt; None:\n    \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(strings, list), \"Texts must be a list of strings\"\n    assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n    assert isinstance(font_sizes, Buffer), \"Font sizes must be a Buffer\"\n    assert isinstance(anchors, Buffer), \"Anchors must be a Buffer\"\n    assert isinstance(angles, Buffer), \"Angles must be a Buffer\"\n    assert isinstance(font_name, str), \"Font name must be a string\"\n\n    # check positions, colors, font_sizes, anchors, angles have the same length as strings\n    assert positions.get_count() == len(\n        strings\n    ), f\"Positions length must match number of strings. Got {positions.get_count()} positions vs {len(strings)} strings\"\n    assert colors.get_count() == len(strings), f\"Colors length must match number of strings. Got {colors.get_count()} colors vs {len(strings)} strings\"\n    assert font_sizes.get_count() == len(\n        strings\n    ), f\"Font sizes length must match number of strings. Got {font_sizes.get_count()} font sizes vs {len(strings)} strings\"\n    assert anchors.get_count() == len(strings), f\"Anchors length must match number of strings. Got {anchors.get_count()} anchors vs {len(strings)} strings\"\n    assert angles.get_count() == len(strings), f\"Angles length must match number of strings. Got {angles.get_count()} angles vs {len(strings)} strings\"\n\n    # check font_name is not empty and is a string\n    assert len(font_name) &gt; 0, \"Font name must be a non-empty string\"\n    assert isinstance(font_name, str), \"Font name must be a string\"\n\n    # check all strings are indeed strings\n    for string in strings:\n        assert isinstance(string, str), \"All elements in strings must be of type str\"\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_anchors","title":"<code>set_anchors(anchors: TransBuf) -&gt; None</code>","text":"<p>Set anchor positions of the texts.</p> <p>Parameters:</p> Name Type Description Default <code>anchors</code> <code>gsp.types.transbuf.TransBuf</code> <p>New anchor positions for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_anchors(self, anchors: TransBuf) -&gt; None:\n    \"\"\"Set anchor positions of the texts.\n\n    Args:\n        anchors: New anchor positions for the texts.\n    \"\"\"\n    self._anchors = anchors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_angles","title":"<code>set_angles(angles: TransBuf) -&gt; None</code>","text":"<p>Set rotation angles of the texts.</p> <p>Parameters:</p> Name Type Description Default <code>angles</code> <code>gsp.types.transbuf.TransBuf</code> <p>New rotation angles for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_angles(self, angles: TransBuf) -&gt; None:\n    \"\"\"Set rotation angles of the texts.\n\n    Args:\n        angles: New rotation angles for the texts.\n    \"\"\"\n    self._angles = angles\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, strings: list[str] | None = None, colors: TransBuf | None = None, font_sizes: TransBuf | None = None, anchors: TransBuf | None = None, angles: TransBuf | None = None, font_name: str | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_attributes(\n    self,\n    positions: TransBuf | None = None,\n    strings: list[str] | None = None,\n    colors: TransBuf | None = None,\n    font_sizes: TransBuf | None = None,\n    anchors: TransBuf | None = None,\n    angles: TransBuf | None = None,\n    font_name: str | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if positions is not None:\n        self._positions = positions\n    if strings is not None:\n        self._strings = strings\n    if colors is not None:\n        self._colors = colors\n    if font_sizes is not None:\n        self._font_sizes = font_sizes\n    if anchors is not None:\n        self._anchors = anchors\n    if angles is not None:\n        self._angles = angles\n    if font_name is not None:\n        self._font_name = font_name\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_colors","title":"<code>set_colors(colors: TransBuf) -&gt; None</code>","text":"<p>Set colors of the texts.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>New colors for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_colors(self, colors: TransBuf) -&gt; None:\n    \"\"\"Set colors of the texts.\n\n    Args:\n        colors: New colors for the texts.\n    \"\"\"\n    self._colors = colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_font_name","title":"<code>set_font_name(font_name: str) -&gt; None</code>","text":"<p>Set font name for the texts.</p> <p>Parameters:</p> Name Type Description Default <code>font_name</code> <code>str</code> <p>New font name for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_font_name(self, font_name: str) -&gt; None:\n    \"\"\"Set font name for the texts.\n\n    Args:\n        font_name: New font name for the texts.\n    \"\"\"\n    self._font_name = font_name\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_font_sizes","title":"<code>set_font_sizes(font_sizes: TransBuf) -&gt; None</code>","text":"<p>Set font sizes of the texts.</p> <p>Parameters:</p> Name Type Description Default <code>font_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>New font sizes for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_font_sizes(self, font_sizes: TransBuf) -&gt; None:\n    \"\"\"Set font sizes of the texts.\n\n    Args:\n        font_sizes: New font sizes for the texts.\n    \"\"\"\n    self._font_sizes = font_sizes\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_positions","title":"<code>set_positions(positions: TransBuf) -&gt; None</code>","text":"<p>Set positions of the texts.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>New positions for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_positions(self, positions: TransBuf) -&gt; None:\n    \"\"\"Set positions of the texts.\n\n    Args:\n        positions: New positions for the texts.\n    \"\"\"\n    self._positions = positions\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_strings","title":"<code>set_strings(strings: list[str]) -&gt; None</code>","text":"<p>Set text strings.</p> <p>Parameters:</p> Name Type Description Default <code>strings</code> <code>list[str]</code> <p>New text strings.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_strings(self, strings: list[str]) -&gt; None:\n    \"\"\"Set text strings.\n\n    Args:\n        strings: New text strings.\n    \"\"\"\n    self._strings = strings\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#transforms-module","title":"Transforms Module","text":""},{"location":"api/gsp/#gsp.transforms","title":"<code>gsp.transforms</code>","text":"<p>GSP Transforms Package.</p>"},{"location":"api/gsp/#gsp.transforms.transform_chain","title":"<code>gsp.transforms.transform_chain</code>","text":"<p>Transform chain module for composing transformations.</p> <p>This module provides the TransformChain class which allows chaining multiple transform links to process data through a series of transformations.</p>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain","title":"<code>TransformChain</code>","text":"<p>Chain of transformations to apply to data.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>class TransformChain:\n    \"\"\"Chain of transformations to apply to data.\"\"\"\n\n    __slots__ = [\"__links\", \"__buffer_count\", \"__buffer_type\"]\n\n    def __init__(self, buffer_count: int, buffer_type: BufferType | None) -&gt; None:\n        \"\"\"Initialize a TransformChain.\n\n        Args:\n            buffer_count (int): Number of elements in the output Buffer. -1 if not defined yet.\n            buffer_type (BufferType | None): Type of the output Buffer. None if not defined yet.\n        \"\"\"\n        self.__links: list[TransformLinkBase] = []\n        \"\"\"Ordered list of links defining the transform.\"\"\"\n\n        # sanity check\n        if buffer_count &lt; 0:\n            assert buffer_count == -1, \"TransformChain: buffer_count must be -1 (undefined) or &gt;= 0\"\n\n        self.__buffer_count = buffer_count\n        \"\"\"Number of elements in the output Buffer. -1 if not defined yet.\"\"\"\n\n        self.__buffer_type = buffer_type\n        \"\"\"Type of the output Buffer. None if not defined yet.\"\"\"\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    def is_fully_defined(self) -&gt; bool:\n        \"\"\"Check if the TransformChain is fully defined.\n\n        A TransformChain is fully defined when both buffer_type is not None\n        and buffer_count is &gt;= 0.\n\n        Returns:\n            bool: True if fully defined, False otherwise.\n        \"\"\"\n        if self.__buffer_type is None:\n            return False\n        if self.__buffer_count &lt; 0:\n            return False\n        return True\n\n    def get_buffer_count(self) -&gt; int:\n        \"\"\"Get the number of elements in the output Buffer.\n\n        Note:\n            This method should only be called if is_fully_defined() returns True.\n\n        Returns:\n            int: The number of elements in the output Buffer.\n\n        Raises:\n            AssertionError: If buffer_type is None or buffer_count is negative.\n        \"\"\"\n        # sanity check - buffer_count MUST be defined\n        assert self.__buffer_type is not None, \"TransformChain.get_buffer_count: buffer_type is None. use .is_fully_defined() to check.\"\n        assert self.__buffer_count &gt;= 0, \"TransformChain.get_buffer_count: buffer_count is negative. use .is_fully_defined() to check.\"\n\n        # return the buffer count\n        return self.__buffer_count\n\n    def get_buffer_type(self) -&gt; BufferType:\n        \"\"\"Get the type of the output Buffer.\n\n        Note:\n            This method should only be called if is_fully_defined() returns True.\n\n        Returns:\n            BufferType: The type of the output Buffer.\n\n        Raises:\n            AssertionError: If buffer_type is None or buffer_count is negative.\n        \"\"\"\n        # sanity check - buffer_type MUST be defined\n        assert self.__buffer_type is not None, \"TransformChain.get_buffer_type: buffer_type is None. use .is_fully_defined() to check.\"\n        assert self.__buffer_count &gt;= 0, \"TransformChain.get_buffer_count: buffer_count is negative. use .is_fully_defined() to check.\"\n\n        # return the buffer type\n        return self.__buffer_type\n\n    # =============================================================================\n    # .add/.remove/.clear the links\n    # =============================================================================\n\n    def add(self, link: TransformLinkBase) -&gt; None:\n        \"\"\"Add a TransformLink to the chain.\n\n        Args:\n            link: The TransformLink to add to the chain.\n        \"\"\"\n        self.__links.append(link)\n\n    def remove(self, link: TransformLinkBase) -&gt; None:\n        \"\"\"Remove a TransformLink from the chain.\n\n        Args:\n            link: The TransformLink to remove from the chain.\n\n        Raises:\n            ValueError: If the link is not found in the chain.\n        \"\"\"\n        self.__links.remove(link)\n\n    # =============================================================================\n    # .run()\n    # =============================================================================\n\n    def run(self) -&gt; Buffer:\n        \"\"\"Compute the transform and return a Buffer with the result.\n\n        Applies each link in the chain sequentially, passing the output of\n        each link to the next link in the chain.\n\n        Returns:\n            Buffer: The final transformed buffer.\n\n        Raises:\n            AssertionError: If no buffer is produced by the transform chain.\n        \"\"\"\n        # Create a new Buffer to hold the transformed data\n        buffer = None\n\n        # Apply each link in the chain\n        for link in self.__links:\n            buffer = link.apply(buffer)\n\n        # Sanity check the output buffer\n        assert buffer is not None, \"TransformChain.to_buffer: No buffer produced by the transform chain.\"\n\n        # Return the final buffer\n        return buffer\n\n    # =============================================================================\n    # Serialisation\n    # =============================================================================\n\n    def serialize(self) -&gt; dict[str, Any]:\n        \"\"\"Serialize the TransformChain to a dictionary.\n\n        Returns:\n            dict[str, Any]: The serialized TransformChain containing buffer_count,\n                buffer_type, and links.\n        \"\"\"\n        links_data = [link.serialize() for link in self.__links]\n        chain_serialized = {\n            \"buffer_count\": self.__buffer_count,\n            \"buffer_type\": self.__buffer_type.name if self.__buffer_type is not None else None,\n            \"links\": links_data,\n        }\n        return chain_serialized\n\n    @staticmethod\n    def deserialize(data: dict[str, Any]) -&gt; \"TransformChain\":\n        \"\"\"Deserialize a TransformChain from a dictionary.\n\n        Args:\n            data (dict[str, Any]): The serialized TransformChain.\n\n        Returns:\n            TransformChain: The deserialized TransformChain instance.\n        \"\"\"\n        buffer_count = int(data[\"buffer_count\"])\n        buffer_type_str: str | None = data[\"buffer_type\"]\n        buffer_type = BufferType[buffer_type_str] if buffer_type_str is not None else None\n\n        transform_chain = TransformChain(buffer_count, buffer_type)\n\n        links_data: list[dict[str, Any]] = data[\"links\"]\n        for link_data in links_data:\n            link_type: str = link_data[\"link_type\"]\n            link_class: type[TransformLinkBase] = TransformRegistry.get_link_class(link_type)\n            link_instance = link_class.deserialize(link_data)\n            transform_chain.add(link_instance)\n\n        return transform_chain\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.__buffer_count","title":"<code>__buffer_count = buffer_count</code>  <code>instance-attribute</code>","text":"<p>Number of elements in the output Buffer. -1 if not defined yet.</p>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.__buffer_type","title":"<code>__buffer_type = buffer_type</code>  <code>instance-attribute</code>","text":"<p>Type of the output Buffer. None if not defined yet.</p>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.__links","title":"<code>__links: list[TransformLinkBase] = []</code>  <code>instance-attribute</code>","text":"<p>Ordered list of links defining the transform.</p>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.__init__","title":"<code>__init__(buffer_count: int, buffer_type: BufferType | None) -&gt; None</code>","text":"<p>Initialize a TransformChain.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_count</code> <code>int</code> <p>Number of elements in the output Buffer. -1 if not defined yet.</p> required <code>buffer_type</code> <code>gsp.types.BufferType | None</code> <p>Type of the output Buffer. None if not defined yet.</p> required Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def __init__(self, buffer_count: int, buffer_type: BufferType | None) -&gt; None:\n    \"\"\"Initialize a TransformChain.\n\n    Args:\n        buffer_count (int): Number of elements in the output Buffer. -1 if not defined yet.\n        buffer_type (BufferType | None): Type of the output Buffer. None if not defined yet.\n    \"\"\"\n    self.__links: list[TransformLinkBase] = []\n    \"\"\"Ordered list of links defining the transform.\"\"\"\n\n    # sanity check\n    if buffer_count &lt; 0:\n        assert buffer_count == -1, \"TransformChain: buffer_count must be -1 (undefined) or &gt;= 0\"\n\n    self.__buffer_count = buffer_count\n    \"\"\"Number of elements in the output Buffer. -1 if not defined yet.\"\"\"\n\n    self.__buffer_type = buffer_type\n    \"\"\"Type of the output Buffer. None if not defined yet.\"\"\"\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.add","title":"<code>add(link: TransformLinkBase) -&gt; None</code>","text":"<p>Add a TransformLink to the chain.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>gsp.transforms.transform_link_base.TransformLinkBase</code> <p>The TransformLink to add to the chain.</p> required Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def add(self, link: TransformLinkBase) -&gt; None:\n    \"\"\"Add a TransformLink to the chain.\n\n    Args:\n        link: The TransformLink to add to the chain.\n    \"\"\"\n    self.__links.append(link)\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.deserialize","title":"<code>deserialize(data: dict[str, Any]) -&gt; TransformChain</code>  <code>staticmethod</code>","text":"<p>Deserialize a TransformChain from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, typing.Any]</code> <p>The serialized TransformChain.</p> required <p>Returns:</p> Name Type Description <code>TransformChain</code> <code>gsp.transforms.transform_chain.TransformChain</code> <p>The deserialized TransformChain instance.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>@staticmethod\ndef deserialize(data: dict[str, Any]) -&gt; \"TransformChain\":\n    \"\"\"Deserialize a TransformChain from a dictionary.\n\n    Args:\n        data (dict[str, Any]): The serialized TransformChain.\n\n    Returns:\n        TransformChain: The deserialized TransformChain instance.\n    \"\"\"\n    buffer_count = int(data[\"buffer_count\"])\n    buffer_type_str: str | None = data[\"buffer_type\"]\n    buffer_type = BufferType[buffer_type_str] if buffer_type_str is not None else None\n\n    transform_chain = TransformChain(buffer_count, buffer_type)\n\n    links_data: list[dict[str, Any]] = data[\"links\"]\n    for link_data in links_data:\n        link_type: str = link_data[\"link_type\"]\n        link_class: type[TransformLinkBase] = TransformRegistry.get_link_class(link_type)\n        link_instance = link_class.deserialize(link_data)\n        transform_chain.add(link_instance)\n\n    return transform_chain\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.get_buffer_count","title":"<code>get_buffer_count() -&gt; int</code>","text":"<p>Get the number of elements in the output Buffer.</p> Note <p>This method should only be called if is_fully_defined() returns True.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the output Buffer.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If buffer_type is None or buffer_count is negative.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def get_buffer_count(self) -&gt; int:\n    \"\"\"Get the number of elements in the output Buffer.\n\n    Note:\n        This method should only be called if is_fully_defined() returns True.\n\n    Returns:\n        int: The number of elements in the output Buffer.\n\n    Raises:\n        AssertionError: If buffer_type is None or buffer_count is negative.\n    \"\"\"\n    # sanity check - buffer_count MUST be defined\n    assert self.__buffer_type is not None, \"TransformChain.get_buffer_count: buffer_type is None. use .is_fully_defined() to check.\"\n    assert self.__buffer_count &gt;= 0, \"TransformChain.get_buffer_count: buffer_count is negative. use .is_fully_defined() to check.\"\n\n    # return the buffer count\n    return self.__buffer_count\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.get_buffer_type","title":"<code>get_buffer_type() -&gt; BufferType</code>","text":"<p>Get the type of the output Buffer.</p> Note <p>This method should only be called if is_fully_defined() returns True.</p> <p>Returns:</p> Name Type Description <code>BufferType</code> <code>gsp.types.BufferType</code> <p>The type of the output Buffer.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If buffer_type is None or buffer_count is negative.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def get_buffer_type(self) -&gt; BufferType:\n    \"\"\"Get the type of the output Buffer.\n\n    Note:\n        This method should only be called if is_fully_defined() returns True.\n\n    Returns:\n        BufferType: The type of the output Buffer.\n\n    Raises:\n        AssertionError: If buffer_type is None or buffer_count is negative.\n    \"\"\"\n    # sanity check - buffer_type MUST be defined\n    assert self.__buffer_type is not None, \"TransformChain.get_buffer_type: buffer_type is None. use .is_fully_defined() to check.\"\n    assert self.__buffer_count &gt;= 0, \"TransformChain.get_buffer_count: buffer_count is negative. use .is_fully_defined() to check.\"\n\n    # return the buffer type\n    return self.__buffer_type\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.is_fully_defined","title":"<code>is_fully_defined() -&gt; bool</code>","text":"<p>Check if the TransformChain is fully defined.</p> <p>A TransformChain is fully defined when both buffer_type is not None and buffer_count is &gt;= 0.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if fully defined, False otherwise.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def is_fully_defined(self) -&gt; bool:\n    \"\"\"Check if the TransformChain is fully defined.\n\n    A TransformChain is fully defined when both buffer_type is not None\n    and buffer_count is &gt;= 0.\n\n    Returns:\n        bool: True if fully defined, False otherwise.\n    \"\"\"\n    if self.__buffer_type is None:\n        return False\n    if self.__buffer_count &lt; 0:\n        return False\n    return True\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.remove","title":"<code>remove(link: TransformLinkBase) -&gt; None</code>","text":"<p>Remove a TransformLink from the chain.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>gsp.transforms.transform_link_base.TransformLinkBase</code> <p>The TransformLink to remove from the chain.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the link is not found in the chain.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def remove(self, link: TransformLinkBase) -&gt; None:\n    \"\"\"Remove a TransformLink from the chain.\n\n    Args:\n        link: The TransformLink to remove from the chain.\n\n    Raises:\n        ValueError: If the link is not found in the chain.\n    \"\"\"\n    self.__links.remove(link)\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.run","title":"<code>run() -&gt; Buffer</code>","text":"<p>Compute the transform and return a Buffer with the result.</p> <p>Applies each link in the chain sequentially, passing the output of each link to the next link in the chain.</p> <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.Buffer</code> <p>The final transformed buffer.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If no buffer is produced by the transform chain.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def run(self) -&gt; Buffer:\n    \"\"\"Compute the transform and return a Buffer with the result.\n\n    Applies each link in the chain sequentially, passing the output of\n    each link to the next link in the chain.\n\n    Returns:\n        Buffer: The final transformed buffer.\n\n    Raises:\n        AssertionError: If no buffer is produced by the transform chain.\n    \"\"\"\n    # Create a new Buffer to hold the transformed data\n    buffer = None\n\n    # Apply each link in the chain\n    for link in self.__links:\n        buffer = link.apply(buffer)\n\n    # Sanity check the output buffer\n    assert buffer is not None, \"TransformChain.to_buffer: No buffer produced by the transform chain.\"\n\n    # Return the final buffer\n    return buffer\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.serialize","title":"<code>serialize() -&gt; dict[str, Any]</code>","text":"<p>Serialize the TransformChain to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>dict[str, Any]: The serialized TransformChain containing buffer_count, buffer_type, and links.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n    \"\"\"Serialize the TransformChain to a dictionary.\n\n    Returns:\n        dict[str, Any]: The serialized TransformChain containing buffer_count,\n            buffer_type, and links.\n    \"\"\"\n    links_data = [link.serialize() for link in self.__links]\n    chain_serialized = {\n        \"buffer_count\": self.__buffer_count,\n        \"buffer_type\": self.__buffer_type.name if self.__buffer_type is not None else None,\n        \"links\": links_data,\n    }\n    return chain_serialized\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_link_base","title":"<code>gsp.transforms.transform_link_base</code>","text":"<p>Transform Link Base Module.</p>"},{"location":"api/gsp/#gsp.transforms.transform_link_base.TransformLinkBase","title":"<code>TransformLinkBase</code>","text":"<p>               Bases: <code>abc.ABC</code></p> <p>Base class for a link in a Transform chain.</p> Source code in <code>src/gsp/transforms/transform_link_base.py</code> <pre><code>class TransformLinkBase(ABC):\n    \"\"\"Base class for a link in a Transform chain.\"\"\"\n\n    @abstractmethod\n    def apply(self, buffer_src: Buffer | None) -&gt; Buffer:\n        \"\"\"Apply the transformation to the given buffer and return a new buffer.\n\n        Args:\n            buffer_src (Buffer | None): The source buffer to transform. Can be None.\n\n        Returns:\n            Buffer: The transformed buffer.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def serialize(self) -&gt; dict[str, Any]:\n        \"\"\"Serialize the TransformLink to a dictionary.\n\n        Returns:\n            dict[str, Any]: The serialized TransformLink.\n        \"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def deserialize(data: dict[str, Any]) -&gt; \"TransformLinkBase\":\n        \"\"\"Deserialize a TransformLink from a dictionary.\n\n        Args:\n            data (dict[str, Any]): The serialized TransformLink.\n\n        Returns:\n            TransformLinkBase: The deserialized TransformLink instance.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_link_base.TransformLinkBase.apply","title":"<code>apply(buffer_src: Buffer | None) -&gt; Buffer</code>  <code>abstractmethod</code>","text":"<p>Apply the transformation to the given buffer and return a new buffer.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_src</code> <code>gsp.types.Buffer | None</code> <p>The source buffer to transform. Can be None.</p> required <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.Buffer</code> <p>The transformed buffer.</p> Source code in <code>src/gsp/transforms/transform_link_base.py</code> <pre><code>@abstractmethod\ndef apply(self, buffer_src: Buffer | None) -&gt; Buffer:\n    \"\"\"Apply the transformation to the given buffer and return a new buffer.\n\n    Args:\n        buffer_src (Buffer | None): The source buffer to transform. Can be None.\n\n    Returns:\n        Buffer: The transformed buffer.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_link_base.TransformLinkBase.deserialize","title":"<code>deserialize(data: dict[str, Any]) -&gt; TransformLinkBase</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Deserialize a TransformLink from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, typing.Any]</code> <p>The serialized TransformLink.</p> required <p>Returns:</p> Name Type Description <code>TransformLinkBase</code> <code>gsp.transforms.transform_link_base.TransformLinkBase</code> <p>The deserialized TransformLink instance.</p> Source code in <code>src/gsp/transforms/transform_link_base.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef deserialize(data: dict[str, Any]) -&gt; \"TransformLinkBase\":\n    \"\"\"Deserialize a TransformLink from a dictionary.\n\n    Args:\n        data (dict[str, Any]): The serialized TransformLink.\n\n    Returns:\n        TransformLinkBase: The deserialized TransformLink instance.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_link_base.TransformLinkBase.serialize","title":"<code>serialize() -&gt; dict[str, Any]</code>  <code>abstractmethod</code>","text":"<p>Serialize the TransformLink to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>dict[str, Any]: The serialized TransformLink.</p> Source code in <code>src/gsp/transforms/transform_link_base.py</code> <pre><code>@abstractmethod\ndef serialize(self) -&gt; dict[str, Any]:\n    \"\"\"Serialize the TransformLink to a dictionary.\n\n    Returns:\n        dict[str, Any]: The serialized TransformLink.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#utilities-module","title":"Utilities Module","text":""},{"location":"api/gsp/#gsp.utils","title":"<code>gsp.utils</code>","text":"<p>Utility modules for GSP.</p>"},{"location":"api/gsp/#gsp.utils.cmap_utils","title":"<code>gsp.utils.cmap_utils</code>","text":"<p>Colormap utilities for mapping values to colors using matplotlib colormaps.</p>"},{"location":"api/gsp/#gsp.utils.cmap_utils.CmapUtils","title":"<code>CmapUtils</code>","text":"<p>Utility class for colormap operations. Leverage matplotlib colormaps.</p> Source code in <code>src/gsp/utils/cmap_utils.py</code> <pre><code>class CmapUtils:\n    \"\"\"Utility class for colormap operations. Leverage [matplotlib colormaps](https://matplotlib.org/stable/tutorials/colors/colormaps.html).\"\"\"\n\n    @staticmethod\n    def has_color_map(colormap_name: str) -&gt; bool:\n        \"\"\"Check if the given colormap name is recognized by matplotlib.\n\n        Args:\n            colormap_name (str): Name of the colormap to check.\n\n        Returns:\n            bool: True if the colormap exists, False otherwise.\n        \"\"\"\n        try:\n            matplotlib.cm.get_cmap(colormap_name)\n            return True\n        except ValueError:\n            return False\n\n    @staticmethod\n    def get_color_map(colormap_name: str, values: np.ndarray, vmin: float | None = None, vmax: float | None = None) -&gt; Buffer:\n        \"\"\"Get colors from a colormap for the given values.\n\n        Args:\n            colormap_name (str): Name of the colormap (e.g., 'plasma', 'viridis', etc.).\n            values (np.ndarray): Array of input values to map to colors.\n            vmin (float|None): Minimum value for values normalization. if None, use min of values.\n            vmax (float|None): Maximum value for values normalization. if None, use max of values.\n\n        Returns:\n            Buffer: A Buffer containing the RGBA8 colors mapped from the input values.\n        \"\"\"\n        # Handle default parameters\n        vmin = vmin if vmin is not None else values.min()\n        vmax = vmax if vmax is not None else values.max()\n\n        # sanity check\n        assert CmapUtils.has_color_map(colormap_name), f\"Colormap '{colormap_name}' is not recognized.\"\n\n        mpl_color_map = matplotlib.cm.get_cmap(colormap_name)\n\n        # sanity check\n        assert vmin is not None, \"vmin should not be None\"\n        assert vmax is not None, \"vmax should not be None\"\n\n        normalized_values = (values - vmin) / (vmax - vmin)\n        normalized_values = np.clip(normalized_values, 0.0, 1.0)\n        color_mapped_normalized = mpl_color_map(normalized_values)  # normalized values to [0, 1]\n        color_mapped_255 = (color_mapped_normalized * 255).astype(np.uint8)\n\n        # Create a Buffer\n        color_buffer = Buffer(color_mapped_255.__len__(), buffer_type=BufferType.rgba8)\n        color_buffer.set_data(bytearray(color_mapped_255.tobytes()), 0, color_mapped_255.__len__())\n\n        # Return the color buffer\n        return color_buffer\n</code></pre>"},{"location":"api/gsp/#gsp.utils.cmap_utils.CmapUtils.get_color_map","title":"<code>get_color_map(colormap_name: str, values: np.ndarray, vmin: float | None = None, vmax: float | None = None) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Get colors from a colormap for the given values.</p> <p>Parameters:</p> Name Type Description Default <code>colormap_name</code> <code>str</code> <p>Name of the colormap (e.g., 'plasma', 'viridis', etc.).</p> required <code>values</code> <code>numpy.ndarray</code> <p>Array of input values to map to colors.</p> required <code>vmin</code> <code>float | None</code> <p>Minimum value for values normalization. if None, use min of values.</p> <code>None</code> <code>vmax</code> <code>float | None</code> <p>Maximum value for values normalization. if None, use max of values.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.Buffer</code> <p>A Buffer containing the RGBA8 colors mapped from the input values.</p> Source code in <code>src/gsp/utils/cmap_utils.py</code> <pre><code>@staticmethod\ndef get_color_map(colormap_name: str, values: np.ndarray, vmin: float | None = None, vmax: float | None = None) -&gt; Buffer:\n    \"\"\"Get colors from a colormap for the given values.\n\n    Args:\n        colormap_name (str): Name of the colormap (e.g., 'plasma', 'viridis', etc.).\n        values (np.ndarray): Array of input values to map to colors.\n        vmin (float|None): Minimum value for values normalization. if None, use min of values.\n        vmax (float|None): Maximum value for values normalization. if None, use max of values.\n\n    Returns:\n        Buffer: A Buffer containing the RGBA8 colors mapped from the input values.\n    \"\"\"\n    # Handle default parameters\n    vmin = vmin if vmin is not None else values.min()\n    vmax = vmax if vmax is not None else values.max()\n\n    # sanity check\n    assert CmapUtils.has_color_map(colormap_name), f\"Colormap '{colormap_name}' is not recognized.\"\n\n    mpl_color_map = matplotlib.cm.get_cmap(colormap_name)\n\n    # sanity check\n    assert vmin is not None, \"vmin should not be None\"\n    assert vmax is not None, \"vmax should not be None\"\n\n    normalized_values = (values - vmin) / (vmax - vmin)\n    normalized_values = np.clip(normalized_values, 0.0, 1.0)\n    color_mapped_normalized = mpl_color_map(normalized_values)  # normalized values to [0, 1]\n    color_mapped_255 = (color_mapped_normalized * 255).astype(np.uint8)\n\n    # Create a Buffer\n    color_buffer = Buffer(color_mapped_255.__len__(), buffer_type=BufferType.rgba8)\n    color_buffer.set_data(bytearray(color_mapped_255.tobytes()), 0, color_mapped_255.__len__())\n\n    # Return the color buffer\n    return color_buffer\n</code></pre>"},{"location":"api/gsp/#gsp.utils.cmap_utils.CmapUtils.has_color_map","title":"<code>has_color_map(colormap_name: str) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Check if the given colormap name is recognized by matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>colormap_name</code> <code>str</code> <p>Name of the colormap to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the colormap exists, False otherwise.</p> Source code in <code>src/gsp/utils/cmap_utils.py</code> <pre><code>@staticmethod\ndef has_color_map(colormap_name: str) -&gt; bool:\n    \"\"\"Check if the given colormap name is recognized by matplotlib.\n\n    Args:\n        colormap_name (str): Name of the colormap to check.\n\n    Returns:\n        bool: True if the colormap exists, False otherwise.\n    \"\"\"\n    try:\n        matplotlib.cm.get_cmap(colormap_name)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils","title":"<code>gsp.utils.group_utils</code>","text":"<p>Utility functions for handling and manipulating group objects.</p> <p>This module provides utilities for working with Groups, which can be represented in multiple formats: int, list[int], or list[list[int]].</p>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils","title":"<code>GroupUtils</code>","text":"<p>Utility class for group operations and validation.</p> <p>This class provides static methods for: - Validating group objects - Computing group counts and indices - Converting between different group formats</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>class GroupUtils:\n    \"\"\"Utility class for group operations and validation.\n\n    This class provides static methods for:\n    - Validating group objects\n    - Computing group counts and indices\n    - Converting between different group formats\n    \"\"\"\n\n    @staticmethod\n    def get_group_count(vertex_count: int, groups: Groups) -&gt; int:\n        \"\"\"Return the number of groups from the groups object.\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (Groups): groups object\n\n        Returns:\n            int: number of groups\n\n        Raises:\n            NotImplementedError: if the groups object type is not supported\n        \"\"\"\n        groups_format = GroupUtils._groups_format(groups)\n        if groups_format == GroupUtils.FORMAT_INT:\n            groups_typed = typing.cast(int, groups)\n            group_count = vertex_count // groups_typed\n        elif groups_format == GroupUtils.FORMAT_LIST_INT:\n            groups_typed = typing.cast(list[int], groups)\n            group_count = len(groups_typed)\n        elif groups_format == GroupUtils.FORMAT_LIST_LIST_INT:\n            groups_typed = typing.cast(list[list[int]], groups)\n            group_count = len(groups_typed)\n        else:\n            raise NotImplementedError(f\"Group buffer shape not supported: {type(groups)}\")\n\n        return group_count\n\n    # =============================================================================\n    # is_instance_of_groups\n    # =============================================================================\n\n    @staticmethod\n    def is_instance_of_groups(groups: Groups) -&gt; bool:\n        \"\"\"Check if the type of groups is valid.\n\n        Deep check where all elements are checked.\n        Does not check the values themselves, only the types.\n\n        Groups can be:\n        - int\n        - list[int]\n        - list[list[int]]\n\n        Args:\n            groups (Groups): groups object\n\n        Returns:\n            bool: True if groups is a valid Groups object, False otherwise.\n        \"\"\"\n        if isinstance(groups, int):\n            return True\n        elif isinstance(groups, list) and all(isinstance(int_value, int) for int_value in groups):\n            return True\n        elif isinstance(groups, list) and all(isinstance(group, list) for group in groups) and all(isinstance(int_value, int) for int_list in groups for int_value in int_list):  # type: ignore[union-attr]\n            return True\n        else:\n            return False\n\n    # =============================================================================\n    # ._groups_format()\n    # =============================================================================\n\n    FORMAT_INT = \"format_int\"\n    FORMAT_LIST_INT = \"format_list_int\"\n    FORMAT_LIST_LIST_INT = \"format_list_list_int\"\n\n    @staticmethod\n    def _groups_format(groups: Groups) -&gt; Literal[\"format_int\", \"format_list_int\", \"format_list_list_int\"]:\n        \"\"\"Return the format of the groups object as a string.\n\n        No check is done.\n\n        Args:\n            groups (Groups): groups object\n\n        Returns:\n            Literal[\"format_int\", \"format_list_int\", \"format_list_list_int\"]: \"format_int\", \"format_list_int\", \"format_list_list_int\"\n\n        Raises:\n            ValueError: if the groups object is not valid\n        \"\"\"\n        if isinstance(groups, int):\n            return GroupUtils.FORMAT_INT\n        elif isinstance(groups, list) and groups.__len__() &gt; 0 and isinstance(groups[0], int):\n            return GroupUtils.FORMAT_LIST_INT\n        elif isinstance(groups, list) and groups.__len__() &gt; 0 and isinstance(groups[0], list) and groups[0].__len__() &gt; 0 and isinstance(groups[0][0], int):\n            return GroupUtils.FORMAT_LIST_LIST_INT\n        else:\n            raise ValueError(f\"Groups object is not valid: {type(groups)}\")\n\n    # =============================================================================\n    # Sanity Checks\n    # =============================================================================\n\n    @staticmethod\n    def sanity_check(vertex_count: int, groups: Groups) -&gt; None:\n        \"\"\"Perform sanity checks on the groups object, raising exceptions if not valid.\n\n        Raise:\n            ValueError: if the groups object is not valid.\n        \"\"\"\n        if not GroupUtils.is_instance_of_groups(groups):\n            raise ValueError(f\"Groups object is not valid: {type(groups)}\")\n\n        groups_mode = GroupUtils._groups_format(groups)\n\n        if groups_mode == GroupUtils.FORMAT_INT:\n            groups_int = typing.cast(int, groups)\n            if groups_int &lt;= 0:\n                raise ValueError(f\"Groups as int must be positive, got {groups_int}\")\n            if groups_int &gt; vertex_count:\n                raise ValueError(f\"Groups as int must be less than or equal to vertex_count, got groups={groups_int}, vertex_count={vertex_count}\")\n            if vertex_count % groups_int != 0:\n                raise ValueError(f\"Groups as int must divide vertex_count, got vertex_count={vertex_count}, groups={groups_int}\")\n        elif groups_mode == GroupUtils.FORMAT_LIST_INT:\n            groups_list_int = typing.cast(list[int], groups)\n            if any(group_size &lt;= 0 for group_size in groups_list_int):\n                raise ValueError(f\"Groups as list[int], group sizes must be all positive, got {groups_list_int}\")\n            if sum(groups_list_int) != vertex_count:\n                raise ValueError(\n                    f\"Sum of groups size as list[int] must equal vertex_count, got sum(groups)={sum(groups_list_int)}, vertex_count={vertex_count}\"\n                )\n        elif groups_mode == GroupUtils.FORMAT_LIST_LIST_INT:\n            groups_list_list_int = typing.cast(list[list[int]], groups)\n            all_indices = [index for group in groups_list_list_int for index in group]\n            if any(index &lt; 0 or index &gt;= vertex_count for index in all_indices):\n                raise ValueError(f\"Groups as list[list[int]], all indices must be in range [0, {vertex_count-1}], got indices={all_indices}\")\n            if len(set(all_indices)) != len(all_indices):\n                raise ValueError(f\"Groups as list[list[int]], all indices must be unique, got indices={all_indices}\")\n\n        # TODO check that the list matches the vertex count where needed\n        # TODO check that no list is empty\n\n    @staticmethod\n    def sanity_check_safe(vertex_count: int, groups: Groups) -&gt; bool:\n        \"\"\"Perform sanity checks on the groups object.\n\n        Same as .sanity_check_groups() but does not raise exceptions if not valid.\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (Groups): groups object\n\n        Returns:\n            bool: True if the groups object is valid, False otherwise.\n        \"\"\"\n        try:\n            GroupUtils.sanity_check(vertex_count, groups)\n            return True\n        except ValueError:\n            return False\n\n    # =============================================================================\n    # .compute_indices_per_group\n    # =============================================================================\n\n    @staticmethod\n    def compute_indices_per_group(vertex_count: int, groups: Groups) -&gt; list[list[int]]:\n        \"\"\"Compute indices_per_group for groups depending on the type of groups.\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (Groups): groups object\n\n        Returns:\n            list[list[int]]: list of vertex indices per group\n\n        Raises:\n            NotImplementedError: if the groups object type is not supported\n        \"\"\"\n        # sanity check\n        assert GroupUtils.sanity_check_safe(vertex_count, groups), \"groups failed sanity check\"\n\n        groups_format = GroupUtils._groups_format(groups)\n        if groups_format == GroupUtils.FORMAT_INT:\n            groups_typed = typing.cast(int, groups)\n            indices_per_group = GroupUtils._compute_indices_per_group_int(vertex_count, groups_typed)\n        elif groups_format == GroupUtils.FORMAT_LIST_INT:\n            groups_typed = typing.cast(list[int], groups)\n            indices_per_group = GroupUtils._compute_indices_per_group_list_int(vertex_count, groups_typed)\n        elif groups_format == GroupUtils.FORMAT_LIST_LIST_INT:\n            groups_typed = typing.cast(list[list[int]], groups)\n            indices_per_group = GroupUtils._compute_indices_per_group_list_list_int(vertex_count, groups_typed)\n        else:\n            raise NotImplementedError(f\"Group buffer shape not supported: {type(groups)}\")\n\n        return indices_per_group\n\n    # =============================================================================\n    # ._compute_indices_per_group_*() for each format\n    # =============================================================================\n\n    @staticmethod\n    def _compute_indices_per_group_int(vertex_count: int, groups: int) -&gt; list[list[int]]:\n        \"\"\"Compute indices_per_group for groups as int.\n\n        The int represents the size of each group.\n\n        group_count = vertex_count // groups\n        indices_per_group = list[list[int]]\n\n        Examples:\n        - vertex_count = 6, groups = 2 - divisible - all groups are vertex_count // groups long\n          - indices_per_group = [[0, 1], [2, 3], [4, 5]]\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (int): size of each group\n\n        Returns:\n            list[list[int]]: list of vertex indices per group\n        \"\"\"\n        # Initialize output variables\n        group_count: int = vertex_count // groups\n        indices_per_group: list[list[int]] = []\n\n        # Create the indices per group for this case\n        element_count_per_group = groups\n\n        for group_index in range(group_count):\n            start_index = element_count_per_group * group_index\n            end_index = element_count_per_group * (group_index + 1)\n\n            # Fill the indices for this group\n            indices_per_group.append(list(range(start_index, end_index)))\n\n        return indices_per_group\n\n    @staticmethod\n    def _compute_indices_per_group_list_int(vertex_count: int, groups: list[int]) -&gt; list[list[int]]:\n        \"\"\"Compute indices_per_group for groups as list[int].\n\n        In this case, each int represents the size of each group.\n\n        group_count = len(groups)\n        indices_per_group = list[list[int]]\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (list[int]): list of group sizes\n\n        Returns:\n            list[list[int]]: list of vertex indices per group\n        \"\"\"\n        # Initialize output variables\n        indices_per_group: list[list[int]] = []\n\n        # Create the indices per group for this case\n        current_index = 0\n        for group_size in groups:\n            # Fill the indices for this group\n            group_indices = list(range(current_index, current_index + group_size))\n            indices_per_group.append(group_indices)\n\n            # Update the current index\n            current_index += group_size\n\n        return indices_per_group\n\n    @staticmethod\n    def _compute_indices_per_group_list_list_int(vertex_count: int, groups: list[list[int]]) -&gt; list[list[int]]:\n        \"\"\"Compute indices_per_group for groups as list[list[int]].\n\n        In this case, the groups are directly the indices per group themselves.\n\n        group_count = len(groups)\n        indices_per_group = list[list[int]]\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (list[list[int]]): list of vertex indices per group\n\n        Returns:\n            list[list[int]]: list of vertex indices per group\n        \"\"\"\n        # Initialize output variables\n        indices_per_group: list[list[int]] = groups\n\n        return indices_per_group\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.compute_indices_per_group","title":"<code>compute_indices_per_group(vertex_count: int, groups: Groups) -&gt; list[list[int]]</code>  <code>staticmethod</code>","text":"<p>Compute indices_per_group for groups depending on the type of groups.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_count</code> <code>int</code> <p>number of vertices</p> required <code>groups</code> <code>gsp.types.group.Groups</code> <p>groups object</p> required <p>Returns:</p> Type Description <code>list[list[int]]</code> <p>list[list[int]]: list of vertex indices per group</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if the groups object type is not supported</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef compute_indices_per_group(vertex_count: int, groups: Groups) -&gt; list[list[int]]:\n    \"\"\"Compute indices_per_group for groups depending on the type of groups.\n\n    Args:\n        vertex_count (int): number of vertices\n        groups (Groups): groups object\n\n    Returns:\n        list[list[int]]: list of vertex indices per group\n\n    Raises:\n        NotImplementedError: if the groups object type is not supported\n    \"\"\"\n    # sanity check\n    assert GroupUtils.sanity_check_safe(vertex_count, groups), \"groups failed sanity check\"\n\n    groups_format = GroupUtils._groups_format(groups)\n    if groups_format == GroupUtils.FORMAT_INT:\n        groups_typed = typing.cast(int, groups)\n        indices_per_group = GroupUtils._compute_indices_per_group_int(vertex_count, groups_typed)\n    elif groups_format == GroupUtils.FORMAT_LIST_INT:\n        groups_typed = typing.cast(list[int], groups)\n        indices_per_group = GroupUtils._compute_indices_per_group_list_int(vertex_count, groups_typed)\n    elif groups_format == GroupUtils.FORMAT_LIST_LIST_INT:\n        groups_typed = typing.cast(list[list[int]], groups)\n        indices_per_group = GroupUtils._compute_indices_per_group_list_list_int(vertex_count, groups_typed)\n    else:\n        raise NotImplementedError(f\"Group buffer shape not supported: {type(groups)}\")\n\n    return indices_per_group\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.get_group_count","title":"<code>get_group_count(vertex_count: int, groups: Groups) -&gt; int</code>  <code>staticmethod</code>","text":"<p>Return the number of groups from the groups object.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_count</code> <code>int</code> <p>number of vertices</p> required <code>groups</code> <code>gsp.types.group.Groups</code> <p>groups object</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of groups</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if the groups object type is not supported</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef get_group_count(vertex_count: int, groups: Groups) -&gt; int:\n    \"\"\"Return the number of groups from the groups object.\n\n    Args:\n        vertex_count (int): number of vertices\n        groups (Groups): groups object\n\n    Returns:\n        int: number of groups\n\n    Raises:\n        NotImplementedError: if the groups object type is not supported\n    \"\"\"\n    groups_format = GroupUtils._groups_format(groups)\n    if groups_format == GroupUtils.FORMAT_INT:\n        groups_typed = typing.cast(int, groups)\n        group_count = vertex_count // groups_typed\n    elif groups_format == GroupUtils.FORMAT_LIST_INT:\n        groups_typed = typing.cast(list[int], groups)\n        group_count = len(groups_typed)\n    elif groups_format == GroupUtils.FORMAT_LIST_LIST_INT:\n        groups_typed = typing.cast(list[list[int]], groups)\n        group_count = len(groups_typed)\n    else:\n        raise NotImplementedError(f\"Group buffer shape not supported: {type(groups)}\")\n\n    return group_count\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.is_instance_of_groups","title":"<code>is_instance_of_groups(groups: Groups) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Check if the type of groups is valid.</p> <p>Deep check where all elements are checked. Does not check the values themselves, only the types.</p> <p>Groups can be: - int - list[int] - list[list[int]]</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>gsp.types.group.Groups</code> <p>groups object</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if groups is a valid Groups object, False otherwise.</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef is_instance_of_groups(groups: Groups) -&gt; bool:\n    \"\"\"Check if the type of groups is valid.\n\n    Deep check where all elements are checked.\n    Does not check the values themselves, only the types.\n\n    Groups can be:\n    - int\n    - list[int]\n    - list[list[int]]\n\n    Args:\n        groups (Groups): groups object\n\n    Returns:\n        bool: True if groups is a valid Groups object, False otherwise.\n    \"\"\"\n    if isinstance(groups, int):\n        return True\n    elif isinstance(groups, list) and all(isinstance(int_value, int) for int_value in groups):\n        return True\n    elif isinstance(groups, list) and all(isinstance(group, list) for group in groups) and all(isinstance(int_value, int) for int_list in groups for int_value in int_list):  # type: ignore[union-attr]\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.sanity_check","title":"<code>sanity_check(vertex_count: int, groups: Groups) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Perform sanity checks on the groups object, raising exceptions if not valid.</p> Raise <p>ValueError: if the groups object is not valid.</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef sanity_check(vertex_count: int, groups: Groups) -&gt; None:\n    \"\"\"Perform sanity checks on the groups object, raising exceptions if not valid.\n\n    Raise:\n        ValueError: if the groups object is not valid.\n    \"\"\"\n    if not GroupUtils.is_instance_of_groups(groups):\n        raise ValueError(f\"Groups object is not valid: {type(groups)}\")\n\n    groups_mode = GroupUtils._groups_format(groups)\n\n    if groups_mode == GroupUtils.FORMAT_INT:\n        groups_int = typing.cast(int, groups)\n        if groups_int &lt;= 0:\n            raise ValueError(f\"Groups as int must be positive, got {groups_int}\")\n        if groups_int &gt; vertex_count:\n            raise ValueError(f\"Groups as int must be less than or equal to vertex_count, got groups={groups_int}, vertex_count={vertex_count}\")\n        if vertex_count % groups_int != 0:\n            raise ValueError(f\"Groups as int must divide vertex_count, got vertex_count={vertex_count}, groups={groups_int}\")\n    elif groups_mode == GroupUtils.FORMAT_LIST_INT:\n        groups_list_int = typing.cast(list[int], groups)\n        if any(group_size &lt;= 0 for group_size in groups_list_int):\n            raise ValueError(f\"Groups as list[int], group sizes must be all positive, got {groups_list_int}\")\n        if sum(groups_list_int) != vertex_count:\n            raise ValueError(\n                f\"Sum of groups size as list[int] must equal vertex_count, got sum(groups)={sum(groups_list_int)}, vertex_count={vertex_count}\"\n            )\n    elif groups_mode == GroupUtils.FORMAT_LIST_LIST_INT:\n        groups_list_list_int = typing.cast(list[list[int]], groups)\n        all_indices = [index for group in groups_list_list_int for index in group]\n        if any(index &lt; 0 or index &gt;= vertex_count for index in all_indices):\n            raise ValueError(f\"Groups as list[list[int]], all indices must be in range [0, {vertex_count-1}], got indices={all_indices}\")\n        if len(set(all_indices)) != len(all_indices):\n            raise ValueError(f\"Groups as list[list[int]], all indices must be unique, got indices={all_indices}\")\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.sanity_check_safe","title":"<code>sanity_check_safe(vertex_count: int, groups: Groups) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Perform sanity checks on the groups object.</p> <p>Same as .sanity_check_groups() but does not raise exceptions if not valid.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_count</code> <code>int</code> <p>number of vertices</p> required <code>groups</code> <code>gsp.types.group.Groups</code> <p>groups object</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the groups object is valid, False otherwise.</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef sanity_check_safe(vertex_count: int, groups: Groups) -&gt; bool:\n    \"\"\"Perform sanity checks on the groups object.\n\n    Same as .sanity_check_groups() but does not raise exceptions if not valid.\n\n    Args:\n        vertex_count (int): number of vertices\n        groups (Groups): groups object\n\n    Returns:\n        bool: True if the groups object is valid, False otherwise.\n    \"\"\"\n    try:\n        GroupUtils.sanity_check(vertex_count, groups)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/gsp/#gsp.utils.math_utils","title":"<code>gsp.utils.math_utils</code>","text":"<p>Mathematical utility functions for GSP.</p> <p>This module provides mathematical operations and transformations used throughout the GSP library, including: - Model-View-Projection (MVP) transformations for 3D graphics</p>"},{"location":"api/gsp/#gsp.utils.math_utils.MathUtils","title":"<code>MathUtils</code>","text":"<p>Utility class for mathematical operations in GSP.</p> <p>This class provides static methods for common mathematical operations used in graphics programming, such as matrix transformations.</p> Source code in <code>src/gsp/utils/math_utils.py</code> <pre><code>class MathUtils:\n    \"\"\"Utility class for mathematical operations in GSP.\n\n    This class provides static methods for common mathematical operations\n    used in graphics programming, such as matrix transformations.\n    \"\"\"\n\n    @staticmethod\n    def apply_mvp_to_vertices_transform(vertices: np.ndarray, model_matrix: np.ndarray, view_matrix: np.ndarray, projection_matrix: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Applies Model-View-Projection transformation to the vertices.\n\n        Args:\n            vertices (np.ndarray): Input vertices of shape (N, 3).\n            model_matrix (np.ndarray): Model matrix of shape (4, 4).\n            view_matrix (np.ndarray): View matrix of shape (4, 4).\n            projection_matrix (np.ndarray): Projection matrix of shape (4, 4).\n\n        Returns:\n            np.ndarray: MVP transformed vertices of shape (N, 4).\n        \"\"\"\n        # sanity checks\n        assert vertices.ndim == 2 and vertices.shape[1] == 3, f\"Expected vertices shape (N, 3), got {vertices.shape}\"\n        assert model_matrix.shape == (4, 4), f\"Expected model_matrix shape (4, 4), got {model_matrix.shape}\"\n        assert view_matrix.shape == (4, 4), f\"Expected view_matrix shape (4, 4), got {view_matrix.shape}\"\n        assert projection_matrix.shape == (4, 4), f\"Expected projection_matrix shape (4, 4), got {projection_matrix.shape}\"\n\n        # Compute the Model-View-Projection (MVP) matrix\n        mvp_matrix = projection_matrix @ view_matrix @ model_matrix\n\n        # convert vertices to homogeneous coordinates (x, y, z) -&gt; (x, y, z, w=1.0)\n        ws_column = np.ones((vertices.shape[0], 1), dtype=np.float32)\n        vertices_homogeneous = np.hstack((vertices, ws_column))  # shape (N, 4) for N vertices\n\n        # Apply the MVP transformation to the vertices\n        vertices_mvp_transformed = (mvp_matrix @ vertices_homogeneous.T).T  # shape (N, 4)\n\n        # return the transformed vertices\n        return vertices_mvp_transformed\n\n    @staticmethod\n    def apply_mvp_to_vertices(vertices: np.ndarray, model_matrix: np.ndarray, view_matrix: np.ndarray, projection_matrix: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Applies Model-View-Projection transformation to the vertices.\n\n        Args:\n            vertices (np.ndarray): Input vertices of shape (N, 3).\n            model_matrix (np.ndarray): Model matrix of shape (4, 4).\n            view_matrix (np.ndarray): View matrix of shape (4, 4).\n            projection_matrix (np.ndarray): Projection matrix of shape (4, 4).\n\n        Returns:\n            np.ndarray: Transformed vertices of shape (N, 3).\n        \"\"\"\n        # Apply the MVP transformation to the vertices\n        vertices_mvp_transformed = MathUtils.apply_mvp_to_vertices_transform(vertices, model_matrix, view_matrix, projection_matrix)\n\n        # Perform perspective division to get normalized device coordinates (NDC)\n        vertices_homo_transformed = vertices_mvp_transformed / vertices_mvp_transformed[:, 3:4]  # divide by w - shape (N, 4)\n        vertices_3d_transformed = vertices_homo_transformed[:, :3]  # drop w-coordinate - shape (N, 3)\n\n        # NOTE: no need to map NDC to screen coordinates as canvas is drawn directly in NDC coordinates 2d\n        pass\n\n        # return the transformed vertices\n        return vertices_3d_transformed\n</code></pre>"},{"location":"api/gsp/#gsp.utils.math_utils.MathUtils.apply_mvp_to_vertices","title":"<code>apply_mvp_to_vertices(vertices: np.ndarray, model_matrix: np.ndarray, view_matrix: np.ndarray, projection_matrix: np.ndarray) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Applies Model-View-Projection transformation to the vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>numpy.ndarray</code> <p>Input vertices of shape (N, 3).</p> required <code>model_matrix</code> <code>numpy.ndarray</code> <p>Model matrix of shape (4, 4).</p> required <code>view_matrix</code> <code>numpy.ndarray</code> <p>View matrix of shape (4, 4).</p> required <code>projection_matrix</code> <code>numpy.ndarray</code> <p>Projection matrix of shape (4, 4).</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Transformed vertices of shape (N, 3).</p> Source code in <code>src/gsp/utils/math_utils.py</code> <pre><code>@staticmethod\ndef apply_mvp_to_vertices(vertices: np.ndarray, model_matrix: np.ndarray, view_matrix: np.ndarray, projection_matrix: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Applies Model-View-Projection transformation to the vertices.\n\n    Args:\n        vertices (np.ndarray): Input vertices of shape (N, 3).\n        model_matrix (np.ndarray): Model matrix of shape (4, 4).\n        view_matrix (np.ndarray): View matrix of shape (4, 4).\n        projection_matrix (np.ndarray): Projection matrix of shape (4, 4).\n\n    Returns:\n        np.ndarray: Transformed vertices of shape (N, 3).\n    \"\"\"\n    # Apply the MVP transformation to the vertices\n    vertices_mvp_transformed = MathUtils.apply_mvp_to_vertices_transform(vertices, model_matrix, view_matrix, projection_matrix)\n\n    # Perform perspective division to get normalized device coordinates (NDC)\n    vertices_homo_transformed = vertices_mvp_transformed / vertices_mvp_transformed[:, 3:4]  # divide by w - shape (N, 4)\n    vertices_3d_transformed = vertices_homo_transformed[:, :3]  # drop w-coordinate - shape (N, 3)\n\n    # NOTE: no need to map NDC to screen coordinates as canvas is drawn directly in NDC coordinates 2d\n    pass\n\n    # return the transformed vertices\n    return vertices_3d_transformed\n</code></pre>"},{"location":"api/gsp/#gsp.utils.math_utils.MathUtils.apply_mvp_to_vertices_transform","title":"<code>apply_mvp_to_vertices_transform(vertices: np.ndarray, model_matrix: np.ndarray, view_matrix: np.ndarray, projection_matrix: np.ndarray) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Applies Model-View-Projection transformation to the vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>numpy.ndarray</code> <p>Input vertices of shape (N, 3).</p> required <code>model_matrix</code> <code>numpy.ndarray</code> <p>Model matrix of shape (4, 4).</p> required <code>view_matrix</code> <code>numpy.ndarray</code> <p>View matrix of shape (4, 4).</p> required <code>projection_matrix</code> <code>numpy.ndarray</code> <p>Projection matrix of shape (4, 4).</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: MVP transformed vertices of shape (N, 4).</p> Source code in <code>src/gsp/utils/math_utils.py</code> <pre><code>@staticmethod\ndef apply_mvp_to_vertices_transform(vertices: np.ndarray, model_matrix: np.ndarray, view_matrix: np.ndarray, projection_matrix: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Applies Model-View-Projection transformation to the vertices.\n\n    Args:\n        vertices (np.ndarray): Input vertices of shape (N, 3).\n        model_matrix (np.ndarray): Model matrix of shape (4, 4).\n        view_matrix (np.ndarray): View matrix of shape (4, 4).\n        projection_matrix (np.ndarray): Projection matrix of shape (4, 4).\n\n    Returns:\n        np.ndarray: MVP transformed vertices of shape (N, 4).\n    \"\"\"\n    # sanity checks\n    assert vertices.ndim == 2 and vertices.shape[1] == 3, f\"Expected vertices shape (N, 3), got {vertices.shape}\"\n    assert model_matrix.shape == (4, 4), f\"Expected model_matrix shape (4, 4), got {model_matrix.shape}\"\n    assert view_matrix.shape == (4, 4), f\"Expected view_matrix shape (4, 4), got {view_matrix.shape}\"\n    assert projection_matrix.shape == (4, 4), f\"Expected projection_matrix shape (4, 4), got {projection_matrix.shape}\"\n\n    # Compute the Model-View-Projection (MVP) matrix\n    mvp_matrix = projection_matrix @ view_matrix @ model_matrix\n\n    # convert vertices to homogeneous coordinates (x, y, z) -&gt; (x, y, z, w=1.0)\n    ws_column = np.ones((vertices.shape[0], 1), dtype=np.float32)\n    vertices_homogeneous = np.hstack((vertices, ws_column))  # shape (N, 4) for N vertices\n\n    # Apply the MVP transformation to the vertices\n    vertices_mvp_transformed = (mvp_matrix @ vertices_homogeneous.T).T  # shape (N, 4)\n\n    # return the transformed vertices\n    return vertices_mvp_transformed\n</code></pre>"},{"location":"api/gsp/#gsp.utils.transbuf_utils","title":"<code>gsp.utils.transbuf_utils</code>","text":"<p>Utility functions for working with TransBuf objects.</p> <p>This module provides helper functions to convert TransBuf instances to Buffer objects, handling both direct Buffer instances and TransformChain objects.</p>"},{"location":"api/gsp/#gsp.utils.transbuf_utils.TransBufUtils","title":"<code>TransBufUtils</code>","text":"<p>Utility class for TransBuf conversions and operations.</p> <p>This class provides static methods for converting TransBuf objects to Buffer objects, supporting both direct Buffer instances and TransformChain objects that need to be executed.</p> Source code in <code>src/gsp/utils/transbuf_utils.py</code> <pre><code>class TransBufUtils:\n    \"\"\"Utility class for TransBuf conversions and operations.\n\n    This class provides static methods for converting TransBuf objects\n    to Buffer objects, supporting both direct Buffer instances and\n    TransformChain objects that need to be executed.\n    \"\"\"\n\n    @staticmethod\n    def to_buffer(trans_buf: TransBuf) -&gt; Buffer:\n        \"\"\"Convert a TransBuf to a Buffer.\n\n        Args:\n            trans_buf: A TransBuf object which can be either a Buffer or a TransformChain.\n\n        Returns:\n            A Buffer object. If the input is already a Buffer, it's returned directly.\n            If it's a TransformChain, it's executed and the resulting Buffer is returned.\n\n        Raises:\n            ValueError: If the trans_buf is neither a Buffer nor a TransformChain.\n        \"\"\"\n        if isinstance(trans_buf, Buffer):\n            buffer = typing.cast(Buffer, trans_buf)\n            return buffer\n        elif isinstance(trans_buf, TransformChain):\n            transform_chain = typing.cast(TransformChain, trans_buf)\n            buffer = transform_chain.run()\n            return buffer\n        else:\n            raise ValueError(f\"Unsupported type for transbuf_to_buffer {type(trans_buf)}\")\n</code></pre>"},{"location":"api/gsp/#gsp.utils.transbuf_utils.TransBufUtils.to_buffer","title":"<code>to_buffer(trans_buf: TransBuf) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Convert a TransBuf to a Buffer.</p> <p>Parameters:</p> Name Type Description Default <code>trans_buf</code> <code>gsp.types.transbuf.TransBuf</code> <p>A TransBuf object which can be either a Buffer or a TransformChain.</p> required <p>Returns:</p> Type Description <code>gsp.types.buffer.Buffer</code> <p>A Buffer object. If the input is already a Buffer, it's returned directly.</p> <code>gsp.types.buffer.Buffer</code> <p>If it's a TransformChain, it's executed and the resulting Buffer is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the trans_buf is neither a Buffer nor a TransformChain.</p> Source code in <code>src/gsp/utils/transbuf_utils.py</code> <pre><code>@staticmethod\ndef to_buffer(trans_buf: TransBuf) -&gt; Buffer:\n    \"\"\"Convert a TransBuf to a Buffer.\n\n    Args:\n        trans_buf: A TransBuf object which can be either a Buffer or a TransformChain.\n\n    Returns:\n        A Buffer object. If the input is already a Buffer, it's returned directly.\n        If it's a TransformChain, it's executed and the resulting Buffer is returned.\n\n    Raises:\n        ValueError: If the trans_buf is neither a Buffer nor a TransformChain.\n    \"\"\"\n    if isinstance(trans_buf, Buffer):\n        buffer = typing.cast(Buffer, trans_buf)\n        return buffer\n    elif isinstance(trans_buf, TransformChain):\n        transform_chain = typing.cast(TransformChain, trans_buf)\n        buffer = transform_chain.run()\n        return buffer\n    else:\n        raise ValueError(f\"Unsupported type for transbuf_to_buffer {type(trans_buf)}\")\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils","title":"<code>gsp.utils.unit_utils</code>","text":"<p>\"Utility functions for unit conversions related to display and typography.</p>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils","title":"<code>UnitUtils</code>","text":"<p>Utility class for unit conversions related to display and typography.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>class UnitUtils:\n    \"\"\"Utility class for unit conversions related to display and typography.\"\"\"\n    @staticmethod\n    def in_to_cm(inches: float) -&gt; float:\n        \"\"\"Convert inches to centimeters.\n\n        Args:\n            inches (float): Length in inches.\n\n        Returns:\n            float: Length in centimeters.\n        \"\"\"\n        return inches * 2.54\n\n    @staticmethod\n    def cm_to_in(cm: float) -&gt; float:\n        \"\"\"Convert centimeters to inches.\n\n        Args:\n            cm (float): Length in centimeters.\n\n        Returns:\n            float: Length in inches.\n        \"\"\"\n        return cm / 2.54\n\n    @staticmethod\n    def device_pixel_ratio() -&gt; float:\n        \"\"\"Get the device pixel ratio for high-DPI displays.\n\n        Returns:\n            float: Device pixel ratio (typically 1.0 for standard displays, &gt;1.0 for high-DPI).\n        \"\"\"\n        # detect if running on a macOS retina display or other high-DPI display\n        # This is a placeholder implementation; actual detection may vary based on the GUI framework used.\n        is_macosx = \"darwin\" in sys.platform\n        if is_macosx:\n            return 2.0  # Common value for retina displays\n        return 1.0\n\n    @staticmethod\n    def pixel_to_point(pixel_size: float, dpi: float) -&gt; float:\n        \"\"\"Convert pixel size to typographic point size based on DPI.\n\n        Args:\n            pixel_size (float): Size in pixels.\n            dpi (float): Dots per inch of the display.\n\n        Returns:\n            float: Size in points.\n        \"\"\"\n        inches_per_pixel = 1.0 / dpi\n        points_per_inch = 72.0\n        point_size = pixel_size * inches_per_pixel * points_per_inch\n        return point_size\n\n    @staticmethod\n    def point_to_pixel(point_size: float, dpi: float) -&gt; float:\n        \"\"\"Convert point size to pixel size based on DPI.\n\n        Args:\n            point_size (float): Size in points.\n            dpi (float): Dots per inch of the display.\n\n        Returns:\n            float: Size in pixels.\n        \"\"\"\n        inches_per_point = 1.0 / 72.0\n        pixels_per_inch = dpi\n        pixel_size = point_size * inches_per_point * pixels_per_inch\n        return pixel_size\n\n    # =============================================================================\n    # numpy array versions\n    # =============================================================================\n\n    @staticmethod\n    def pixel_to_point_numpy(pixel_sizes: np.ndarray, dpi: float) -&gt; np.ndarray:\n        \"\"\"Convert an array of pixel sizes to point sizes based on DPI.\n\n        Args:\n            pixel_sizes (np.ndarray): Array of sizes in pixels.\n            dpi (float): Dots per inch of the display.\n\n        Returns:\n            np.ndarray: Array of sizes in points.\n        \"\"\"\n        inches_per_pixel = 1.0 / dpi\n        points_per_inch = 72.0\n        point_sizes = pixel_sizes * inches_per_pixel * points_per_inch\n        return point_sizes\n\n    @staticmethod\n    def point_to_pixel_numpy(point_sizes: np.ndarray, dpi: float) -&gt; np.ndarray:\n        \"\"\"Convert an array of point sizes to pixel sizes based on DPI.\n\n        Args:\n            point_sizes (np.ndarray): Array of sizes in points.\n            dpi (float): Dots per inch of the display.\n\n        Returns:\n            np.ndarray: Array of sizes in pixels.\n        \"\"\"\n        inches_per_point = 1.0 / 72.0\n        pixels_per_inch = dpi\n        pixel_sizes = point_sizes * inches_per_point * pixels_per_inch\n        return pixel_sizes\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.cm_to_in","title":"<code>cm_to_in(cm: float) -&gt; float</code>  <code>staticmethod</code>","text":"<p>Convert centimeters to inches.</p> <p>Parameters:</p> Name Type Description Default <code>cm</code> <code>float</code> <p>Length in centimeters.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length in inches.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef cm_to_in(cm: float) -&gt; float:\n    \"\"\"Convert centimeters to inches.\n\n    Args:\n        cm (float): Length in centimeters.\n\n    Returns:\n        float: Length in inches.\n    \"\"\"\n    return cm / 2.54\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.device_pixel_ratio","title":"<code>device_pixel_ratio() -&gt; float</code>  <code>staticmethod</code>","text":"<p>Get the device pixel ratio for high-DPI displays.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Device pixel ratio (typically 1.0 for standard displays, &gt;1.0 for high-DPI).</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef device_pixel_ratio() -&gt; float:\n    \"\"\"Get the device pixel ratio for high-DPI displays.\n\n    Returns:\n        float: Device pixel ratio (typically 1.0 for standard displays, &gt;1.0 for high-DPI).\n    \"\"\"\n    # detect if running on a macOS retina display or other high-DPI display\n    # This is a placeholder implementation; actual detection may vary based on the GUI framework used.\n    is_macosx = \"darwin\" in sys.platform\n    if is_macosx:\n        return 2.0  # Common value for retina displays\n    return 1.0\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.in_to_cm","title":"<code>in_to_cm(inches: float) -&gt; float</code>  <code>staticmethod</code>","text":"<p>Convert inches to centimeters.</p> <p>Parameters:</p> Name Type Description Default <code>inches</code> <code>float</code> <p>Length in inches.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length in centimeters.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef in_to_cm(inches: float) -&gt; float:\n    \"\"\"Convert inches to centimeters.\n\n    Args:\n        inches (float): Length in inches.\n\n    Returns:\n        float: Length in centimeters.\n    \"\"\"\n    return inches * 2.54\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.pixel_to_point","title":"<code>pixel_to_point(pixel_size: float, dpi: float) -&gt; float</code>  <code>staticmethod</code>","text":"<p>Convert pixel size to typographic point size based on DPI.</p> <p>Parameters:</p> Name Type Description Default <code>pixel_size</code> <code>float</code> <p>Size in pixels.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch of the display.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Size in points.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef pixel_to_point(pixel_size: float, dpi: float) -&gt; float:\n    \"\"\"Convert pixel size to typographic point size based on DPI.\n\n    Args:\n        pixel_size (float): Size in pixels.\n        dpi (float): Dots per inch of the display.\n\n    Returns:\n        float: Size in points.\n    \"\"\"\n    inches_per_pixel = 1.0 / dpi\n    points_per_inch = 72.0\n    point_size = pixel_size * inches_per_pixel * points_per_inch\n    return point_size\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.pixel_to_point_numpy","title":"<code>pixel_to_point_numpy(pixel_sizes: np.ndarray, dpi: float) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Convert an array of pixel sizes to point sizes based on DPI.</p> <p>Parameters:</p> Name Type Description Default <code>pixel_sizes</code> <code>numpy.ndarray</code> <p>Array of sizes in pixels.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch of the display.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Array of sizes in points.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef pixel_to_point_numpy(pixel_sizes: np.ndarray, dpi: float) -&gt; np.ndarray:\n    \"\"\"Convert an array of pixel sizes to point sizes based on DPI.\n\n    Args:\n        pixel_sizes (np.ndarray): Array of sizes in pixels.\n        dpi (float): Dots per inch of the display.\n\n    Returns:\n        np.ndarray: Array of sizes in points.\n    \"\"\"\n    inches_per_pixel = 1.0 / dpi\n    points_per_inch = 72.0\n    point_sizes = pixel_sizes * inches_per_pixel * points_per_inch\n    return point_sizes\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.point_to_pixel","title":"<code>point_to_pixel(point_size: float, dpi: float) -&gt; float</code>  <code>staticmethod</code>","text":"<p>Convert point size to pixel size based on DPI.</p> <p>Parameters:</p> Name Type Description Default <code>point_size</code> <code>float</code> <p>Size in points.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch of the display.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Size in pixels.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef point_to_pixel(point_size: float, dpi: float) -&gt; float:\n    \"\"\"Convert point size to pixel size based on DPI.\n\n    Args:\n        point_size (float): Size in points.\n        dpi (float): Dots per inch of the display.\n\n    Returns:\n        float: Size in pixels.\n    \"\"\"\n    inches_per_point = 1.0 / 72.0\n    pixels_per_inch = dpi\n    pixel_size = point_size * inches_per_point * pixels_per_inch\n    return pixel_size\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.point_to_pixel_numpy","title":"<code>point_to_pixel_numpy(point_sizes: np.ndarray, dpi: float) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Convert an array of point sizes to pixel sizes based on DPI.</p> <p>Parameters:</p> Name Type Description Default <code>point_sizes</code> <code>numpy.ndarray</code> <p>Array of sizes in points.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch of the display.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Array of sizes in pixels.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef point_to_pixel_numpy(point_sizes: np.ndarray, dpi: float) -&gt; np.ndarray:\n    \"\"\"Convert an array of point sizes to pixel sizes based on DPI.\n\n    Args:\n        point_sizes (np.ndarray): Array of sizes in points.\n        dpi (float): Dots per inch of the display.\n\n    Returns:\n        np.ndarray: Array of sizes in pixels.\n    \"\"\"\n    inches_per_point = 1.0 / 72.0\n    pixels_per_inch = dpi\n    pixel_sizes = point_sizes * inches_per_point * pixels_per_inch\n    return pixel_sizes\n</code></pre>"},{"location":"api/gsp/#gsp.utils.uuid_utils","title":"<code>gsp.utils.uuid_utils</code>","text":"<p>Utility functions for UUID generation.</p>"},{"location":"api/gsp/#gsp.utils.uuid_utils.UuidUtils","title":"<code>UuidUtils</code>","text":"<p>Utility class for generating UUIDs.</p> Source code in <code>src/gsp/utils/uuid_utils.py</code> <pre><code>class UuidUtils:\n    \"\"\"Utility class for generating UUIDs.\"\"\"\n\n    GSP_UUID_COUNTER: int = 0\n\n    @staticmethod\n    def generate_uuid() -&gt; str:\n        \"\"\"Generate a UUID version 4.\n\n        Returns:\n            str: The generated UUID.\n        \"\"\"\n        # if GSP_UUID_COUNTER is set, use a deterministic uuid for testing purposes\n        # - uuid becomes \"uuid-counter-&lt;counter&gt;\"\n        if \"GSP_UUID_COUNTER\" in os.environ:\n            _uuid = UuidUtils.GSP_UUID_COUNTER\n            UuidUtils.GSP_UUID_COUNTER += 1\n            return f\"uuid-counter-{_uuid}\"\n\n        # uuid4 = UuidUtils._generate_uuid_v4_with_uuid()\n        uuid4 = UuidUtils._generate_uuid_v4_with_numpy()\n        return uuid4\n\n    @staticmethod\n    def _generate_uuid_v4_with_numpy() -&gt; str:\n        \"\"\"Generate a UUID version 4 using numpy for random byte generation.\n\n        Thus it can be made deterministic by setting the numpy random seed.\n        \"\"\"\n        # 1. Generate 16 random bytes (128 bits) using numpy\n        # We use uint8 for byte representation\n        random_bytes = np.random.randint(0, 256, size=16, dtype=np.uint8)\n\n        # Convert the numpy array of bytes into a standard Python byte string\n        # This is necessary because bit manipulation on numpy arrays is tricky/non-standard\n        byte_string = bytes(random_bytes.tolist())\n\n        # 2. Apply the UUID version 4 (variant 1) rules:\n\n        # Rule 1: Set the four most significant bits of the 7th byte (octet 6) to 0100_2\n        # This sets the UUID version to 4.\n        # The 7th byte is at index 6 (0-indexed).\n        # To set the first four bits to 0100 (4 in hex), we clear the upper 4 bits\n        # and then set them to 4. (byte_string[6] &amp; 0b1111) clears the upper bits,\n        # then | 0x40 is wrong. It should be (byte_string[6] &amp; 0x0F) | 0x40.\n\n        # We must use a mutable structure to modify the bytes.\n        # We'll use a standard Python list of integers (0-255) for easy modification.\n        byte_list = list(byte_string)\n\n        # Set Version (byte 6, index 6): 0x40 (0100xxxx)\n        byte_list[6] = (byte_list[6] &amp; 0x0F) | 0x40\n\n        # Rule 2: Set the two most significant bits of the 9th byte (octet 8) to 10_2\n        # This sets the UUID variant to 'Reserved (RFC 4122)'.\n        # The 9th byte is at index 8.\n        # To set the first two bits to 10 (8 in hex or 0x80), we clear the upper 2 bits\n        # and then set them to 10. (byte_list[8] &amp; 0x3F) clears the upper 2 bits,\n        # then | 0x80 sets them to 10.\n        byte_list[8] = (byte_list[8] &amp; 0x3F) | 0x80\n\n        # 3. Format the bytes into a standard UUID string format (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)\n        # We convert the list back to bytes and then to hexadecimal.\n        final_bytes = bytes(byte_list)\n        hex_str = final_bytes.hex()\n\n        # Insert hyphens\n        uuid_v4 = f\"{hex_str[0:8]}-{hex_str[8:12]}-{hex_str[12:16]}-{hex_str[16:20]}-{hex_str[20:32]}\"\n\n        return uuid_v4\n\n    @staticmethod\n    def _generate_uuid_v4_with_uuid() -&gt; str:\n        \"\"\"Generate a UUID version 4 using the standard library uuid module.\"\"\"\n        import uuid\n\n        uuid_v4 = str(uuid.uuid4())\n\n        return uuid_v4\n</code></pre>"},{"location":"api/gsp/#gsp.utils.uuid_utils.UuidUtils.generate_uuid","title":"<code>generate_uuid() -&gt; str</code>  <code>staticmethod</code>","text":"<p>Generate a UUID version 4.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated UUID.</p> Source code in <code>src/gsp/utils/uuid_utils.py</code> <pre><code>@staticmethod\ndef generate_uuid() -&gt; str:\n    \"\"\"Generate a UUID version 4.\n\n    Returns:\n        str: The generated UUID.\n    \"\"\"\n    # if GSP_UUID_COUNTER is set, use a deterministic uuid for testing purposes\n    # - uuid becomes \"uuid-counter-&lt;counter&gt;\"\n    if \"GSP_UUID_COUNTER\" in os.environ:\n        _uuid = UuidUtils.GSP_UUID_COUNTER\n        UuidUtils.GSP_UUID_COUNTER += 1\n        return f\"uuid-counter-{_uuid}\"\n\n    # uuid4 = UuidUtils._generate_uuid_v4_with_uuid()\n    uuid4 = UuidUtils._generate_uuid_v4_with_numpy()\n    return uuid4\n</code></pre>"},{"location":"api/gsp/#constants","title":"Constants","text":""},{"location":"api/gsp/#gsp.constants","title":"<code>gsp.constants</code>","text":"<p>Common constants for GSP including color definitions.</p>"},{"location":"api/gsp/#gsp.constants.Constants","title":"<code>Constants</code>","text":"<p>Common constants in GSP. e.g. colors.</p> Source code in <code>src/gsp/constants.py</code> <pre><code>class Constants:\n    \"\"\"Common constants in GSP. e.g. colors.\"\"\"\n\n    class Color:\n        \"\"\"Common colors as RGBA bytearrays.\n\n        Each color is represented as a bytearray of four integers\n        corresponding to the red, green, blue, and alpha (opacity) channels, respectively.\n        Each channel value ranges from 0 to 255.\n        \"\"\"\n\n        white = bytearray([255, 255, 255, 255])\n        black = bytearray([0, 0, 0, 255])\n        red = bytearray([255, 0, 0, 255])\n        green = bytearray([0, 255, 0, 255])\n        blue = bytearray([0, 0, 255, 255])\n\n        yellow = bytearray([255, 255, 0, 255])\n        magenta = bytearray([255, 0, 255, 255])\n        cyan = bytearray([0, 255, 255, 255])\n\n        light_gray = bytearray([211, 211, 211, 255])\n        gray = bytearray([128, 128, 128, 255])\n        dark_gray = bytearray([64, 64, 64, 255])\n\n        transparent = bytearray([0, 0, 0, 0])\n</code></pre>"},{"location":"api/gsp/#gsp.constants.Constants.Color","title":"<code>Color</code>","text":"<p>Common colors as RGBA bytearrays.</p> <p>Each color is represented as a bytearray of four integers corresponding to the red, green, blue, and alpha (opacity) channels, respectively. Each channel value ranges from 0 to 255.</p> Source code in <code>src/gsp/constants.py</code> <pre><code>class Color:\n    \"\"\"Common colors as RGBA bytearrays.\n\n    Each color is represented as a bytearray of four integers\n    corresponding to the red, green, blue, and alpha (opacity) channels, respectively.\n    Each channel value ranges from 0 to 255.\n    \"\"\"\n\n    white = bytearray([255, 255, 255, 255])\n    black = bytearray([0, 0, 0, 255])\n    red = bytearray([255, 0, 0, 255])\n    green = bytearray([0, 255, 0, 255])\n    blue = bytearray([0, 0, 255, 255])\n\n    yellow = bytearray([255, 255, 0, 255])\n    magenta = bytearray([255, 0, 255, 255])\n    cyan = bytearray([0, 255, 255, 255])\n\n    light_gray = bytearray([211, 211, 211, 255])\n    gray = bytearray([128, 128, 128, 255])\n    dark_gray = bytearray([64, 64, 64, 255])\n\n    transparent = bytearray([0, 0, 0, 0])\n</code></pre>"},{"location":"api/gsp_datoviz/","title":"GSP Datoviz API Reference","text":"<p>The GSP Datoviz backend provides high-performance rendering using the Datoviz library.</p>"},{"location":"api/gsp_datoviz/#overview","title":"Overview","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz","title":"<code>gsp_datoviz</code>","text":"<p>GSP Datoviz package.</p>"},{"location":"api/gsp_datoviz/#renderer-module","title":"Renderer Module","text":"<p>The renderer module contains the main Datoviz renderer implementation and specialized renderers for different visual types.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer","title":"<code>gsp_datoviz.renderer</code>","text":"<p>Renderer module for GSP Datoviz.</p>"},{"location":"api/gsp_datoviz/#datoviz-renderer","title":"Datoviz Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer","title":"<code>gsp_datoviz.renderer.datoviz_renderer</code>","text":"<p>Datoviz renderer implementation.</p> <ul> <li><code>DVZ_LOG_LEVEL</code> environment variable can be set to control datoviz logging level.</li> <li>e.g. <code>DVZ_LOG_LEVEL=4</code> to mute all logs</li> </ul>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer","title":"<code>DatovizRenderer</code>","text":"<p>               Bases: <code>gsp.types.renderer_base.RendererBase</code></p> <p>Datoviz renderer implementation.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>class DatovizRenderer(RendererBase):\n    \"\"\"Datoviz renderer implementation.\"\"\"\n\n    def __init__(self, canvas: Canvas, offscreen: bool = False) -&gt; None:\n        \"\"\"Initialize the Datoviz renderer.\n\n        Args:\n            canvas (Canvas): The GSP canvas to render on.\n            offscreen (bool, optional): Whether to run the datoviz App in offscreen mode. Defaults to False.\n        \"\"\"\n        self._canvas = canvas\n        self._dvz_app: dvz.App = dvz.App(background=\"white\", offscreen=offscreen)\n        self._dvz_offscreen = offscreen\n        self._dvz_figure: _DvzFigure = self._dvz_app.figure(\n            width=canvas.get_width(),\n            height=canvas.get_height(),\n        )\n        self._dvz_panels: dict[str, _DvzPanel] = {}\n        \"\"\"datoviz panel per gsp viewport UUID\"\"\"\n        self._dvz_visuals: dict[str, _DvzVisual] = {}\n        \"\"\"datoviz visual per gsp visual group UUID\"\"\"\n        self._dvz_textures: dict[str, _DvzTexture] = {}\n        \"\"\"datoviz texture per gsp texture UUID\"\"\"\n\n        self._group_count: dict[str, int] = {}\n        \"\"\"group count per visual UUID\"\"\"\n\n    def close(self) -&gt; None:\n        \"\"\"Close the datoviz renderer and its app.\"\"\"\n        self._dvz_app.destroy()\n\n    def get_canvas(self) -&gt; Canvas:\n        \"\"\"Get the GSP canvas associated with the renderer.\"\"\"\n        return self._canvas\n\n    def get_dvz_app(self) -&gt; dvz.App:\n        \"\"\"Get the datoviz App associated with the renderer.\"\"\"\n        return self._dvz_app\n\n    def get_dvz_figure(self) -&gt; _DvzFigure:\n        \"\"\"Get the datoviz Figure associated with the renderer.\"\"\"\n        return self._dvz_figure\n\n    def show(self) -&gt; None:\n        \"\"\"Show the datoviz window and start the app.\"\"\"\n        # handle non-interactive mode for tests\n        in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n        if in_test:\n            return\n\n        # listen to keyboard events - if 'q' is pressed, stop the app\n        @self._dvz_app.connect(self._dvz_figure)\n        def on_keyboard(event):\n            # print(f\"{event.key_event()} key {event.key()} ({event.key_name()})\")\n            if event.key_event() == \"press\" and event.key_name() == \"q\":\n                self._dvz_app.stop()\n\n        # run the datoviz app to show the window\n        self._dvz_app.run()\n\n    # =============================================================================\n    # .render() function\n    # =============================================================================\n    def render(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n        return_image: bool = True,  # NOTE: make False by default. datoviz screenshot can cause segmentation fault in some cases\n        image_format: str = \"png\",\n    ) -&gt; bytes:\n        \"\"\"Render the given viewports and visuals using datoviz.\n\n        Args:\n            viewports (Sequence[Viewport]): Sequence of viewports to render.\n            visuals (Sequence[VisualBase]): Sequence of visual objects to render.\n            model_matrices (Sequence[TransBuf]): Sequence of transformation buffers for the visuals.\n            cameras (Sequence[Camera]): Sequence of cameras for each viewport.\n            return_image (bool, optional): Whether to return the rendered image as bytes. Defaults to True.\n            image_format (str, optional): The image format to return (\"png\"). Defaults to \"png\".\n\n        Returns:\n            bytes: The rendered image data if return_image is True, else empty bytes.\n        \"\"\"\n        # =============================================================================\n        # Create all viewport if needed\n        # =============================================================================\n\n        for viewport in viewports:\n            _dvz_panel = self._getOrCreateDvzPanel(viewport)\n\n        # =============================================================================\n        # Render all visual\n        # =============================================================================\n\n        for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n            self._render_visual(viewport, visual, model_matrix, camera)\n\n        # =============================================================================\n        # Return an image if needed\n        # =============================================================================\n\n        # sanity check\n        has_offscreen = bool(self._dvz_app.c_flags | dvz.APP_FLAGS_OFFSCREEN)\n        if return_image and not has_offscreen:\n            raise Exception(\"DatovizRenderer.render(): cannot return image when datoviz App is not in offscreen mode\")\n\n        rendered_image = b\"\"\n        if return_image:\n            if self._dvz_offscreen is True:\n                assert image_format in [\"png\"], f\"Unsupported image format: {image_format}\"\n                image_path = pathlib.Path(__file__).parent / \"_datoviz_offscreen_python.png\"\n                self._dvz_app.screenshot(self._dvz_figure, str(image_path))\n                with open(image_path, \"rb\") as file_reader:\n                    rendered_image = file_reader.read()\n                image_path.unlink()\n            else:\n                # NOTE: datoviz requires the datoviz App to be in offscreen mode to capture screenshot\n                # - this is a workaround to init a temporary offscreen datoviz App to capture the image\n\n                # Init a temporary offscreen datoviz renderer to capture the image\n                _renderer_offscreen = DatovizRenderer(self._canvas, offscreen=True)\n                # do render call\n                rendered_image = _renderer_offscreen.render(viewports, visuals, model_matrices, cameras, return_image=True)\n                # close the offscreen renderer\n                _renderer_offscreen.close()\n\n        return rendered_image\n\n    # =============================================================================\n    # ._render_pixels()\n    # =============================================================================\n\n    def _render_visual(self, viewport: Viewport, visual: VisualBase, model_matrix: TransBuf, camera: Camera) -&gt; None:\n        if isinstance(visual, Image):\n            from .datoviz_renderer_image import DatovizRendererImage\n\n            DatovizRendererImage.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Pixels):\n            from .datoviz_renderer_pixels import DatovizRendererPixels\n\n            DatovizRendererPixels.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Points):\n            from .datoviz_renderer_points import DatovizRendererPoints\n\n            DatovizRendererPoints.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Paths):\n            from .datoviz_renderer_paths import DatovizRendererPaths\n\n            DatovizRendererPaths.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Markers):\n            from .datoviz_renderer_markers import DatovizRendererMarkers\n\n            DatovizRendererMarkers.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Segments):\n            from .datoviz_renderer_segments import DatovizRendererSegments\n\n            DatovizRendererSegments.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Texts):\n            from .datoviz_renderer_texts import DatovizRendererTexts\n\n            DatovizRendererTexts.render(self, viewport, visual, model_matrix, camera)\n        else:\n            raise NotImplementedError(f\"DatovizRenderer.render() does not support visual of type {type(visual)}\")\n\n    # =============================================================================\n    # Get or create datoviz panel for viewport\n    # =============================================================================\n\n    def _getOrCreateDvzPanel(self, viewport: Viewport) -&gt; _DvzPanel:\n        viewport_uuid = viewport.get_uuid()\n        # if it already exists, return it\n        if viewport_uuid in self._dvz_panels:\n            return self._dvz_panels[viewport_uuid]\n\n        # create the datoviz panel\n        dvz_offset = (viewport.get_x(), self.get_canvas().get_height() - viewport.get_y() - viewport.get_height())\n        # dvz_offset = (viewport.get_x(), viewport.get_y())\n        dvz_size = (viewport.get_width(), viewport.get_height())\n        dvz_panel = self._dvz_figure.panel(\n            offset=dvz_offset,\n            size=dvz_size,\n        )\n\n        # store it\n        self._dvz_panels[viewport_uuid] = dvz_panel\n\n        # return newly created panel\n        return dvz_panel\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.__init__","title":"<code>__init__(canvas: Canvas, offscreen: bool = False) -&gt; None</code>","text":"<p>Initialize the Datoviz renderer.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>gsp.core.canvas.Canvas</code> <p>The GSP canvas to render on.</p> required <code>offscreen</code> <code>bool</code> <p>Whether to run the datoviz App in offscreen mode. Defaults to False.</p> <code>False</code> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def __init__(self, canvas: Canvas, offscreen: bool = False) -&gt; None:\n    \"\"\"Initialize the Datoviz renderer.\n\n    Args:\n        canvas (Canvas): The GSP canvas to render on.\n        offscreen (bool, optional): Whether to run the datoviz App in offscreen mode. Defaults to False.\n    \"\"\"\n    self._canvas = canvas\n    self._dvz_app: dvz.App = dvz.App(background=\"white\", offscreen=offscreen)\n    self._dvz_offscreen = offscreen\n    self._dvz_figure: _DvzFigure = self._dvz_app.figure(\n        width=canvas.get_width(),\n        height=canvas.get_height(),\n    )\n    self._dvz_panels: dict[str, _DvzPanel] = {}\n    \"\"\"datoviz panel per gsp viewport UUID\"\"\"\n    self._dvz_visuals: dict[str, _DvzVisual] = {}\n    \"\"\"datoviz visual per gsp visual group UUID\"\"\"\n    self._dvz_textures: dict[str, _DvzTexture] = {}\n    \"\"\"datoviz texture per gsp texture UUID\"\"\"\n\n    self._group_count: dict[str, int] = {}\n    \"\"\"group count per visual UUID\"\"\"\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the datoviz renderer and its app.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the datoviz renderer and its app.\"\"\"\n    self._dvz_app.destroy()\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.get_canvas","title":"<code>get_canvas() -&gt; Canvas</code>","text":"<p>Get the GSP canvas associated with the renderer.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def get_canvas(self) -&gt; Canvas:\n    \"\"\"Get the GSP canvas associated with the renderer.\"\"\"\n    return self._canvas\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.get_dvz_app","title":"<code>get_dvz_app() -&gt; dvz.App</code>","text":"<p>Get the datoviz App associated with the renderer.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def get_dvz_app(self) -&gt; dvz.App:\n    \"\"\"Get the datoviz App associated with the renderer.\"\"\"\n    return self._dvz_app\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.get_dvz_figure","title":"<code>get_dvz_figure() -&gt; _DvzFigure</code>","text":"<p>Get the datoviz Figure associated with the renderer.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def get_dvz_figure(self) -&gt; _DvzFigure:\n    \"\"\"Get the datoviz Figure associated with the renderer.\"\"\"\n    return self._dvz_figure\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.render","title":"<code>render(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera], return_image: bool = True, image_format: str = 'png') -&gt; bytes</code>","text":"<p>Render the given viewports and visuals using datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>Sequence of viewports to render.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>Sequence of visual objects to render.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>Sequence of transformation buffers for the visuals.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>Sequence of cameras for each viewport.</p> required <code>return_image</code> <code>bool</code> <p>Whether to return the rendered image as bytes. Defaults to True.</p> <code>True</code> <code>image_format</code> <code>str</code> <p>The image format to return (\"png\"). Defaults to \"png\".</p> <code>'png'</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The rendered image data if return_image is True, else empty bytes.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def render(\n    self,\n    viewports: Sequence[Viewport],\n    visuals: Sequence[VisualBase],\n    model_matrices: Sequence[TransBuf],\n    cameras: Sequence[Camera],\n    return_image: bool = True,  # NOTE: make False by default. datoviz screenshot can cause segmentation fault in some cases\n    image_format: str = \"png\",\n) -&gt; bytes:\n    \"\"\"Render the given viewports and visuals using datoviz.\n\n    Args:\n        viewports (Sequence[Viewport]): Sequence of viewports to render.\n        visuals (Sequence[VisualBase]): Sequence of visual objects to render.\n        model_matrices (Sequence[TransBuf]): Sequence of transformation buffers for the visuals.\n        cameras (Sequence[Camera]): Sequence of cameras for each viewport.\n        return_image (bool, optional): Whether to return the rendered image as bytes. Defaults to True.\n        image_format (str, optional): The image format to return (\"png\"). Defaults to \"png\".\n\n    Returns:\n        bytes: The rendered image data if return_image is True, else empty bytes.\n    \"\"\"\n    # =============================================================================\n    # Create all viewport if needed\n    # =============================================================================\n\n    for viewport in viewports:\n        _dvz_panel = self._getOrCreateDvzPanel(viewport)\n\n    # =============================================================================\n    # Render all visual\n    # =============================================================================\n\n    for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n        self._render_visual(viewport, visual, model_matrix, camera)\n\n    # =============================================================================\n    # Return an image if needed\n    # =============================================================================\n\n    # sanity check\n    has_offscreen = bool(self._dvz_app.c_flags | dvz.APP_FLAGS_OFFSCREEN)\n    if return_image and not has_offscreen:\n        raise Exception(\"DatovizRenderer.render(): cannot return image when datoviz App is not in offscreen mode\")\n\n    rendered_image = b\"\"\n    if return_image:\n        if self._dvz_offscreen is True:\n            assert image_format in [\"png\"], f\"Unsupported image format: {image_format}\"\n            image_path = pathlib.Path(__file__).parent / \"_datoviz_offscreen_python.png\"\n            self._dvz_app.screenshot(self._dvz_figure, str(image_path))\n            with open(image_path, \"rb\") as file_reader:\n                rendered_image = file_reader.read()\n            image_path.unlink()\n        else:\n            # NOTE: datoviz requires the datoviz App to be in offscreen mode to capture screenshot\n            # - this is a workaround to init a temporary offscreen datoviz App to capture the image\n\n            # Init a temporary offscreen datoviz renderer to capture the image\n            _renderer_offscreen = DatovizRenderer(self._canvas, offscreen=True)\n            # do render call\n            rendered_image = _renderer_offscreen.render(viewports, visuals, model_matrices, cameras, return_image=True)\n            # close the offscreen renderer\n            _renderer_offscreen.close()\n\n    return rendered_image\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.show","title":"<code>show() -&gt; None</code>","text":"<p>Show the datoviz window and start the app.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the datoviz window and start the app.\"\"\"\n    # handle non-interactive mode for tests\n    in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n    if in_test:\n        return\n\n    # listen to keyboard events - if 'q' is pressed, stop the app\n    @self._dvz_app.connect(self._dvz_figure)\n    def on_keyboard(event):\n        # print(f\"{event.key_event()} key {event.key()} ({event.key_name()})\")\n        if event.key_event() == \"press\" and event.key_name() == \"q\":\n            self._dvz_app.stop()\n\n    # run the datoviz app to show the window\n    self._dvz_app.run()\n</code></pre>"},{"location":"api/gsp_datoviz/#markers-renderer","title":"Markers Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_markers","title":"<code>gsp_datoviz.renderer.datoviz_renderer_markers</code>","text":"<p>Datoviz renderer for Markers visuals.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_markers.DatovizRendererMarkers","title":"<code>DatovizRendererMarkers</code>","text":"<p>Datoviz renderer for Markers visuals.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_markers.py</code> <pre><code>class DatovizRendererMarkers:\n    \"\"\"Datoviz renderer for Markers visuals.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: DatovizRenderer,\n        viewport: Viewport,\n        markers: Markers,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; None:\n        \"\"\"Render Markers visuals using Datoviz.\n\n        Args:\n            renderer (DatovizRenderer): The Datoviz renderer instance.\n            viewport (Viewport): The viewport to render in.\n            markers (Markers): The Markers visual to render.\n            model_matrix (TransBuf): The model matrix for the visual.\n            camera (Camera): The camera used for rendering.\n        \"\"\"\n        dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(markers.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 3d - shape (N, 3)\n        vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        sizes_buffer = TransBufUtils.to_buffer(markers.get_sizes())\n        face_colors_buffer = TransBufUtils.to_buffer(markers.get_face_colors())\n        edge_colors_buffer = TransBufUtils.to_buffer(markers.get_edge_colors())\n        edge_widths_buffer = TransBufUtils.to_buffer(markers.get_edge_widths())\n\n        # Convert buffers to numpy arrays)\n        sizes_pt2_numpy = Bufferx.to_numpy(sizes_buffer)\n        face_colors_numpy = Bufferx.to_numpy(face_colors_buffer)\n        edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer)\n        edge_widths_pt_numpy = Bufferx.to_numpy(edge_widths_buffer)\n\n        # Convert sizes from point^2 to pixel\n        radius_pt_numpy = np.sqrt(sizes_pt2_numpy / np.pi)\n        radius_px_numpy = UnitUtils.point_to_pixel_numpy(radius_pt_numpy, renderer.get_canvas().get_dpi())\n        diameter_px_numpy = radius_px_numpy * 2.0 * UnitUtils.device_pixel_ratio()\n        diameter_px_numpy = diameter_px_numpy.reshape(-1)\n\n        edge_widths_px_numpy = UnitUtils.point_to_pixel_numpy(edge_widths_pt_numpy, renderer.get_canvas().get_dpi())\n        edge_widths_px_numpy = edge_widths_px_numpy * UnitUtils.device_pixel_ratio()\n        edge_widths_px_numpy = edge_widths_px_numpy.reshape(-1)\n\n        # =============================================================================\n        # Sanity checks attributes buffers\n        # =============================================================================\n\n        Markers.sanity_check_attributes_buffer(\n            markers.get_marker_shape(),\n            vertices_buffer,\n            sizes_buffer,\n            face_colors_buffer,\n            edge_colors_buffer,\n            edge_widths_buffer,\n        )\n\n        # =============================================================================\n        # Create the datoviz visual if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{markers.get_uuid()}\"\n\n        # Create datoviz_visual if they do not exist\n        if artist_uuid not in renderer._dvz_visuals:\n            dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n            dvz_markers = renderer._dvz_app.marker(position=dummy_position_numpy)\n            renderer._dvz_visuals[artist_uuid] = dvz_markers\n            # Add the new visual to the panel\n            dvz_panel.add(dvz_markers)\n\n        # =============================================================================\n        # Update all attributes\n        # =============================================================================\n\n        # get the datoviz visual\n        dvz_markers = typing.cast(_DvzMarkers, renderer._dvz_visuals[artist_uuid])\n\n        # set attributes\n        dvz_markers.set_position(vertices_3d)\n\n        # Set the proper parameters\n        dvz_markers.set_size(diameter_px_numpy)\n        dvz_markers.set_color(face_colors_numpy)\n        dvz_markers.set_linewidth(edge_widths_px_numpy[0])\n        dvz_markers.set_edgecolor(edge_colors_numpy[0].tolist())  # datoviz only supports a single edge color\n\n        # sanity check - if edge_widths_px_numpy are not all the same, warn the user\n        if not np.all(edge_widths_px_numpy == edge_widths_px_numpy[0]):\n            warnings.warn(\"DatovizRendererMarkers: edge widths per marker are not fully supported by datoviz. \" \"Using the first edge width for all markers.\")\n        # sanity check - if edge_colors_numpy are not all the same, warn the user\n        if not np.all(edge_colors_numpy == edge_colors_numpy[0]):\n            warnings.warn(\"DatovizRendererMarkers: edge colors per marker are not fully supported by datoviz. \" \"Using the first edge color for all markers.\")\n\n        # Set mode, shape and aspect\n        dvz_markers.set_mode(\"code\")\n        dvz_markers.set_shape(ConverterUtils.marker_shape_gsp_to_dvz(markers.get_marker_shape()))\n\n        # Determine the `aspect` depending on face and edge colors/widths\n        is_face_color_transparent = bool(np.all(face_colors_numpy[:, 3] == 0))\n        is_edge_color_transparent = bool(np.all(edge_colors_numpy[:, 3] == 0))\n        is_edge_width_zero = bool(np.all(edge_widths_px_numpy == 0))\n        has_edge = not is_edge_color_transparent and not is_edge_width_zero\n        if not is_face_color_transparent:\n            if has_edge:\n                dvz_markers.set_aspect(\"outline\")\n            else:\n                dvz_markers.set_aspect(\"filled\")\n        else:\n            dvz_markers.set_aspect(\"stroke\")\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_markers.DatovizRendererMarkers.render","title":"<code>render(renderer: DatovizRenderer, viewport: Viewport, markers: Markers, model_matrix: TransBuf, camera: Camera) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Render Markers visuals using Datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer</code> <p>The Datoviz renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render in.</p> required <code>markers</code> <code>gsp.visuals.markers.Markers</code> <p>The Markers visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model matrix for the visual.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera used for rendering.</p> required Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_markers.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: DatovizRenderer,\n    viewport: Viewport,\n    markers: Markers,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; None:\n    \"\"\"Render Markers visuals using Datoviz.\n\n    Args:\n        renderer (DatovizRenderer): The Datoviz renderer instance.\n        viewport (Viewport): The viewport to render in.\n        markers (Markers): The Markers visual to render.\n        model_matrix (TransBuf): The model matrix for the visual.\n        camera (Camera): The camera used for rendering.\n    \"\"\"\n    dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(markers.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 3d - shape (N, 3)\n    vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    sizes_buffer = TransBufUtils.to_buffer(markers.get_sizes())\n    face_colors_buffer = TransBufUtils.to_buffer(markers.get_face_colors())\n    edge_colors_buffer = TransBufUtils.to_buffer(markers.get_edge_colors())\n    edge_widths_buffer = TransBufUtils.to_buffer(markers.get_edge_widths())\n\n    # Convert buffers to numpy arrays)\n    sizes_pt2_numpy = Bufferx.to_numpy(sizes_buffer)\n    face_colors_numpy = Bufferx.to_numpy(face_colors_buffer)\n    edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer)\n    edge_widths_pt_numpy = Bufferx.to_numpy(edge_widths_buffer)\n\n    # Convert sizes from point^2 to pixel\n    radius_pt_numpy = np.sqrt(sizes_pt2_numpy / np.pi)\n    radius_px_numpy = UnitUtils.point_to_pixel_numpy(radius_pt_numpy, renderer.get_canvas().get_dpi())\n    diameter_px_numpy = radius_px_numpy * 2.0 * UnitUtils.device_pixel_ratio()\n    diameter_px_numpy = diameter_px_numpy.reshape(-1)\n\n    edge_widths_px_numpy = UnitUtils.point_to_pixel_numpy(edge_widths_pt_numpy, renderer.get_canvas().get_dpi())\n    edge_widths_px_numpy = edge_widths_px_numpy * UnitUtils.device_pixel_ratio()\n    edge_widths_px_numpy = edge_widths_px_numpy.reshape(-1)\n\n    # =============================================================================\n    # Sanity checks attributes buffers\n    # =============================================================================\n\n    Markers.sanity_check_attributes_buffer(\n        markers.get_marker_shape(),\n        vertices_buffer,\n        sizes_buffer,\n        face_colors_buffer,\n        edge_colors_buffer,\n        edge_widths_buffer,\n    )\n\n    # =============================================================================\n    # Create the datoviz visual if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{markers.get_uuid()}\"\n\n    # Create datoviz_visual if they do not exist\n    if artist_uuid not in renderer._dvz_visuals:\n        dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n        dvz_markers = renderer._dvz_app.marker(position=dummy_position_numpy)\n        renderer._dvz_visuals[artist_uuid] = dvz_markers\n        # Add the new visual to the panel\n        dvz_panel.add(dvz_markers)\n\n    # =============================================================================\n    # Update all attributes\n    # =============================================================================\n\n    # get the datoviz visual\n    dvz_markers = typing.cast(_DvzMarkers, renderer._dvz_visuals[artist_uuid])\n\n    # set attributes\n    dvz_markers.set_position(vertices_3d)\n\n    # Set the proper parameters\n    dvz_markers.set_size(diameter_px_numpy)\n    dvz_markers.set_color(face_colors_numpy)\n    dvz_markers.set_linewidth(edge_widths_px_numpy[0])\n    dvz_markers.set_edgecolor(edge_colors_numpy[0].tolist())  # datoviz only supports a single edge color\n\n    # sanity check - if edge_widths_px_numpy are not all the same, warn the user\n    if not np.all(edge_widths_px_numpy == edge_widths_px_numpy[0]):\n        warnings.warn(\"DatovizRendererMarkers: edge widths per marker are not fully supported by datoviz. \" \"Using the first edge width for all markers.\")\n    # sanity check - if edge_colors_numpy are not all the same, warn the user\n    if not np.all(edge_colors_numpy == edge_colors_numpy[0]):\n        warnings.warn(\"DatovizRendererMarkers: edge colors per marker are not fully supported by datoviz. \" \"Using the first edge color for all markers.\")\n\n    # Set mode, shape and aspect\n    dvz_markers.set_mode(\"code\")\n    dvz_markers.set_shape(ConverterUtils.marker_shape_gsp_to_dvz(markers.get_marker_shape()))\n\n    # Determine the `aspect` depending on face and edge colors/widths\n    is_face_color_transparent = bool(np.all(face_colors_numpy[:, 3] == 0))\n    is_edge_color_transparent = bool(np.all(edge_colors_numpy[:, 3] == 0))\n    is_edge_width_zero = bool(np.all(edge_widths_px_numpy == 0))\n    has_edge = not is_edge_color_transparent and not is_edge_width_zero\n    if not is_face_color_transparent:\n        if has_edge:\n            dvz_markers.set_aspect(\"outline\")\n        else:\n            dvz_markers.set_aspect(\"filled\")\n    else:\n        dvz_markers.set_aspect(\"stroke\")\n</code></pre>"},{"location":"api/gsp_datoviz/#paths-renderer","title":"Paths Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_paths","title":"<code>gsp_datoviz.renderer.datoviz_renderer_paths</code>","text":"<p>Datoviz renderer for Paths visuals.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_paths.DatovizRendererPaths","title":"<code>DatovizRendererPaths</code>","text":"<p>Datoviz renderer for Paths visuals.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_paths.py</code> <pre><code>class DatovizRendererPaths:\n    \"\"\"Datoviz renderer for Paths visuals.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: DatovizRenderer,\n        viewport: Viewport,\n        paths: Paths,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; None:\n        \"\"\"Render Paths visuals using Datoviz.\n\n        Args:\n            renderer (DatovizRenderer): The Datoviz renderer instance.\n            viewport (Viewport): The viewport to render in.\n            paths (Paths): The Paths visual to render.\n            model_matrix (TransBuf): The model matrix for the visual.\n            camera (Camera): The camera used for rendering.\n        \"\"\"\n        dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(paths.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 3d - shape (N, 3)\n        vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n        # =============================================================================\n        # Get attributes\n        # =============================================================================\n\n        # get attributes from TransBuf to buffer\n        path_sizes_buffer = TransBufUtils.to_buffer(paths.get_path_sizes())\n        colors_buffer = TransBufUtils.to_buffer(paths.get_colors())\n        line_widths_buffer = TransBufUtils.to_buffer(paths.get_line_widths())\n\n        # convert buffers to numpy arrays\n        path_sizes_numpy = Bufferx.to_numpy(path_sizes_buffer)\n        colors_numpy = Bufferx.to_numpy(colors_buffer)\n        line_widths_pt_numpy = Bufferx.to_numpy(line_widths_buffer)\n\n        # Convert sizes from point^2 to pixel diameter\n        line_widths_px_numpy = UnitUtils.point_to_pixel_numpy(line_widths_pt_numpy, renderer.get_canvas().get_dpi())\n\n        path_sizes_numpy = path_sizes_numpy.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n        line_widths_px_numpy = line_widths_px_numpy.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n\n        # =============================================================================\n        # Sanity checks attributes buffers\n        # =============================================================================\n\n        Paths.sanity_check_attributes_buffer(\n            vertices_buffer,\n            path_sizes_buffer,\n            colors_buffer,\n            line_widths_buffer,\n            paths.get_cap_style(),\n            paths.get_join_style(),\n        )\n\n        # =============================================================================\n        # Create the datoviz visual if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{paths.get_uuid()}\"\n\n        # Create datoviz_visual if they do not exist\n        if artist_uuid not in renderer._dvz_visuals:\n            dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n            dummy_path_sizes_numpy = np.array([1], dtype=np.uint32)\n            dvz_paths = renderer._dvz_app.path()\n            dvz_paths.set_position(dummy_position_numpy, groups=dummy_path_sizes_numpy)\n            renderer._dvz_visuals[artist_uuid] = dvz_paths\n            # Add the new visual to the panel\n            dvz_panel.add(dvz_paths)\n\n        # =============================================================================\n        # Update all attributes\n        # =============================================================================\n\n        # get the datoviz visual\n        dvz_paths = typing.cast(_DvzPaths, renderer._dvz_visuals[artist_uuid])\n\n        dvz_paths.set_position(vertices_3d, groups=path_sizes_numpy)\n        dvz_paths.set_color(colors_numpy)\n        dvz_paths.set_linewidth(line_widths_px_numpy)\n        dvz_paths.set_cap(ConverterUtils.cap_style_gsp_to_dvz(paths.get_cap_style()))\n        dvz_paths.set_join(ConverterUtils.join_style_gsp_to_dvz(paths.get_join_style()))\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_paths.DatovizRendererPaths.render","title":"<code>render(renderer: DatovizRenderer, viewport: Viewport, paths: Paths, model_matrix: TransBuf, camera: Camera) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Render Paths visuals using Datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer</code> <p>The Datoviz renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render in.</p> required <code>paths</code> <code>gsp.visuals.paths.Paths</code> <p>The Paths visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model matrix for the visual.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera used for rendering.</p> required Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_paths.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: DatovizRenderer,\n    viewport: Viewport,\n    paths: Paths,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; None:\n    \"\"\"Render Paths visuals using Datoviz.\n\n    Args:\n        renderer (DatovizRenderer): The Datoviz renderer instance.\n        viewport (Viewport): The viewport to render in.\n        paths (Paths): The Paths visual to render.\n        model_matrix (TransBuf): The model matrix for the visual.\n        camera (Camera): The camera used for rendering.\n    \"\"\"\n    dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(paths.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 3d - shape (N, 3)\n    vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n    # =============================================================================\n    # Get attributes\n    # =============================================================================\n\n    # get attributes from TransBuf to buffer\n    path_sizes_buffer = TransBufUtils.to_buffer(paths.get_path_sizes())\n    colors_buffer = TransBufUtils.to_buffer(paths.get_colors())\n    line_widths_buffer = TransBufUtils.to_buffer(paths.get_line_widths())\n\n    # convert buffers to numpy arrays\n    path_sizes_numpy = Bufferx.to_numpy(path_sizes_buffer)\n    colors_numpy = Bufferx.to_numpy(colors_buffer)\n    line_widths_pt_numpy = Bufferx.to_numpy(line_widths_buffer)\n\n    # Convert sizes from point^2 to pixel diameter\n    line_widths_px_numpy = UnitUtils.point_to_pixel_numpy(line_widths_pt_numpy, renderer.get_canvas().get_dpi())\n\n    path_sizes_numpy = path_sizes_numpy.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n    line_widths_px_numpy = line_widths_px_numpy.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n\n    # =============================================================================\n    # Sanity checks attributes buffers\n    # =============================================================================\n\n    Paths.sanity_check_attributes_buffer(\n        vertices_buffer,\n        path_sizes_buffer,\n        colors_buffer,\n        line_widths_buffer,\n        paths.get_cap_style(),\n        paths.get_join_style(),\n    )\n\n    # =============================================================================\n    # Create the datoviz visual if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{paths.get_uuid()}\"\n\n    # Create datoviz_visual if they do not exist\n    if artist_uuid not in renderer._dvz_visuals:\n        dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n        dummy_path_sizes_numpy = np.array([1], dtype=np.uint32)\n        dvz_paths = renderer._dvz_app.path()\n        dvz_paths.set_position(dummy_position_numpy, groups=dummy_path_sizes_numpy)\n        renderer._dvz_visuals[artist_uuid] = dvz_paths\n        # Add the new visual to the panel\n        dvz_panel.add(dvz_paths)\n\n    # =============================================================================\n    # Update all attributes\n    # =============================================================================\n\n    # get the datoviz visual\n    dvz_paths = typing.cast(_DvzPaths, renderer._dvz_visuals[artist_uuid])\n\n    dvz_paths.set_position(vertices_3d, groups=path_sizes_numpy)\n    dvz_paths.set_color(colors_numpy)\n    dvz_paths.set_linewidth(line_widths_px_numpy)\n    dvz_paths.set_cap(ConverterUtils.cap_style_gsp_to_dvz(paths.get_cap_style()))\n    dvz_paths.set_join(ConverterUtils.join_style_gsp_to_dvz(paths.get_join_style()))\n</code></pre>"},{"location":"api/gsp_datoviz/#pixels-renderer","title":"Pixels Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_pixels","title":"<code>gsp_datoviz.renderer.datoviz_renderer_pixels</code>","text":"<p>Datoviz renderer for Pixels visuals.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_pixels.DatovizRendererPixels","title":"<code>DatovizRendererPixels</code>","text":"<p>Datoviz renderer for Pixels visuals.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_pixels.py</code> <pre><code>class DatovizRendererPixels:\n    \"\"\"Datoviz renderer for Pixels visuals.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: DatovizRenderer,\n        viewport: Viewport,\n        pixels: Pixels,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; None:\n        \"\"\"Render Pixels visuals using Datoviz.\n\n        Args:\n            renderer (DatovizRenderer): The Datoviz renderer instance.\n            viewport (Viewport): The viewport to render in.\n            pixels (Pixels): The Pixels visual to render.\n            model_matrix (TransBuf): The model matrix for the visual.\n            camera (Camera): The camera used for rendering.\n        \"\"\"\n        dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(pixels.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 3d - shape (N, 3)\n        vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n        # =============================================================================\n        # Get attributes\n        # =============================================================================\n\n        # get attributes from TransBuf to buffer\n        colors_buffer = TransBufUtils.to_buffer(pixels.get_colors())\n\n        # convert buffers to numpy arrays\n        colors_numpy = Bufferx.to_numpy(colors_buffer)\n\n        # =============================================================================\n        # Sanity checks attributes buffers\n        # =============================================================================\n\n        Pixels.sanity_check_attributes_buffer(vertices_buffer, colors_buffer, pixels.get_groups())\n\n        # =============================================================================\n        #   Compute indices_per_group for groups depending on the type of groups\n        # =============================================================================\n\n        indices_per_group = GroupUtils.compute_indices_per_group(vertices_3d.__len__(), pixels.get_groups())\n        group_count = GroupUtils.get_group_count(vertices_3d.__len__(), pixels.get_groups())\n\n        # =============================================================================\n        # Create the datoviz pixels if needed\n        # =============================================================================\n\n        artist_uuid_prefix = f\"{viewport.get_uuid()}_{pixels.get_uuid()}\"\n\n        # update stored group count\n        old_group_count = None\n        if artist_uuid_prefix in renderer._group_count:\n            old_group_count = renderer._group_count[artist_uuid_prefix]\n        renderer._group_count[artist_uuid_prefix] = group_count\n\n        # If the group count has changed, destroy old datoviz_visuals\n        if old_group_count is not None and old_group_count != group_count:\n            for group_index in range(old_group_count):\n                group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n                if group_uuid in renderer._dvz_visuals:\n                    dvz_pixels = typing.cast(_DvzPixel, renderer._dvz_visuals[group_uuid])\n                    dvz_panel.remove(dvz_pixels)\n                    del renderer._dvz_visuals[group_uuid]\n\n        # Create datoviz_visual if they do not exist\n        sample_group_uuid = f\"{artist_uuid_prefix}_group_0\"\n        if sample_group_uuid not in renderer._dvz_visuals:\n            for group_index in range(group_count):\n                dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n                dummy_color_numpy = np.array([[255, 0, 0, 255]], dtype=np.uint8).reshape((-1, 4))\n                dvz_pixels = renderer._dvz_app.pixel(\n                    position=dummy_position_numpy,\n                    color=dummy_color_numpy,\n                )\n                group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n                renderer._dvz_visuals[group_uuid] = dvz_pixels\n                # Add the new pixels to the panel\n                dvz_panel.add(dvz_pixels)\n\n        # =============================================================================\n        # Update all attributes\n        # =============================================================================\n\n        for group_index in range(group_count):\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n\n            # get the datoviz pixels\n            dvz_pixels = typing.cast(_DvzPixel, renderer._dvz_visuals[group_uuid])\n\n            # set attributes\n            group_vertices = vertices_3d[indices_per_group[group_index]]\n            dvz_pixels.set_position(group_vertices)\n\n            # set group_colors\n            group_colors = np.tile(colors_numpy[group_index], group_vertices.__len__()).reshape((-1, 4))\n            dvz_pixels.set_color(group_colors)\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_pixels.DatovizRendererPixels.render","title":"<code>render(renderer: DatovizRenderer, viewport: Viewport, pixels: Pixels, model_matrix: TransBuf, camera: Camera) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Render Pixels visuals using Datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer</code> <p>The Datoviz renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render in.</p> required <code>pixels</code> <code>gsp.visuals.pixels.Pixels</code> <p>The Pixels visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model matrix for the visual.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera used for rendering.</p> required Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_pixels.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: DatovizRenderer,\n    viewport: Viewport,\n    pixels: Pixels,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; None:\n    \"\"\"Render Pixels visuals using Datoviz.\n\n    Args:\n        renderer (DatovizRenderer): The Datoviz renderer instance.\n        viewport (Viewport): The viewport to render in.\n        pixels (Pixels): The Pixels visual to render.\n        model_matrix (TransBuf): The model matrix for the visual.\n        camera (Camera): The camera used for rendering.\n    \"\"\"\n    dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(pixels.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 3d - shape (N, 3)\n    vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n    # =============================================================================\n    # Get attributes\n    # =============================================================================\n\n    # get attributes from TransBuf to buffer\n    colors_buffer = TransBufUtils.to_buffer(pixels.get_colors())\n\n    # convert buffers to numpy arrays\n    colors_numpy = Bufferx.to_numpy(colors_buffer)\n\n    # =============================================================================\n    # Sanity checks attributes buffers\n    # =============================================================================\n\n    Pixels.sanity_check_attributes_buffer(vertices_buffer, colors_buffer, pixels.get_groups())\n\n    # =============================================================================\n    #   Compute indices_per_group for groups depending on the type of groups\n    # =============================================================================\n\n    indices_per_group = GroupUtils.compute_indices_per_group(vertices_3d.__len__(), pixels.get_groups())\n    group_count = GroupUtils.get_group_count(vertices_3d.__len__(), pixels.get_groups())\n\n    # =============================================================================\n    # Create the datoviz pixels if needed\n    # =============================================================================\n\n    artist_uuid_prefix = f\"{viewport.get_uuid()}_{pixels.get_uuid()}\"\n\n    # update stored group count\n    old_group_count = None\n    if artist_uuid_prefix in renderer._group_count:\n        old_group_count = renderer._group_count[artist_uuid_prefix]\n    renderer._group_count[artist_uuid_prefix] = group_count\n\n    # If the group count has changed, destroy old datoviz_visuals\n    if old_group_count is not None and old_group_count != group_count:\n        for group_index in range(old_group_count):\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n            if group_uuid in renderer._dvz_visuals:\n                dvz_pixels = typing.cast(_DvzPixel, renderer._dvz_visuals[group_uuid])\n                dvz_panel.remove(dvz_pixels)\n                del renderer._dvz_visuals[group_uuid]\n\n    # Create datoviz_visual if they do not exist\n    sample_group_uuid = f\"{artist_uuid_prefix}_group_0\"\n    if sample_group_uuid not in renderer._dvz_visuals:\n        for group_index in range(group_count):\n            dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n            dummy_color_numpy = np.array([[255, 0, 0, 255]], dtype=np.uint8).reshape((-1, 4))\n            dvz_pixels = renderer._dvz_app.pixel(\n                position=dummy_position_numpy,\n                color=dummy_color_numpy,\n            )\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n            renderer._dvz_visuals[group_uuid] = dvz_pixels\n            # Add the new pixels to the panel\n            dvz_panel.add(dvz_pixels)\n\n    # =============================================================================\n    # Update all attributes\n    # =============================================================================\n\n    for group_index in range(group_count):\n        group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n\n        # get the datoviz pixels\n        dvz_pixels = typing.cast(_DvzPixel, renderer._dvz_visuals[group_uuid])\n\n        # set attributes\n        group_vertices = vertices_3d[indices_per_group[group_index]]\n        dvz_pixels.set_position(group_vertices)\n\n        # set group_colors\n        group_colors = np.tile(colors_numpy[group_index], group_vertices.__len__()).reshape((-1, 4))\n        dvz_pixels.set_color(group_colors)\n</code></pre>"},{"location":"api/gsp_datoviz/#points-renderer","title":"Points Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_points","title":"<code>gsp_datoviz.renderer.datoviz_renderer_points</code>","text":"<p>Datoviz renderer for Points visuals.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_points.DatovizRendererPoints","title":"<code>DatovizRendererPoints</code>","text":"<p>Datoviz renderer for Points visuals.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_points.py</code> <pre><code>class DatovizRendererPoints:\n    \"\"\"Datoviz renderer for Points visuals.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: DatovizRenderer,\n        viewport: Viewport,\n        points: Points,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; None:\n        \"\"\"Render Points visuals using Datoviz.\n\n        Args:\n            renderer (DatovizRenderer): The Datoviz renderer instance.\n            viewport (Viewport): The viewport to render in.\n            points (Points): The Points visual to render.\n            model_matrix (TransBuf): The model matrix for the visual.\n            camera (Camera): The camera used for rendering.\n        \"\"\"\n        dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(points.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 3d - shape (N, 3)\n        vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n        # =============================================================================\n        # Get attributes\n        # =============================================================================\n\n        # get attributes from TransBuf to buffer\n        sizes_buffer = TransBufUtils.to_buffer(points.get_sizes())\n        face_colors_buffer = TransBufUtils.to_buffer(points.get_face_colors())\n        edge_colors_buffer = TransBufUtils.to_buffer(points.get_edge_colors())\n        edge_widths_buffer = TransBufUtils.to_buffer(points.get_edge_widths())\n\n        # convert buffers to numpy arrays\n        face_colors_numpy = Bufferx.to_numpy(face_colors_buffer)\n        edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer) / 255.0  # normalize to [0, 1] range\n        edge_widths_numpy = Bufferx.to_numpy(edge_widths_buffer).flatten()\n\n        # Convert sizes from point^2 to pixel diameter\n        sizes_pt2_numpy = Bufferx.to_numpy(sizes_buffer)\n        radius_pt_numpy = np.sqrt(sizes_pt2_numpy / np.pi)\n        radius_px_numpy = UnitUtils.point_to_pixel_numpy(radius_pt_numpy, renderer.get_canvas().get_dpi())\n        diameter_px_numpy = radius_px_numpy * 2.0 * UnitUtils.device_pixel_ratio()\n\n        # =============================================================================\n        # Sanity checks attributes buffers\n        # =============================================================================\n\n        Points.sanity_check_attributes_buffer(\n            vertices_buffer,\n            sizes_buffer,\n            face_colors_buffer,\n            edge_colors_buffer,\n            edge_widths_buffer,\n        )\n\n        # =============================================================================\n        # Create the datoviz visual if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{points.get_uuid()}\"\n\n        # Create datoviz_visual if they do not exist\n        if artist_uuid not in renderer._dvz_visuals:\n            dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n            dummy_color_numpy = np.array([[255, 0, 0, 255]], dtype=np.uint8).reshape((-1, 4))\n            dummy_size_numpy = np.array([1], dtype=np.float32).reshape((-1, 1)).reshape(-1)\n            dvz_points = renderer._dvz_app.point(\n                position=dummy_position_numpy,\n                color=dummy_color_numpy,\n                size=dummy_size_numpy,\n            )\n            renderer._dvz_visuals[artist_uuid] = dvz_points\n            # Add the new visual to the panel\n            dvz_panel.add(dvz_points)\n\n        # =============================================================================\n        # Update all attributes\n        # =============================================================================\n\n        # get the datoviz visual\n        dvz_points = typing.cast(_DvzPoints, renderer._dvz_visuals[artist_uuid])\n\n        # set attributes\n        dvz_points.set_position(vertices_3d)\n\n        # set group_sizes\n        group_sizes = np.tile(diameter_px_numpy, vertices_3d.__len__()).reshape((-1, 1))\n        group_sizes = group_sizes.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n        dvz_points.set_size(group_sizes)\n\n        # set group_colors\n        group_colors = np.tile(face_colors_numpy, vertices_3d.__len__()).reshape((-1, 4))\n        dvz_points.set_color(group_colors)\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_points.DatovizRendererPoints.render","title":"<code>render(renderer: DatovizRenderer, viewport: Viewport, points: Points, model_matrix: TransBuf, camera: Camera) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Render Points visuals using Datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer</code> <p>The Datoviz renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render in.</p> required <code>points</code> <code>gsp.visuals.points.Points</code> <p>The Points visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model matrix for the visual.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera used for rendering.</p> required Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_points.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: DatovizRenderer,\n    viewport: Viewport,\n    points: Points,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; None:\n    \"\"\"Render Points visuals using Datoviz.\n\n    Args:\n        renderer (DatovizRenderer): The Datoviz renderer instance.\n        viewport (Viewport): The viewport to render in.\n        points (Points): The Points visual to render.\n        model_matrix (TransBuf): The model matrix for the visual.\n        camera (Camera): The camera used for rendering.\n    \"\"\"\n    dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(points.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 3d - shape (N, 3)\n    vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n    # =============================================================================\n    # Get attributes\n    # =============================================================================\n\n    # get attributes from TransBuf to buffer\n    sizes_buffer = TransBufUtils.to_buffer(points.get_sizes())\n    face_colors_buffer = TransBufUtils.to_buffer(points.get_face_colors())\n    edge_colors_buffer = TransBufUtils.to_buffer(points.get_edge_colors())\n    edge_widths_buffer = TransBufUtils.to_buffer(points.get_edge_widths())\n\n    # convert buffers to numpy arrays\n    face_colors_numpy = Bufferx.to_numpy(face_colors_buffer)\n    edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer) / 255.0  # normalize to [0, 1] range\n    edge_widths_numpy = Bufferx.to_numpy(edge_widths_buffer).flatten()\n\n    # Convert sizes from point^2 to pixel diameter\n    sizes_pt2_numpy = Bufferx.to_numpy(sizes_buffer)\n    radius_pt_numpy = np.sqrt(sizes_pt2_numpy / np.pi)\n    radius_px_numpy = UnitUtils.point_to_pixel_numpy(radius_pt_numpy, renderer.get_canvas().get_dpi())\n    diameter_px_numpy = radius_px_numpy * 2.0 * UnitUtils.device_pixel_ratio()\n\n    # =============================================================================\n    # Sanity checks attributes buffers\n    # =============================================================================\n\n    Points.sanity_check_attributes_buffer(\n        vertices_buffer,\n        sizes_buffer,\n        face_colors_buffer,\n        edge_colors_buffer,\n        edge_widths_buffer,\n    )\n\n    # =============================================================================\n    # Create the datoviz visual if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{points.get_uuid()}\"\n\n    # Create datoviz_visual if they do not exist\n    if artist_uuid not in renderer._dvz_visuals:\n        dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n        dummy_color_numpy = np.array([[255, 0, 0, 255]], dtype=np.uint8).reshape((-1, 4))\n        dummy_size_numpy = np.array([1], dtype=np.float32).reshape((-1, 1)).reshape(-1)\n        dvz_points = renderer._dvz_app.point(\n            position=dummy_position_numpy,\n            color=dummy_color_numpy,\n            size=dummy_size_numpy,\n        )\n        renderer._dvz_visuals[artist_uuid] = dvz_points\n        # Add the new visual to the panel\n        dvz_panel.add(dvz_points)\n\n    # =============================================================================\n    # Update all attributes\n    # =============================================================================\n\n    # get the datoviz visual\n    dvz_points = typing.cast(_DvzPoints, renderer._dvz_visuals[artist_uuid])\n\n    # set attributes\n    dvz_points.set_position(vertices_3d)\n\n    # set group_sizes\n    group_sizes = np.tile(diameter_px_numpy, vertices_3d.__len__()).reshape((-1, 1))\n    group_sizes = group_sizes.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n    dvz_points.set_size(group_sizes)\n\n    # set group_colors\n    group_colors = np.tile(face_colors_numpy, vertices_3d.__len__()).reshape((-1, 4))\n    dvz_points.set_color(group_colors)\n</code></pre>"},{"location":"api/gsp_datoviz/#segments-renderer","title":"Segments Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_segments","title":"<code>gsp_datoviz.renderer.datoviz_renderer_segments</code>","text":"<p>Datoviz renderer for Segments visuals.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_segments.DatovizRendererSegments","title":"<code>DatovizRendererSegments</code>","text":"<p>Datoviz renderer for Segments visuals.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_segments.py</code> <pre><code>class DatovizRendererSegments:\n    \"\"\"Datoviz renderer for Segments visuals.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: DatovizRenderer,\n        viewport: Viewport,\n        segments: Segments,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; None:\n        \"\"\"Render Segments visuals using Datoviz.\n\n        Args:\n            renderer (DatovizRenderer): The Datoviz renderer instance.\n            viewport (Viewport): The viewport to render in.\n            segments (Segments): The Segments visual to render.\n            model_matrix (TransBuf): The model matrix for the visual.\n            camera (Camera): The camera used for rendering.\n        \"\"\"\n        dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(segments.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 3d - shape (N, 3)\n        vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n        # =============================================================================\n        # Get attributes\n        # =============================================================================\n\n        # get attributes from TransBuf to buffer\n        colors_buffer = TransBufUtils.to_buffer(segments.get_colors())\n        line_widths_buffer = TransBufUtils.to_buffer(segments.get_line_widths())\n\n        # convert buffers to numpy arrays\n        colors_numpy = Bufferx.to_numpy(colors_buffer)\n        line_widths_pt_numpy = Bufferx.to_numpy(line_widths_buffer)\n\n        # Convert sizes from point to pixel diameter\n        line_widths_px_numpy = UnitUtils.point_to_pixel_numpy(line_widths_pt_numpy, renderer.get_canvas().get_dpi())\n        line_widths_px_numpy = line_widths_px_numpy.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n\n        # =============================================================================\n        # Sanity checks attributes buffers\n        # =============================================================================\n\n        Segments.sanity_check_attributes_buffer(\n            vertices_buffer,\n            line_widths_buffer,\n            segments.get_cap_style(),\n            colors_buffer,\n        )\n\n        # =============================================================================\n        # Create the datoviz visual if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{segments.get_uuid()}\"\n\n        # Create datoviz_visual if they do not exist\n        if artist_uuid not in renderer._dvz_visuals:\n            dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n            dvz_segments = renderer._dvz_app.segment(dummy_position_numpy, dummy_position_numpy)\n            renderer._dvz_visuals[artist_uuid] = dvz_segments\n            # Add the new visual to the panel\n            dvz_panel.add(dvz_segments)\n\n        # =============================================================================\n        # Update all attributes\n        # =============================================================================\n\n        # get the datoviz visual\n        dvz_segments = typing.cast(_DvzSegments, renderer._dvz_visuals[artist_uuid])\n\n        # dvz_vertices_initial - the even indices are initial points\n        dvz_initial_vertices = np.ascontiguousarray(vertices_3d[0::2])\n        # dvz_vertices_terminal - the odd indices are terminal points\n        dvz_terminal_vertices = np.ascontiguousarray(vertices_3d[1::2])\n        dvz_initial_cap = ConverterUtils.cap_style_gsp_to_dvz(segments.get_cap_style())\n        dvz_terminal_cap = dvz_initial_cap  # same cap for initial and terminal\n\n        dvz_segments.set_position(dvz_initial_vertices, dvz_terminal_vertices)\n        dvz_segments.set_color(colors_numpy)\n        dvz_segments.set_linewidth(line_widths_px_numpy)\n        dvz_segments.set_cap(dvz_initial_cap, dvz_terminal_cap)\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_segments.DatovizRendererSegments.render","title":"<code>render(renderer: DatovizRenderer, viewport: Viewport, segments: Segments, model_matrix: TransBuf, camera: Camera) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Render Segments visuals using Datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer</code> <p>The Datoviz renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render in.</p> required <code>segments</code> <code>gsp.visuals.segments.Segments</code> <p>The Segments visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model matrix for the visual.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera used for rendering.</p> required Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_segments.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: DatovizRenderer,\n    viewport: Viewport,\n    segments: Segments,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; None:\n    \"\"\"Render Segments visuals using Datoviz.\n\n    Args:\n        renderer (DatovizRenderer): The Datoviz renderer instance.\n        viewport (Viewport): The viewport to render in.\n        segments (Segments): The Segments visual to render.\n        model_matrix (TransBuf): The model matrix for the visual.\n        camera (Camera): The camera used for rendering.\n    \"\"\"\n    dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(segments.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 3d - shape (N, 3)\n    vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n    # =============================================================================\n    # Get attributes\n    # =============================================================================\n\n    # get attributes from TransBuf to buffer\n    colors_buffer = TransBufUtils.to_buffer(segments.get_colors())\n    line_widths_buffer = TransBufUtils.to_buffer(segments.get_line_widths())\n\n    # convert buffers to numpy arrays\n    colors_numpy = Bufferx.to_numpy(colors_buffer)\n    line_widths_pt_numpy = Bufferx.to_numpy(line_widths_buffer)\n\n    # Convert sizes from point to pixel diameter\n    line_widths_px_numpy = UnitUtils.point_to_pixel_numpy(line_widths_pt_numpy, renderer.get_canvas().get_dpi())\n    line_widths_px_numpy = line_widths_px_numpy.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n\n    # =============================================================================\n    # Sanity checks attributes buffers\n    # =============================================================================\n\n    Segments.sanity_check_attributes_buffer(\n        vertices_buffer,\n        line_widths_buffer,\n        segments.get_cap_style(),\n        colors_buffer,\n    )\n\n    # =============================================================================\n    # Create the datoviz visual if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{segments.get_uuid()}\"\n\n    # Create datoviz_visual if they do not exist\n    if artist_uuid not in renderer._dvz_visuals:\n        dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n        dvz_segments = renderer._dvz_app.segment(dummy_position_numpy, dummy_position_numpy)\n        renderer._dvz_visuals[artist_uuid] = dvz_segments\n        # Add the new visual to the panel\n        dvz_panel.add(dvz_segments)\n\n    # =============================================================================\n    # Update all attributes\n    # =============================================================================\n\n    # get the datoviz visual\n    dvz_segments = typing.cast(_DvzSegments, renderer._dvz_visuals[artist_uuid])\n\n    # dvz_vertices_initial - the even indices are initial points\n    dvz_initial_vertices = np.ascontiguousarray(vertices_3d[0::2])\n    # dvz_vertices_terminal - the odd indices are terminal points\n    dvz_terminal_vertices = np.ascontiguousarray(vertices_3d[1::2])\n    dvz_initial_cap = ConverterUtils.cap_style_gsp_to_dvz(segments.get_cap_style())\n    dvz_terminal_cap = dvz_initial_cap  # same cap for initial and terminal\n\n    dvz_segments.set_position(dvz_initial_vertices, dvz_terminal_vertices)\n    dvz_segments.set_color(colors_numpy)\n    dvz_segments.set_linewidth(line_widths_px_numpy)\n    dvz_segments.set_cap(dvz_initial_cap, dvz_terminal_cap)\n</code></pre>"},{"location":"api/gsp_datoviz/#texts-renderer","title":"Texts Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_texts","title":"<code>gsp_datoviz.renderer.datoviz_renderer_texts</code>","text":"<p>Datoviz renderer for Texts visuals.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_texts.DatovizRendererTexts","title":"<code>DatovizRendererTexts</code>","text":"<p>Datoviz renderer for Texts visuals.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_texts.py</code> <pre><code>class DatovizRendererTexts:\n    \"\"\"Datoviz renderer for Texts visuals.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: DatovizRenderer,\n        viewport: Viewport,\n        texts: Texts,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; None:\n        \"\"\"Render Texts visuals using Datoviz.\n\n        Args:\n            renderer (DatovizRenderer): The Datoviz renderer instance.\n            viewport (Viewport): The viewport to render in.\n            texts (Texts): The Texts visual to render.\n            model_matrix (TransBuf): The model matrix for the visual.\n            camera (Camera): The camera used for rendering.\n        \"\"\"\n        dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(texts.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 3d - shape (N, 3)\n        vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n        # =============================================================================\n        # Get attributes\n        # =============================================================================\n\n        # get attributes from TransBuf to buffer\n        colors_buffer = TransBufUtils.to_buffer(texts.get_colors())\n        font_sizes_buffer = TransBufUtils.to_buffer(texts.get_font_sizes())\n        anchors_buffer = TransBufUtils.to_buffer(texts.get_anchors())\n        angles_buffer = TransBufUtils.to_buffer(texts.get_angles())\n\n        # convert buffers to numpy arrays\n        colors_numpy = Bufferx.to_numpy(colors_buffer)\n        font_sizes_numpy = Bufferx.to_numpy(font_sizes_buffer)\n        anchors_numpy = Bufferx.to_numpy(anchors_buffer)\n        angles_numpy = Bufferx.to_numpy(angles_buffer)\n\n        # =============================================================================\n        # Sanity checks attributes buffers\n        # =============================================================================\n\n        Texts.sanity_check_attributes_buffer(\n            vertices_buffer,\n            texts.get_strings(),\n            colors_buffer,\n            font_sizes_buffer,\n            anchors_buffer,\n            angles_buffer,\n            texts.get_font_name(),\n        )\n\n        # =============================================================================\n        # Create the datoviz visual if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{texts.get_uuid()}\"\n\n        # Create datoviz_visual if they do not exist\n        if artist_uuid not in renderer._dvz_visuals:\n            artist_uuid = f\"{viewport.get_uuid()}_{texts.get_uuid()}\"\n            dvz_glyphs = renderer._dvz_app.glyph(font_size=30)\n            # set dummy strings to initialize the visual\n            dvz_glyphs.set_strings([\"dummy string\"], string_pos=np.array([[0.0, 0.0, 0.0]], dtype=np.float32), scales=np.array([1.0], dtype=np.float32))\n            renderer._dvz_visuals[artist_uuid] = dvz_glyphs\n            # Add the new visual to the panel\n            dvz_panel.add(dvz_glyphs)\n\n        # =============================================================================\n        # Update all attributes\n        # =============================================================================\n\n        # # get the datoviz visual\n        dvz_glyphs = typing.cast(_DvzGlyphs, renderer._dvz_visuals[artist_uuid])\n\n        text_strings = texts.get_strings()\n        text_count = len(text_strings)\n        glyph_count = sum(map(len, text_strings))\n\n        # build glyph scales from font sizes\n        glyph_scales = np.zeros((glyph_count,), dtype=np.float32)\n        for text_index in range(text_count):\n            # TODO font-size is in typographic points, have to convert to pixels ? relation with the font_size of the dvz visual ?\n            # glyph_scales[text_index] = font_sizes_numpy[text_index, 0]  # dvz visual default font size is 100\n            for glyph_index in range(len(text_strings[text_index])):\n                global_glyph_index = sum(len(s) for s in text_strings[:text_index]) + glyph_index\n                glyph_scales[global_glyph_index] = font_sizes_numpy[text_index, 0] / 15  # dvz visual default font size is 100\n\n        # build glyph colors from text colors\n        glyph_colors = np.zeros((glyph_count, 4), dtype=np.uint8)\n        for text_index in range(text_count):\n            for glyph_index in range(len(text_strings[text_index])):\n                global_glyph_index = sum(len(s) for s in text_strings[:text_index]) + glyph_index\n                glyph_colors[global_glyph_index, :] = colors_numpy[text_index, :]\n\n        glyphs_angles = np.zeros((glyph_count,), dtype=np.float32)\n        for text_index in range(text_count):\n            for glyph_index in range(len(text_strings[text_index])):\n                global_glyph_index = sum(len(s) for s in text_strings[:text_index]) + glyph_index\n                glyphs_angles[global_glyph_index] = angles_numpy[text_index, 0] / 180 * np.pi  # convert to radians\n\n        dvz_glyphs.set_strings(text_strings, string_pos=vertices_3d)\n        dvz_glyphs.set_color(glyph_colors)\n        dvz_glyphs.set_angle(glyphs_angles)\n        dvz_glyphs.set_scale(glyph_scales)\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_texts.DatovizRendererTexts.render","title":"<code>render(renderer: DatovizRenderer, viewport: Viewport, texts: Texts, model_matrix: TransBuf, camera: Camera) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Render Texts visuals using Datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer</code> <p>The Datoviz renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render in.</p> required <code>texts</code> <code>gsp.visuals.texts.Texts</code> <p>The Texts visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model matrix for the visual.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera used for rendering.</p> required Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_texts.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: DatovizRenderer,\n    viewport: Viewport,\n    texts: Texts,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; None:\n    \"\"\"Render Texts visuals using Datoviz.\n\n    Args:\n        renderer (DatovizRenderer): The Datoviz renderer instance.\n        viewport (Viewport): The viewport to render in.\n        texts (Texts): The Texts visual to render.\n        model_matrix (TransBuf): The model matrix for the visual.\n        camera (Camera): The camera used for rendering.\n    \"\"\"\n    dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(texts.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 3d - shape (N, 3)\n    vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n    # =============================================================================\n    # Get attributes\n    # =============================================================================\n\n    # get attributes from TransBuf to buffer\n    colors_buffer = TransBufUtils.to_buffer(texts.get_colors())\n    font_sizes_buffer = TransBufUtils.to_buffer(texts.get_font_sizes())\n    anchors_buffer = TransBufUtils.to_buffer(texts.get_anchors())\n    angles_buffer = TransBufUtils.to_buffer(texts.get_angles())\n\n    # convert buffers to numpy arrays\n    colors_numpy = Bufferx.to_numpy(colors_buffer)\n    font_sizes_numpy = Bufferx.to_numpy(font_sizes_buffer)\n    anchors_numpy = Bufferx.to_numpy(anchors_buffer)\n    angles_numpy = Bufferx.to_numpy(angles_buffer)\n\n    # =============================================================================\n    # Sanity checks attributes buffers\n    # =============================================================================\n\n    Texts.sanity_check_attributes_buffer(\n        vertices_buffer,\n        texts.get_strings(),\n        colors_buffer,\n        font_sizes_buffer,\n        anchors_buffer,\n        angles_buffer,\n        texts.get_font_name(),\n    )\n\n    # =============================================================================\n    # Create the datoviz visual if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{texts.get_uuid()}\"\n\n    # Create datoviz_visual if they do not exist\n    if artist_uuid not in renderer._dvz_visuals:\n        artist_uuid = f\"{viewport.get_uuid()}_{texts.get_uuid()}\"\n        dvz_glyphs = renderer._dvz_app.glyph(font_size=30)\n        # set dummy strings to initialize the visual\n        dvz_glyphs.set_strings([\"dummy string\"], string_pos=np.array([[0.0, 0.0, 0.0]], dtype=np.float32), scales=np.array([1.0], dtype=np.float32))\n        renderer._dvz_visuals[artist_uuid] = dvz_glyphs\n        # Add the new visual to the panel\n        dvz_panel.add(dvz_glyphs)\n\n    # =============================================================================\n    # Update all attributes\n    # =============================================================================\n\n    # # get the datoviz visual\n    dvz_glyphs = typing.cast(_DvzGlyphs, renderer._dvz_visuals[artist_uuid])\n\n    text_strings = texts.get_strings()\n    text_count = len(text_strings)\n    glyph_count = sum(map(len, text_strings))\n\n    # build glyph scales from font sizes\n    glyph_scales = np.zeros((glyph_count,), dtype=np.float32)\n    for text_index in range(text_count):\n        # TODO font-size is in typographic points, have to convert to pixels ? relation with the font_size of the dvz visual ?\n        # glyph_scales[text_index] = font_sizes_numpy[text_index, 0]  # dvz visual default font size is 100\n        for glyph_index in range(len(text_strings[text_index])):\n            global_glyph_index = sum(len(s) for s in text_strings[:text_index]) + glyph_index\n            glyph_scales[global_glyph_index] = font_sizes_numpy[text_index, 0] / 15  # dvz visual default font size is 100\n\n    # build glyph colors from text colors\n    glyph_colors = np.zeros((glyph_count, 4), dtype=np.uint8)\n    for text_index in range(text_count):\n        for glyph_index in range(len(text_strings[text_index])):\n            global_glyph_index = sum(len(s) for s in text_strings[:text_index]) + glyph_index\n            glyph_colors[global_glyph_index, :] = colors_numpy[text_index, :]\n\n    glyphs_angles = np.zeros((glyph_count,), dtype=np.float32)\n    for text_index in range(text_count):\n        for glyph_index in range(len(text_strings[text_index])):\n            global_glyph_index = sum(len(s) for s in text_strings[:text_index]) + glyph_index\n            glyphs_angles[global_glyph_index] = angles_numpy[text_index, 0] / 180 * np.pi  # convert to radians\n\n    dvz_glyphs.set_strings(text_strings, string_pos=vertices_3d)\n    dvz_glyphs.set_color(glyph_colors)\n    dvz_glyphs.set_angle(glyphs_angles)\n    dvz_glyphs.set_scale(glyph_scales)\n</code></pre>"},{"location":"api/gsp_datoviz/#utils-module","title":"Utils Module","text":"<p>The utils module provides converter utilities for the Datoviz backend.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils","title":"<code>gsp_datoviz.utils</code>","text":"<p>Utility functions for converting GSP types to Datoviz types.</p>"},{"location":"api/gsp_datoviz/#converter-utils","title":"Converter Utils","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils","title":"<code>gsp_datoviz.utils.converter_utils</code>","text":"<p>Utility functions for converting GSP types to Datoviz types.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils.ConverterUtils","title":"<code>ConverterUtils</code>","text":"<p>Utility class for converting GSP types to Datoviz types.</p> Source code in <code>src/gsp_datoviz/utils/converter_utils.py</code> <pre><code>class ConverterUtils:\n    \"\"\"Utility class for converting GSP types to Datoviz types.\"\"\"\n\n    @staticmethod\n    def cap_style_gsp_to_dvz(cap_style: CapStyle) -&gt; str:\n        \"\"\"Convert CapStyle enum to Datoviz string.\n\n        Args:\n            cap_style: The GSP CapStyle enum value.\n\n        Returns:\n            The corresponding Datoviz cap style string.\n        \"\"\"\n        if cap_style == CapStyle.BUTT:\n            return \"butt\"\n        elif cap_style == CapStyle.ROUND:\n            return \"round\"\n        elif cap_style == CapStyle.PROJECTING:\n            return \"square\"\n        else:\n            raise ValueError(f\"Unsupported CapStyle: {cap_style}\")\n\n    @staticmethod\n    def join_style_gsp_to_dvz(join_style: JoinStyle) -&gt; str:\n        \"\"\"Convert JoinStyle enum to Datoviz string.\n\n        Args:\n            join_style: The GSP JoinStyle enum value.\n\n        Returns:\n            The corresponding Datoviz join style string.\n        \"\"\"\n        if join_style == JoinStyle.MITER:\n            raise ValueError(f\"Unsupported JoinStyle in datoviz: {join_style}\")\n        elif join_style == JoinStyle.ROUND:\n            return \"round\"\n        elif join_style == JoinStyle.BEVEL:\n            return \"square\"\n        else:\n            raise ValueError(f\"Unsupported JoinStyle: {join_style}\")\n\n    @staticmethod\n    def marker_shape_gsp_to_dvz(gsp_marker_shape: MarkerShape) -&gt; str:\n        \"\"\"Convert GSP marker shape to Datoviz marker shape.\n\n        Args:\n            gsp_marker_shape: The GSP MarkerShape enum value.\n\n        Returns:\n            The corresponding Datoviz marker shape string.\n        \"\"\"\n        if gsp_marker_shape == MarkerShape.disc:\n            mpl_marker_shape = \"disc\"\n        elif gsp_marker_shape == MarkerShape.square:\n            mpl_marker_shape = \"square\"\n        elif gsp_marker_shape == MarkerShape.club:\n            mpl_marker_shape = \"club\"\n        else:\n            raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n        return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils.ConverterUtils.cap_style_gsp_to_dvz","title":"<code>cap_style_gsp_to_dvz(cap_style: CapStyle) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert CapStyle enum to Datoviz string.</p> <p>Parameters:</p> Name Type Description Default <code>cap_style</code> <code>gsp.types.CapStyle</code> <p>The GSP CapStyle enum value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The corresponding Datoviz cap style string.</p> Source code in <code>src/gsp_datoviz/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef cap_style_gsp_to_dvz(cap_style: CapStyle) -&gt; str:\n    \"\"\"Convert CapStyle enum to Datoviz string.\n\n    Args:\n        cap_style: The GSP CapStyle enum value.\n\n    Returns:\n        The corresponding Datoviz cap style string.\n    \"\"\"\n    if cap_style == CapStyle.BUTT:\n        return \"butt\"\n    elif cap_style == CapStyle.ROUND:\n        return \"round\"\n    elif cap_style == CapStyle.PROJECTING:\n        return \"square\"\n    else:\n        raise ValueError(f\"Unsupported CapStyle: {cap_style}\")\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils.ConverterUtils.join_style_gsp_to_dvz","title":"<code>join_style_gsp_to_dvz(join_style: JoinStyle) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert JoinStyle enum to Datoviz string.</p> <p>Parameters:</p> Name Type Description Default <code>join_style</code> <code>gsp.types.JoinStyle</code> <p>The GSP JoinStyle enum value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The corresponding Datoviz join style string.</p> Source code in <code>src/gsp_datoviz/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef join_style_gsp_to_dvz(join_style: JoinStyle) -&gt; str:\n    \"\"\"Convert JoinStyle enum to Datoviz string.\n\n    Args:\n        join_style: The GSP JoinStyle enum value.\n\n    Returns:\n        The corresponding Datoviz join style string.\n    \"\"\"\n    if join_style == JoinStyle.MITER:\n        raise ValueError(f\"Unsupported JoinStyle in datoviz: {join_style}\")\n    elif join_style == JoinStyle.ROUND:\n        return \"round\"\n    elif join_style == JoinStyle.BEVEL:\n        return \"square\"\n    else:\n        raise ValueError(f\"Unsupported JoinStyle: {join_style}\")\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils.ConverterUtils.marker_shape_gsp_to_dvz","title":"<code>marker_shape_gsp_to_dvz(gsp_marker_shape: MarkerShape) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert GSP marker shape to Datoviz marker shape.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_marker_shape</code> <code>gsp.types.MarkerShape</code> <p>The GSP MarkerShape enum value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The corresponding Datoviz marker shape string.</p> Source code in <code>src/gsp_datoviz/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef marker_shape_gsp_to_dvz(gsp_marker_shape: MarkerShape) -&gt; str:\n    \"\"\"Convert GSP marker shape to Datoviz marker shape.\n\n    Args:\n        gsp_marker_shape: The GSP MarkerShape enum value.\n\n    Returns:\n        The corresponding Datoviz marker shape string.\n    \"\"\"\n    if gsp_marker_shape == MarkerShape.disc:\n        mpl_marker_shape = \"disc\"\n    elif gsp_marker_shape == MarkerShape.square:\n        mpl_marker_shape = \"square\"\n    elif gsp_marker_shape == MarkerShape.club:\n        mpl_marker_shape = \"club\"\n    else:\n        raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n    return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_datoviz/#viewport-events-datoviz","title":"Viewport Events Datoviz","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.viewport_events.viewport_events_datoviz","title":"<code>gsp_datoviz.viewport_events.viewport_events_datoviz</code>","text":"<p>DatovizRenderer event handler for viewport events.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.viewport_events.viewport_events_datoviz.ViewportEventsDatoviz","title":"<code>ViewportEventsDatoviz</code>","text":"<p>               Bases: <code>gsp.types.viewport_events_base.ViewportEventsBase</code></p> <p>DatovizRenderer event handler for viewport.</p> Source code in <code>src/gsp_datoviz/viewport_events/viewport_events_datoviz.py</code> <pre><code>class ViewportEventsDatoviz(ViewportEventsBase):\n    \"\"\"DatovizRenderer event handler for viewport.\"\"\"\n\n    __slots__ = (\"_renderer\", \"_viewport\", \"_has_key_focus\", \"_is_closed\")\n\n    def __init__(self, renderer: DatovizRenderer, viewport: Viewport) -&gt; None:\n        \"\"\"Initialize the Datoviz viewport event handler.\"\"\"\n        self._renderer = renderer\n        \"\"\"MatplotlibRenderer associated with this event handler\"\"\"\n        self._viewport = viewport\n        \"\"\"viewport associated with this event handler\"\"\"\n        self._has_key_focus = False\n        \"\"\"True if this viewport has the keyboard focus\"\"\"\n        self._is_closed = False\n        \"\"\"True if the event handler is closed\"\"\"\n\n        # Intanciate events\n        self.key_press_event = Event[KeyboardEventCallback]()\n        self.key_release_event = Event[KeyboardEventCallback]()\n        self.button_press_event = Event[MouseEventCallback]()\n        self.button_release_event = Event[MouseEventCallback]()\n        self.mouse_move_event = Event[MouseEventCallback]()\n        self.mouse_scroll_event = Event[MouseEventCallback]()\n        self.canvas_resize_event = Event[CanvasResizeEventCallback]()\n\n        dvz_app: dvz.App = self._renderer.get_dvz_app()\n        dvz_figure: _DvzFigure = self._renderer.get_dvz_figure()\n\n        # =============================================================================\n        # Connect keyboard in dvz_app\n        # =============================================================================\n        @dvz_app.connect(dvz_figure)\n        def on_keyboard(dvz_keyboard_event: dvz.KeyboardEvent):\n            # if this viewport is closed, ignore events (datoviz doesnt allow to disconnect events)\n            if self._is_closed:\n                return\n\n            # Read dvz_keyboard_event properties\n            dvz_event_name = dvz_keyboard_event.key_event()\n            dvz_key_name = dvz_keyboard_event.key_name()\n\n            # Convert fields to our MouseEvent\n            if dvz_event_name == \"press\":\n                event_type = EventType.KEY_PRESS\n            elif dvz_event_name == \"release\":\n                event_type = EventType.KEY_RELEASE\n            else:\n                return  # Unknown event\n\n            key_name = dvz_key_name\n\n            # Create our KeyEvent\n            key_event = KeyEvent(\n                viewport_uuid=self._viewport.get_uuid(),\n                event_type=event_type,\n                key_name=key_name,\n            )\n\n            # dispatch key_event to the proper handler\n            if key_event.event_type == EventType.KEY_PRESS:\n                self.key_press_event.dispatch(key_event)\n            elif key_event.event_type == EventType.KEY_RELEASE:\n                self.key_release_event.dispatch(key_event)\n            else:\n                raise ValueError(f\"Unknown key event type: {key_event.event_type}\")\n\n        # =============================================================================\n        # Connect mouse in dvz_app\n        # =============================================================================\n        @dvz_app.connect(dvz_figure)\n        def on_mouse(dvz_mouse_event: dvz.MouseEvent):\n            # if this viewport is closed, ignore events (datoviz doesnt allow to disconnect events)\n            if self._is_closed:\n                return\n\n            # Set key focus to true if there is a mouse press is inside the viewport, otherwise remove key focus if mouse press is outside\n            if dvz_mouse_event.mouse_event() == \"press\":\n                if self._viewport_contains_dvz_mouse_event(dvz_mouse_event):\n                    self._has_key_focus = True\n                else:\n                    self._has_key_focus = False\n\n            # discard events outside the viewport\n            if self._viewport_contains_dvz_mouse_event(dvz_mouse_event) is False:\n                return\n\n            # Read dvz_mouse_event properties\n            dvz_event_name: str = dvz_mouse_event.mouse_event()\n            dvz_mouse_pos: tuple[float, float] = dvz_mouse_event.pos()\n            dvz_mouse_x_px: float = dvz_mouse_pos[0]\n            dvz_mouse_y_px: float = self._renderer.get_canvas().get_height() - dvz_mouse_pos[1]\n            dvz_button_name: str = dvz_mouse_event.button_name()\n            dvz_wheel: float | None = dvz_mouse_event.wheel()\n\n            # Convert fields to our MouseEvent\n            if dvz_event_name == \"press\":\n                print(f\"event {dvz_event_name}\")\n                event_type = EventType.BUTTON_PRESS\n            elif dvz_event_name == \"release\":\n                print(f\"event {dvz_event_name}\")\n                event_type = EventType.BUTTON_RELEASE\n            elif dvz_event_name == \"move\":\n                event_type = EventType.MOUSE_MOVE\n            elif dvz_event_name == \"wheel\":\n                event_type = EventType.MOUSE_SCROLL\n            # elif dvz_event_name == \"drag_start\":\n            #     event_type = EventType.BUTTON_PRESS\n            # elif dvz_event_name == \"drag_stop\":\n            #     event_type = EventType.BUTTON_RELEASE\n            # elif dvz_event_name == \"click\":\n            #     event_type = EventType.BUTTON_PRESS\n            else:\n                print(f'\"Unknown dvz mouse event name: {dvz_event_name}\"')\n                return  # Unknown event\n\n            event_x: float = (dvz_mouse_x_px - self._viewport.get_x()) / self._viewport.get_width() * 2.0 - 1.0\n            event_y: float = (dvz_mouse_y_px - self._viewport.get_y()) / self._viewport.get_height() * 2.0 - 1.0\n\n            # print(f\"event_x: {event_x}, event_y: {event_y}\")\n            # print(\n            #     f\"dvz_mouse_x_px: {dvz_mouse_x_px}, dvz_mouse_y_px: {dvz_mouse_y_px}viewport x:{self._viewport.get_x()}, y:{self._viewport.get_y()}, w:{self._viewport.get_width()}, h:{self._viewport.get_height()}\"\n            # )\n\n            left_button: bool = dvz_button_name == \"left\"\n            middle_button: bool = dvz_button_name == \"middle\"\n            right_button: bool = dvz_button_name == \"right\"\n\n            event_scroll_steps: float = dvz_wheel if dvz_wheel is not None else 0.0\n\n            # Create our MouseEvent\n            mouse_event = MouseEvent(\n                viewport_uuid=self._viewport.get_uuid(),\n                event_type=event_type,\n                x_ndc=event_x,\n                y_ndc=event_y,\n                left_button=left_button,\n                middle_button=middle_button,\n                right_button=right_button,\n                scroll_steps=event_scroll_steps,\n            )\n\n            # dispatch mouse_event to the proper handler\n            if mouse_event.event_type == EventType.BUTTON_PRESS:\n                self.button_press_event.dispatch(mouse_event)\n            elif mouse_event.event_type == EventType.BUTTON_RELEASE:\n                self.button_release_event.dispatch(mouse_event)\n            elif mouse_event.event_type == EventType.MOUSE_MOVE:\n                self.mouse_move_event.dispatch(mouse_event)\n            elif mouse_event.event_type == EventType.MOUSE_SCROLL:\n                self.mouse_scroll_event.dispatch(mouse_event)\n            else:\n                raise ValueError(f\"Unknown mouse event type: {mouse_event.event_type}\")\n\n        # =============================================================================\n        # Connect resize in dvz_app\n        # =============================================================================\n        @dvz_app.connect(dvz_figure)\n        def on_resize(dvz_resize_event: dvz.WindowEvent):\n            canvas_width_px = dvz_resize_event.screen_width()  # TODO may be a good idea to rename .screen_width() to .canvas_width() or similar in datoviz\n            canvas_height_px = dvz_resize_event.screen_height()\n            # dispatch canvas resize event\n            canvas_resize_event = CanvasResizeEvent(\n                viewport_uuid=self._viewport.get_uuid(),\n                event_type=EventType.CANVAS_RESIZE,\n                canvas_width_px=canvas_width_px,\n                canvas_height_px=canvas_height_px,\n            )\n            self.canvas_resize_event.dispatch(canvas_resize_event)\n\n    def close(self):\n        \"\"\"Close the event handler and release resources.\"\"\"\n        # no more dispatch events (datoviz doesnt allow to disconnect events)\n        self._is_closed = True\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    def _viewport_contains_dvz_mouse_event(self, dvz_mouse_event: dvz.MouseEvent) -&gt; bool:\n        \"\"\"Check if the matplotlib mouse event is inside this viewport.\n\n        Args:\n            dvz_mouse_event: Datoviz mouse event.\n\n        Returns:\n            True if the mouse event is inside this viewport, False otherwise.\n        \"\"\"\n        dvz_mouse_pos = dvz_mouse_event.pos()\n        dvz_mouse_x = dvz_mouse_pos[0]\n        dvz_mouse_y = self._renderer.get_canvas().get_height() - dvz_mouse_pos[1]\n\n        # print(f\"dvz_mouse_x: {dvz_mouse_x}, dvz_mouse_y: {dvz_mouse_y}\")\n\n        mouse_x = dvz_mouse_x\n        mouse_y = dvz_mouse_y\n        if mouse_x &lt; self._viewport.get_x():\n            return False\n        if mouse_x &gt;= self._viewport.get_x() + self._viewport.get_width():\n            return False\n        if mouse_y &lt; self._viewport.get_y():\n            return False\n        if mouse_y &gt;= self._viewport.get_y() + self._viewport.get_height():\n            return False\n        return True\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.viewport_events.viewport_events_datoviz.ViewportEventsDatoviz.__init__","title":"<code>__init__(renderer: DatovizRenderer, viewport: Viewport) -&gt; None</code>","text":"<p>Initialize the Datoviz viewport event handler.</p> Source code in <code>src/gsp_datoviz/viewport_events/viewport_events_datoviz.py</code> <pre><code>def __init__(self, renderer: DatovizRenderer, viewport: Viewport) -&gt; None:\n    \"\"\"Initialize the Datoviz viewport event handler.\"\"\"\n    self._renderer = renderer\n    \"\"\"MatplotlibRenderer associated with this event handler\"\"\"\n    self._viewport = viewport\n    \"\"\"viewport associated with this event handler\"\"\"\n    self._has_key_focus = False\n    \"\"\"True if this viewport has the keyboard focus\"\"\"\n    self._is_closed = False\n    \"\"\"True if the event handler is closed\"\"\"\n\n    # Intanciate events\n    self.key_press_event = Event[KeyboardEventCallback]()\n    self.key_release_event = Event[KeyboardEventCallback]()\n    self.button_press_event = Event[MouseEventCallback]()\n    self.button_release_event = Event[MouseEventCallback]()\n    self.mouse_move_event = Event[MouseEventCallback]()\n    self.mouse_scroll_event = Event[MouseEventCallback]()\n    self.canvas_resize_event = Event[CanvasResizeEventCallback]()\n\n    dvz_app: dvz.App = self._renderer.get_dvz_app()\n    dvz_figure: _DvzFigure = self._renderer.get_dvz_figure()\n\n    # =============================================================================\n    # Connect keyboard in dvz_app\n    # =============================================================================\n    @dvz_app.connect(dvz_figure)\n    def on_keyboard(dvz_keyboard_event: dvz.KeyboardEvent):\n        # if this viewport is closed, ignore events (datoviz doesnt allow to disconnect events)\n        if self._is_closed:\n            return\n\n        # Read dvz_keyboard_event properties\n        dvz_event_name = dvz_keyboard_event.key_event()\n        dvz_key_name = dvz_keyboard_event.key_name()\n\n        # Convert fields to our MouseEvent\n        if dvz_event_name == \"press\":\n            event_type = EventType.KEY_PRESS\n        elif dvz_event_name == \"release\":\n            event_type = EventType.KEY_RELEASE\n        else:\n            return  # Unknown event\n\n        key_name = dvz_key_name\n\n        # Create our KeyEvent\n        key_event = KeyEvent(\n            viewport_uuid=self._viewport.get_uuid(),\n            event_type=event_type,\n            key_name=key_name,\n        )\n\n        # dispatch key_event to the proper handler\n        if key_event.event_type == EventType.KEY_PRESS:\n            self.key_press_event.dispatch(key_event)\n        elif key_event.event_type == EventType.KEY_RELEASE:\n            self.key_release_event.dispatch(key_event)\n        else:\n            raise ValueError(f\"Unknown key event type: {key_event.event_type}\")\n\n    # =============================================================================\n    # Connect mouse in dvz_app\n    # =============================================================================\n    @dvz_app.connect(dvz_figure)\n    def on_mouse(dvz_mouse_event: dvz.MouseEvent):\n        # if this viewport is closed, ignore events (datoviz doesnt allow to disconnect events)\n        if self._is_closed:\n            return\n\n        # Set key focus to true if there is a mouse press is inside the viewport, otherwise remove key focus if mouse press is outside\n        if dvz_mouse_event.mouse_event() == \"press\":\n            if self._viewport_contains_dvz_mouse_event(dvz_mouse_event):\n                self._has_key_focus = True\n            else:\n                self._has_key_focus = False\n\n        # discard events outside the viewport\n        if self._viewport_contains_dvz_mouse_event(dvz_mouse_event) is False:\n            return\n\n        # Read dvz_mouse_event properties\n        dvz_event_name: str = dvz_mouse_event.mouse_event()\n        dvz_mouse_pos: tuple[float, float] = dvz_mouse_event.pos()\n        dvz_mouse_x_px: float = dvz_mouse_pos[0]\n        dvz_mouse_y_px: float = self._renderer.get_canvas().get_height() - dvz_mouse_pos[1]\n        dvz_button_name: str = dvz_mouse_event.button_name()\n        dvz_wheel: float | None = dvz_mouse_event.wheel()\n\n        # Convert fields to our MouseEvent\n        if dvz_event_name == \"press\":\n            print(f\"event {dvz_event_name}\")\n            event_type = EventType.BUTTON_PRESS\n        elif dvz_event_name == \"release\":\n            print(f\"event {dvz_event_name}\")\n            event_type = EventType.BUTTON_RELEASE\n        elif dvz_event_name == \"move\":\n            event_type = EventType.MOUSE_MOVE\n        elif dvz_event_name == \"wheel\":\n            event_type = EventType.MOUSE_SCROLL\n        # elif dvz_event_name == \"drag_start\":\n        #     event_type = EventType.BUTTON_PRESS\n        # elif dvz_event_name == \"drag_stop\":\n        #     event_type = EventType.BUTTON_RELEASE\n        # elif dvz_event_name == \"click\":\n        #     event_type = EventType.BUTTON_PRESS\n        else:\n            print(f'\"Unknown dvz mouse event name: {dvz_event_name}\"')\n            return  # Unknown event\n\n        event_x: float = (dvz_mouse_x_px - self._viewport.get_x()) / self._viewport.get_width() * 2.0 - 1.0\n        event_y: float = (dvz_mouse_y_px - self._viewport.get_y()) / self._viewport.get_height() * 2.0 - 1.0\n\n        # print(f\"event_x: {event_x}, event_y: {event_y}\")\n        # print(\n        #     f\"dvz_mouse_x_px: {dvz_mouse_x_px}, dvz_mouse_y_px: {dvz_mouse_y_px}viewport x:{self._viewport.get_x()}, y:{self._viewport.get_y()}, w:{self._viewport.get_width()}, h:{self._viewport.get_height()}\"\n        # )\n\n        left_button: bool = dvz_button_name == \"left\"\n        middle_button: bool = dvz_button_name == \"middle\"\n        right_button: bool = dvz_button_name == \"right\"\n\n        event_scroll_steps: float = dvz_wheel if dvz_wheel is not None else 0.0\n\n        # Create our MouseEvent\n        mouse_event = MouseEvent(\n            viewport_uuid=self._viewport.get_uuid(),\n            event_type=event_type,\n            x_ndc=event_x,\n            y_ndc=event_y,\n            left_button=left_button,\n            middle_button=middle_button,\n            right_button=right_button,\n            scroll_steps=event_scroll_steps,\n        )\n\n        # dispatch mouse_event to the proper handler\n        if mouse_event.event_type == EventType.BUTTON_PRESS:\n            self.button_press_event.dispatch(mouse_event)\n        elif mouse_event.event_type == EventType.BUTTON_RELEASE:\n            self.button_release_event.dispatch(mouse_event)\n        elif mouse_event.event_type == EventType.MOUSE_MOVE:\n            self.mouse_move_event.dispatch(mouse_event)\n        elif mouse_event.event_type == EventType.MOUSE_SCROLL:\n            self.mouse_scroll_event.dispatch(mouse_event)\n        else:\n            raise ValueError(f\"Unknown mouse event type: {mouse_event.event_type}\")\n\n    # =============================================================================\n    # Connect resize in dvz_app\n    # =============================================================================\n    @dvz_app.connect(dvz_figure)\n    def on_resize(dvz_resize_event: dvz.WindowEvent):\n        canvas_width_px = dvz_resize_event.screen_width()  # TODO may be a good idea to rename .screen_width() to .canvas_width() or similar in datoviz\n        canvas_height_px = dvz_resize_event.screen_height()\n        # dispatch canvas resize event\n        canvas_resize_event = CanvasResizeEvent(\n            viewport_uuid=self._viewport.get_uuid(),\n            event_type=EventType.CANVAS_RESIZE,\n            canvas_width_px=canvas_width_px,\n            canvas_height_px=canvas_height_px,\n        )\n        self.canvas_resize_event.dispatch(canvas_resize_event)\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.viewport_events.viewport_events_datoviz.ViewportEventsDatoviz.close","title":"<code>close()</code>","text":"<p>Close the event handler and release resources.</p> Source code in <code>src/gsp_datoviz/viewport_events/viewport_events_datoviz.py</code> <pre><code>def close(self):\n    \"\"\"Close the event handler and release resources.\"\"\"\n    # no more dispatch events (datoviz doesnt allow to disconnect events)\n    self._is_closed = True\n</code></pre>"},{"location":"api/gsp_datoviz/#animator-datoviz","title":"Animator Datoviz","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.animator.animator_datoviz","title":"<code>gsp_datoviz.animator.animator_datoviz</code>","text":"<p>Animator for GSP scenes using a matplotlib renderer.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.animator.animator_datoviz.AnimatorDatoviz","title":"<code>AnimatorDatoviz</code>","text":"<p>               Bases: <code>gsp.types.animator_base.AnimatorBase</code></p> <p>Animator for GSP scenes using a matplotlib renderer.</p> Source code in <code>src/gsp_datoviz/animator/animator_datoviz.py</code> <pre><code>class AnimatorDatoviz(AnimatorBase):\n    \"\"\"Animator for GSP scenes using a matplotlib renderer.\"\"\"\n\n    def __init__(\n        self,\n        datoviz_renderer: DatovizRenderer,\n        fps: int = 50,\n        video_duration: float | None = None,\n        video_path: str | None = None,\n    ):\n        \"\"\"Initialize the animator.\n\n        Args:\n            datoviz_renderer (DatovizRenderer): The datoviz renderer to use for rendering.\n            fps (int, optional): Frames per second. Defaults to 50.\n            video_duration (float | None, optional): Duration of the video to save. Defaults to None.\n            video_path (str | None, optional): Path to save the video. Defaults to None.\n        \"\"\"\n        self._callbacks: list[AnimatorFunc] = []\n        self._datoviz_renderer = datoviz_renderer\n        self._fps = fps\n\n        # sanity check - video not supported yet\n        assert video_duration is None, \"GspAnimatorDatoviz does not support video saving yet.\"\n        assert video_path is None, \"GspAnimatorDatoviz does not support video saving yet.\"\n\n        self._canvas: Canvas | None = None\n        self._viewports: Sequence[Viewport] | None = None\n        self._visuals: Sequence[VisualBase] | None = None\n        self._model_matrices: Sequence[TransBuf] | None = None\n        self._cameras: Sequence[Camera] | None = None\n\n        self.on_video_saved = Event[VideoSavedCalledback]()\n        \"\"\"Event triggered when the video is saved.\"\"\"\n\n    # =============================================================================\n    # .add_callback/.remove_callback/.decorator\n    # =============================================================================\n\n    def add_callback(self, func: AnimatorFunc) -&gt; None:\n        \"\"\"Add a callback to the animation loop.\"\"\"\n        self._callbacks.append(func)\n\n    def remove_callback(self, func: AnimatorFunc) -&gt; None:\n        \"\"\"Remove a callback from the animation loop.\"\"\"\n        self._callbacks.remove(func)\n\n    def event_listener(self, func: AnimatorFunc) -&gt; AnimatorFunc:\n        \"\"\"A decorator to add a callback to the animation loop.\n\n        Usage:\n            ```python\n                @animation_loop.event_listener\n                def my_callback(delta_time: float) -&gt; Sequence[Object3D]:\n                    ...\n\n                # later, if needed\n                animation_loop.remove_callback(my_callback)\n            ```\n        \"\"\"\n        self.add_callback(func)\n\n        def wrapper(delta_time: float) -&gt; Sequence[VisualBase]:\n            # print(\"Before the function runs\")\n            result = func(delta_time)\n            # print(\"After the function runs\")\n            return result\n\n        return wrapper\n\n    # =============================================================================\n    # .start()\n    # =============================================================================\n    def start(self, viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; None:\n        \"\"\"Animate the given canvas and camera using the provided callbacks to update visuals.\"\"\"\n        self._canvas = self._datoviz_renderer.get_canvas()\n        self._viewports = viewports\n        self._visuals = visuals\n        self._model_matrices = model_matrices\n        self._cameras = cameras\n        self._time_last_update = time.time()\n\n        # =============================================================================\n        # Render the image once\n        # =============================================================================\n\n        self._datoviz_renderer.render(viewports, visuals, model_matrices, cameras)\n\n        # =============================================================================\n        # Handle GSP_TEST=True\n        # =============================================================================\n\n        # detect if we are in not interactive mode - used during testing\n        in_test = \"GSP_TEST\" in os.environ and os.environ[\"GSP_TEST\"] == \"True\"\n\n        # if we are not in interactive mode, save a preview image and return\n        if in_test == True:\n            # notify all animator callbacks\n            changed_visuals: list[VisualBase] = []\n            for animator_callback in self._callbacks:\n                _changed_visuals = animator_callback(1.0 / self._fps)\n                changed_visuals.extend(_changed_visuals)\n\n            # render the scene to get the new image\n            image_png_data = self._datoviz_renderer.render(viewports, visuals, model_matrices, cameras, return_image=True, image_format=\"png\")\n            # get the main script name\n            main_script_name = os.path.basename(__main__.__file__) if hasattr(__main__, \"__file__\") else \"interactive\"\n            main_script_basename = os.path.splitext(main_script_name)[0]\n            # buid the output image path\n            image_path = os.path.join(__dirname__, \"../../../examples/output\", f\"{main_script_basename}_animator_datoviz.png\")\n            image_path = os.path.abspath(image_path)\n            # save image_png_data in a image file\n            with open(image_path, \"wb\") as image_file:\n                image_file.write(image_png_data)\n            # log the event\n            print(f\"Saved animation preview image to: {image_path}\")\n            return\n\n        # NOTE: here we are in interactive mode!!\n\n        # =============================================================================\n        # Initialize the animation\n        # =============================================================================\n\n        dvz_app = self._datoviz_renderer.get_dvz_app()\n\n        @dvz_app.timer(period=1.0 / self._fps)\n        def on_timer(event):\n            self._dvz_animate()\n\n        # =============================================================================\n        # Show the animation\n        # =============================================================================\n\n        self._datoviz_renderer.show()\n\n    # =============================================================================\n    # .stop()\n    # =============================================================================\n    def stop(self):\n        \"\"\"Stop the animation.\"\"\"\n        self._canvas = None\n        self._viewports = None\n        self._time_last_update = None\n\n        warning.warn(\"GspAnimatorDatoviz.stop() is not fully implemented yet.\")\n\n    def _dvz_animate(self) -&gt; None:\n        # sanity checks\n        assert self._canvas is not None, \"Canvas MUST be set during the animation\"\n        assert self._viewports is not None, \"Viewports MUST be set during the animation\"\n        assert self._visuals is not None, \"Visuals MUST be set during the animation\"\n        assert self._model_matrices is not None, \"Model matrices MUST be set during the animation\"\n        assert self._cameras is not None, \"Cameras MUST be set during the animation\"\n\n        # compute delta time\n        present = time.time()\n        delta_time = (present - self._time_last_update) if self._time_last_update is not None else (1 / self._fps)\n        self._time_last_update = present\n\n        # notify all animator callbacks\n        changed_visuals: list[VisualBase] = []\n        for callback in self._callbacks:\n            _changed_visuals = callback(delta_time)\n            changed_visuals.extend(_changed_visuals)\n\n        # changed_visuals is not used by datoviz, but could be used in the future\n\n        # Render the scene to update the visuals\n        self._datoviz_renderer.render(self._viewports, self._visuals, self._model_matrices, self._cameras, return_image=False)\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.animator.animator_datoviz.AnimatorDatoviz.on_video_saved","title":"<code>on_video_saved = Event[VideoSavedCalledback]()</code>  <code>instance-attribute</code>","text":"<p>Event triggered when the video is saved.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.animator.animator_datoviz.AnimatorDatoviz.__init__","title":"<code>__init__(datoviz_renderer: DatovizRenderer, fps: int = 50, video_duration: float | None = None, video_path: str | None = None)</code>","text":"<p>Initialize the animator.</p> <p>Parameters:</p> Name Type Description Default <code>datoviz_renderer</code> <code>gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer</code> <p>The datoviz renderer to use for rendering.</p> required <code>fps</code> <code>int</code> <p>Frames per second. Defaults to 50.</p> <code>50</code> <code>video_duration</code> <code>float | None</code> <p>Duration of the video to save. Defaults to None.</p> <code>None</code> <code>video_path</code> <code>str | None</code> <p>Path to save the video. Defaults to None.</p> <code>None</code> Source code in <code>src/gsp_datoviz/animator/animator_datoviz.py</code> <pre><code>def __init__(\n    self,\n    datoviz_renderer: DatovizRenderer,\n    fps: int = 50,\n    video_duration: float | None = None,\n    video_path: str | None = None,\n):\n    \"\"\"Initialize the animator.\n\n    Args:\n        datoviz_renderer (DatovizRenderer): The datoviz renderer to use for rendering.\n        fps (int, optional): Frames per second. Defaults to 50.\n        video_duration (float | None, optional): Duration of the video to save. Defaults to None.\n        video_path (str | None, optional): Path to save the video. Defaults to None.\n    \"\"\"\n    self._callbacks: list[AnimatorFunc] = []\n    self._datoviz_renderer = datoviz_renderer\n    self._fps = fps\n\n    # sanity check - video not supported yet\n    assert video_duration is None, \"GspAnimatorDatoviz does not support video saving yet.\"\n    assert video_path is None, \"GspAnimatorDatoviz does not support video saving yet.\"\n\n    self._canvas: Canvas | None = None\n    self._viewports: Sequence[Viewport] | None = None\n    self._visuals: Sequence[VisualBase] | None = None\n    self._model_matrices: Sequence[TransBuf] | None = None\n    self._cameras: Sequence[Camera] | None = None\n\n    self.on_video_saved = Event[VideoSavedCalledback]()\n    \"\"\"Event triggered when the video is saved.\"\"\"\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.animator.animator_datoviz.AnimatorDatoviz.add_callback","title":"<code>add_callback(func: AnimatorFunc) -&gt; None</code>","text":"<p>Add a callback to the animation loop.</p> Source code in <code>src/gsp_datoviz/animator/animator_datoviz.py</code> <pre><code>def add_callback(self, func: AnimatorFunc) -&gt; None:\n    \"\"\"Add a callback to the animation loop.\"\"\"\n    self._callbacks.append(func)\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.animator.animator_datoviz.AnimatorDatoviz.event_listener","title":"<code>event_listener(func: AnimatorFunc) -&gt; AnimatorFunc</code>","text":"<p>A decorator to add a callback to the animation loop.</p> Usage <pre><code>    @animation_loop.event_listener\n    def my_callback(delta_time: float) -&gt; Sequence[Object3D]:\n        ...\n\n    # later, if needed\n    animation_loop.remove_callback(my_callback)\n</code></pre> Source code in <code>src/gsp_datoviz/animator/animator_datoviz.py</code> <pre><code>def event_listener(self, func: AnimatorFunc) -&gt; AnimatorFunc:\n    \"\"\"A decorator to add a callback to the animation loop.\n\n    Usage:\n        ```python\n            @animation_loop.event_listener\n            def my_callback(delta_time: float) -&gt; Sequence[Object3D]:\n                ...\n\n            # later, if needed\n            animation_loop.remove_callback(my_callback)\n        ```\n    \"\"\"\n    self.add_callback(func)\n\n    def wrapper(delta_time: float) -&gt; Sequence[VisualBase]:\n        # print(\"Before the function runs\")\n        result = func(delta_time)\n        # print(\"After the function runs\")\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.animator.animator_datoviz.AnimatorDatoviz.remove_callback","title":"<code>remove_callback(func: AnimatorFunc) -&gt; None</code>","text":"<p>Remove a callback from the animation loop.</p> Source code in <code>src/gsp_datoviz/animator/animator_datoviz.py</code> <pre><code>def remove_callback(self, func: AnimatorFunc) -&gt; None:\n    \"\"\"Remove a callback from the animation loop.\"\"\"\n    self._callbacks.remove(func)\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.animator.animator_datoviz.AnimatorDatoviz.start","title":"<code>start(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; None</code>","text":"<p>Animate the given canvas and camera using the provided callbacks to update visuals.</p> Source code in <code>src/gsp_datoviz/animator/animator_datoviz.py</code> <pre><code>def start(self, viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; None:\n    \"\"\"Animate the given canvas and camera using the provided callbacks to update visuals.\"\"\"\n    self._canvas = self._datoviz_renderer.get_canvas()\n    self._viewports = viewports\n    self._visuals = visuals\n    self._model_matrices = model_matrices\n    self._cameras = cameras\n    self._time_last_update = time.time()\n\n    # =============================================================================\n    # Render the image once\n    # =============================================================================\n\n    self._datoviz_renderer.render(viewports, visuals, model_matrices, cameras)\n\n    # =============================================================================\n    # Handle GSP_TEST=True\n    # =============================================================================\n\n    # detect if we are in not interactive mode - used during testing\n    in_test = \"GSP_TEST\" in os.environ and os.environ[\"GSP_TEST\"] == \"True\"\n\n    # if we are not in interactive mode, save a preview image and return\n    if in_test == True:\n        # notify all animator callbacks\n        changed_visuals: list[VisualBase] = []\n        for animator_callback in self._callbacks:\n            _changed_visuals = animator_callback(1.0 / self._fps)\n            changed_visuals.extend(_changed_visuals)\n\n        # render the scene to get the new image\n        image_png_data = self._datoviz_renderer.render(viewports, visuals, model_matrices, cameras, return_image=True, image_format=\"png\")\n        # get the main script name\n        main_script_name = os.path.basename(__main__.__file__) if hasattr(__main__, \"__file__\") else \"interactive\"\n        main_script_basename = os.path.splitext(main_script_name)[0]\n        # buid the output image path\n        image_path = os.path.join(__dirname__, \"../../../examples/output\", f\"{main_script_basename}_animator_datoviz.png\")\n        image_path = os.path.abspath(image_path)\n        # save image_png_data in a image file\n        with open(image_path, \"wb\") as image_file:\n            image_file.write(image_png_data)\n        # log the event\n        print(f\"Saved animation preview image to: {image_path}\")\n        return\n\n    # NOTE: here we are in interactive mode!!\n\n    # =============================================================================\n    # Initialize the animation\n    # =============================================================================\n\n    dvz_app = self._datoviz_renderer.get_dvz_app()\n\n    @dvz_app.timer(period=1.0 / self._fps)\n    def on_timer(event):\n        self._dvz_animate()\n\n    # =============================================================================\n    # Show the animation\n    # =============================================================================\n\n    self._datoviz_renderer.show()\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.animator.animator_datoviz.AnimatorDatoviz.stop","title":"<code>stop()</code>","text":"<p>Stop the animation.</p> Source code in <code>src/gsp_datoviz/animator/animator_datoviz.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the animation.\"\"\"\n    self._canvas = None\n    self._viewports = None\n    self._time_last_update = None\n\n    warning.warn(\"GspAnimatorDatoviz.stop() is not fully implemented yet.\")\n</code></pre>"},{"location":"api/gsp_extra/","title":"GSP Extra API Reference","text":"<p>The GSP Extra package provides additional utilities, helpers, and high-level components that extend the core GSP functionality, including animation, 3D object management, camera controls, and viewport event handling.</p>"},{"location":"api/gsp_extra/#overview","title":"Overview","text":""},{"location":"api/gsp_extra/#gsp_extra","title":"<code>gsp_extra</code>","text":""},{"location":"api/gsp_extra/#bufferx-module","title":"Bufferx Module","text":"<p>Extended buffer utilities with numpy integration.</p>"},{"location":"api/gsp_extra/#gsp_extra.bufferx","title":"<code>gsp_extra.bufferx</code>","text":"<p>Bufferx extra module re-exporting Bufferx from gsp_matplotlib.extra.bufferx.</p>"},{"location":"api/gsp_extra/#object3d-module","title":"Object3D Module","text":"<p>3D object management with transformations, visuals, and cameras.</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d","title":"<code>gsp_extra.object3d</code>","text":"<p>Object3D class for managing 3D objects, their transformations, visuals, and cameras.</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D","title":"<code>Object3D</code>","text":"<p>Class representing a 3D object with transformation, visuals, and cameras.</p> Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>class Object3D:\n    \"\"\"Class representing a 3D object with transformation, visuals, and cameras.\"\"\"\n\n    def __init__(self, name: str | None = None):\n        \"\"\"Initialize the Object3D.\n\n        Args:\n            name (str | None): Optional name for the Object3D. If None, a default name is generated.\n        \"\"\"\n        self.uuid = UuidUtils.generate_uuid()\n        \"\"\"uuid of the visual being wrapped.\"\"\"\n\n        self.name: str = name if name is not None else f\"a {self.__class__.__name__} - {self.uuid}\"\n        \"\"\"name of this Object3D.\"\"\"\n\n        self.matrix_world: np.ndarray = np.eye(4, dtype=np.float32)\n        \"\"\"matrix world of this Object3D\"\"\"\n        self.matrix_local: np.ndarray = np.eye(4, dtype=np.float32)\n        \"\"\"matrix local of this Object3D\"\"\"\n\n        self.dont_update_matrix_world: bool = False\n        \"\"\"if True, the world matrix won't be updated.\"\"\"\n        self.dont_update_matrix_local: bool = False\n        \"\"\"if True, the local matrix won't be updated.\"\"\"\n\n        self.rotation_order: str = \"XYZ\"\n        \"\"\"rotation order for euler angles.\"\"\"\n        self.position: np.ndarray = np.zeros(3, dtype=np.float32)\n        \"\"\"position of this Object3D.\"\"\"\n        self.euler: np.ndarray = np.zeros(3, dtype=np.float32)\n        \"\"\"euler angles in radians of this Object3D.\"\"\"\n        self.scale: np.ndarray = np.ones(3, dtype=np.float32)\n        \"\"\"scale of this Object3D.\"\"\"\n\n        self.children: list[Object3D] = []\n        \"\"\"list of children Object3D.\"\"\"\n\n        self.visuals: list[VisualBase] = []\n        \"\"\"list of visuals attached to this Object3D.\"\"\"\n        self.cameras: list[Camera] = []\n        \"\"\"list of cameras attached to this Object3D.\"\"\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of the Object3D.\"\"\"\n        return f\"Object3D(name={self.name})\"\n\n    # =============================================================================\n    # .add/.remove\n    # =============================================================================\n\n    def add(self, child: \"Object3D\"):\n        \"\"\"Add a child Object3D to this Object3D.\n\n        Args:\n            child (Object3D): child to add.\n        \"\"\"\n        self.children.append(child)\n\n    def remove(self, child: \"Object3D\"):\n        \"\"\"Remove a child Object3D from this Object3D.\n\n        Args:\n            child (Object3D): child to remove.\n        \"\"\"\n        self.children.remove(child)\n\n    # =============================================================================\n    # .attach_visual/.detach_visual\n    # =============================================================================\n\n    def attach_visual(self, visual: VisualBase):\n        \"\"\"Add a visual to this Object3D.\n\n        Args:\n            visual (VisualBase): visual to add.\n        \"\"\"\n        self.visuals.append(visual)\n\n    def detach_visual(self, visual: VisualBase):\n        \"\"\"Remove a visual from this Object3D.\n\n        Args:\n            visual (VisualBase): visual to remove.\n        \"\"\"\n        self.visuals.remove(visual)\n\n    # =============================================================================\n    # .attach_camera/.detach_camera\n    # =============================================================================\n\n    def attach_camera(self, camera: Camera):\n        \"\"\"Add a camera to this Object3D.\n\n        Args:\n            camera (Camera): camera to add.\n        \"\"\"\n        self.cameras.append(camera)\n\n    def detach_camera(self, camera: Camera):\n        \"\"\"Remove a camera from this Object3D.\n\n        Args:\n            camera (Camera): camera to remove.\n        \"\"\"\n        self.cameras.remove(camera)\n\n    # =============================================================================\n    # .traverse\n    # =============================================================================\n\n    def traverse(self):\n        \"\"\"Generator to traverse the Object3D hierarchy.\"\"\"\n        yield self\n        for child in self.children:\n            yield from child.traverse()\n\n    # =============================================================================\n    # .update_matrix_*\n    # =============================================================================\n\n    def update_matrix_local(self, force_update: bool = False) -&gt; None:\n        \"\"\"Upload the local matrix from position, euler and scale.\n\n        Args:\n            force_update (bool): if True, forces the update even if dont_update_matrix_local is True. Defaults to False.\n        \"\"\"\n        # honor dont_update_matrix_local flag\n        if self.dont_update_matrix_local and not force_update:\n            return\n\n        # compute the scale matrix\n        scale_matrix = glm.scale(self.scale)\n\n        # compute the rotation matrix in the specified order\n        rotation_matrix = np.eye(4, dtype=np.float32)\n        for axis in self.rotation_order:\n            if axis == \"X\":\n                rotation_matrix = rotation_matrix @ glm.xrotate(self.euler[0] / np.pi * 180.0)\n            elif axis == \"Y\":\n                rotation_matrix = rotation_matrix @ glm.yrotate(self.euler[1] / np.pi * 180.0)\n            elif axis == \"Z\":\n                rotation_matrix = rotation_matrix @ glm.zrotate(self.euler[2] / np.pi * 180.0)\n\n        # compute the translation matrix\n        translation_matrix = glm.translate(self.position)\n\n        # set the local matrix\n        self.matrix_local = translation_matrix @ rotation_matrix @ scale_matrix\n\n    def update_matrix_world(self, parent_matrix_world: np.ndarray | None = None, force_update: bool = False) -&gt; None:\n        \"\"\"Compute the world matrix from the local matrix and the parent's world matrix.\n\n        Args:\n            parent_matrix_world (np.ndarray | None): parent's world matrix. Defaults to None.\n            force_update (bool): if True, forces the update even if dont_update_matrix_world is True. Defaults to False.\n        \"\"\"\n        # update local matrix\n        self.update_matrix_local(force_update=force_update)\n\n        # update world matrix - honor dont_update_matrix_world flag\n        if parent_matrix_world is None:\n            self.matrix_world = self.matrix_local\n        elif not self.dont_update_matrix_world or force_update:\n            self.matrix_world = parent_matrix_world @ self.matrix_local\n\n        # update children\n        for child in self.children:\n            child.update_matrix_world(self.matrix_world)\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    @staticmethod\n    def update_camera_view_matrices(scene: \"Object3D\") -&gt; None:\n        \"\"\"Update the view matrices of all cameras attached to the Object3D hierarchy.\n\n        Args:\n            scene (Object3D): root Object3D of the scene.\n        \"\"\"\n        for object3d in scene.traverse():\n            for camera in object3d.cameras:\n                view_matrix_numpy = np.linalg.inv(object3d.matrix_world)\n                view_matrix_buffer = Bufferx.from_numpy(np.array([view_matrix_numpy]), BufferType.mat4)\n                camera.set_view_matrix(view_matrix_buffer)\n\n    @staticmethod\n    def to_render_args(viewport: Viewport, scene: \"Object3D\", camera: Camera) -&gt; tuple[list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]:\n        \"\"\"Render the scene using the provided renderer.\n\n        Args:\n            viewport (Viewport): viewport to render to.\n            scene (Object3D): root Object3D of the scene.\n            camera (Camera): camera to use for rendering.\n\n        Returns:\n            tuple[list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]: viewports, visuals, model matrices and cameras.\n        \"\"\"\n        # gather all visuals, model matrices and cameras\n        visuals = [visual for object3d in scene.traverse() for visual in object3d.visuals]\n        model_matrices_numpy = [object3d.matrix_world for object3d in scene.traverse() for _ in object3d.visuals]\n        model_matrices_buffer = [Bufferx.from_numpy(np.array([model_matrix_numpy]), BufferType.mat4) for model_matrix_numpy in model_matrices_numpy]\n        model_matrices = [typing.cast(TransBuf, model_matrix_buffer) for model_matrix_buffer in model_matrices_buffer]\n        viewports = [viewport for _ in range(len(visuals))]\n        cameras = [camera for _ in range(len(visuals))]\n\n        return viewports, visuals, model_matrices, cameras\n\n    @staticmethod\n    def pre_render(viewport: Viewport, scene: \"Object3D\", camera: Camera) -&gt; tuple[list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]:\n        \"\"\"Prepare the scene for rendering by updating matrices and gathering render arguments.\n\n        Args:\n            viewport (Viewport): viewport to render to.\n            scene (Object3D): root Object3D of the scene.\n            camera (Camera): camera to use for rendering.\n\n        Returns:\n            tuple[list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]: viewports, visuals, model matrices and cameras.\n        \"\"\"\n        # update all world matrices\n        scene.update_matrix_world()\n\n        # update camera view matrices\n        Object3D.update_camera_view_matrices(scene)\n\n        # gather all visuals, model matrices and cameras\n        viewports, visuals, model_matrices_buffer, cameras = Object3D.to_render_args(viewport, scene, camera)\n\n        return viewports, visuals, model_matrices_buffer, cameras\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.cameras","title":"<code>cameras: list[Camera] = []</code>  <code>instance-attribute</code>","text":"<p>list of cameras attached to this Object3D.</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.children","title":"<code>children: list[Object3D] = []</code>  <code>instance-attribute</code>","text":"<p>list of children Object3D.</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.dont_update_matrix_local","title":"<code>dont_update_matrix_local: bool = False</code>  <code>instance-attribute</code>","text":"<p>if True, the local matrix won't be updated.</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.dont_update_matrix_world","title":"<code>dont_update_matrix_world: bool = False</code>  <code>instance-attribute</code>","text":"<p>if True, the world matrix won't be updated.</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.euler","title":"<code>euler: np.ndarray = np.zeros(3, dtype=(np.float32))</code>  <code>instance-attribute</code>","text":"<p>euler angles in radians of this Object3D.</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.matrix_local","title":"<code>matrix_local: np.ndarray = np.eye(4, dtype=(np.float32))</code>  <code>instance-attribute</code>","text":"<p>matrix local of this Object3D</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.matrix_world","title":"<code>matrix_world: np.ndarray = np.eye(4, dtype=(np.float32))</code>  <code>instance-attribute</code>","text":"<p>matrix world of this Object3D</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.name","title":"<code>name: str = name if name is not None else f'a {self.__class__.__name__} - {self.uuid}'</code>  <code>instance-attribute</code>","text":"<p>name of this Object3D.</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.position","title":"<code>position: np.ndarray = np.zeros(3, dtype=(np.float32))</code>  <code>instance-attribute</code>","text":"<p>position of this Object3D.</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.rotation_order","title":"<code>rotation_order: str = 'XYZ'</code>  <code>instance-attribute</code>","text":"<p>rotation order for euler angles.</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.scale","title":"<code>scale: np.ndarray = np.ones(3, dtype=(np.float32))</code>  <code>instance-attribute</code>","text":"<p>scale of this Object3D.</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.uuid","title":"<code>uuid = UuidUtils.generate_uuid()</code>  <code>instance-attribute</code>","text":"<p>uuid of the visual being wrapped.</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.visuals","title":"<code>visuals: list[VisualBase] = []</code>  <code>instance-attribute</code>","text":"<p>list of visuals attached to this Object3D.</p>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.__init__","title":"<code>__init__(name: str | None = None)</code>","text":"<p>Initialize the Object3D.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Optional name for the Object3D. If None, a default name is generated.</p> <code>None</code> Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>def __init__(self, name: str | None = None):\n    \"\"\"Initialize the Object3D.\n\n    Args:\n        name (str | None): Optional name for the Object3D. If None, a default name is generated.\n    \"\"\"\n    self.uuid = UuidUtils.generate_uuid()\n    \"\"\"uuid of the visual being wrapped.\"\"\"\n\n    self.name: str = name if name is not None else f\"a {self.__class__.__name__} - {self.uuid}\"\n    \"\"\"name of this Object3D.\"\"\"\n\n    self.matrix_world: np.ndarray = np.eye(4, dtype=np.float32)\n    \"\"\"matrix world of this Object3D\"\"\"\n    self.matrix_local: np.ndarray = np.eye(4, dtype=np.float32)\n    \"\"\"matrix local of this Object3D\"\"\"\n\n    self.dont_update_matrix_world: bool = False\n    \"\"\"if True, the world matrix won't be updated.\"\"\"\n    self.dont_update_matrix_local: bool = False\n    \"\"\"if True, the local matrix won't be updated.\"\"\"\n\n    self.rotation_order: str = \"XYZ\"\n    \"\"\"rotation order for euler angles.\"\"\"\n    self.position: np.ndarray = np.zeros(3, dtype=np.float32)\n    \"\"\"position of this Object3D.\"\"\"\n    self.euler: np.ndarray = np.zeros(3, dtype=np.float32)\n    \"\"\"euler angles in radians of this Object3D.\"\"\"\n    self.scale: np.ndarray = np.ones(3, dtype=np.float32)\n    \"\"\"scale of this Object3D.\"\"\"\n\n    self.children: list[Object3D] = []\n    \"\"\"list of children Object3D.\"\"\"\n\n    self.visuals: list[VisualBase] = []\n    \"\"\"list of visuals attached to this Object3D.\"\"\"\n    self.cameras: list[Camera] = []\n    \"\"\"list of cameras attached to this Object3D.\"\"\"\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>String representation of the Object3D.</p> Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation of the Object3D.\"\"\"\n    return f\"Object3D(name={self.name})\"\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.add","title":"<code>add(child: Object3D)</code>","text":"<p>Add a child Object3D to this Object3D.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>gsp_extra.object3d.Object3D</code> <p>child to add.</p> required Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>def add(self, child: \"Object3D\"):\n    \"\"\"Add a child Object3D to this Object3D.\n\n    Args:\n        child (Object3D): child to add.\n    \"\"\"\n    self.children.append(child)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.attach_camera","title":"<code>attach_camera(camera: Camera)</code>","text":"<p>Add a camera to this Object3D.</p> <p>Parameters:</p> Name Type Description Default <code>camera</code> <code>gsp.core.camera.Camera</code> <p>camera to add.</p> required Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>def attach_camera(self, camera: Camera):\n    \"\"\"Add a camera to this Object3D.\n\n    Args:\n        camera (Camera): camera to add.\n    \"\"\"\n    self.cameras.append(camera)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.attach_visual","title":"<code>attach_visual(visual: VisualBase)</code>","text":"<p>Add a visual to this Object3D.</p> <p>Parameters:</p> Name Type Description Default <code>visual</code> <code>gsp.types.visual_base.VisualBase</code> <p>visual to add.</p> required Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>def attach_visual(self, visual: VisualBase):\n    \"\"\"Add a visual to this Object3D.\n\n    Args:\n        visual (VisualBase): visual to add.\n    \"\"\"\n    self.visuals.append(visual)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.detach_camera","title":"<code>detach_camera(camera: Camera)</code>","text":"<p>Remove a camera from this Object3D.</p> <p>Parameters:</p> Name Type Description Default <code>camera</code> <code>gsp.core.camera.Camera</code> <p>camera to remove.</p> required Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>def detach_camera(self, camera: Camera):\n    \"\"\"Remove a camera from this Object3D.\n\n    Args:\n        camera (Camera): camera to remove.\n    \"\"\"\n    self.cameras.remove(camera)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.detach_visual","title":"<code>detach_visual(visual: VisualBase)</code>","text":"<p>Remove a visual from this Object3D.</p> <p>Parameters:</p> Name Type Description Default <code>visual</code> <code>gsp.types.visual_base.VisualBase</code> <p>visual to remove.</p> required Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>def detach_visual(self, visual: VisualBase):\n    \"\"\"Remove a visual from this Object3D.\n\n    Args:\n        visual (VisualBase): visual to remove.\n    \"\"\"\n    self.visuals.remove(visual)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.pre_render","title":"<code>pre_render(viewport: Viewport, scene: Object3D, camera: Camera) -&gt; tuple[list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]</code>  <code>staticmethod</code>","text":"<p>Prepare the scene for rendering by updating matrices and gathering render arguments.</p> <p>Parameters:</p> Name Type Description Default <code>viewport</code> <code>gsp.core.Viewport</code> <p>viewport to render to.</p> required <code>scene</code> <code>gsp_extra.object3d.Object3D</code> <p>root Object3D of the scene.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>camera to use for rendering.</p> required <p>Returns:</p> Type Description <code>tuple[list[gsp.core.Viewport], list[gsp.types.visual_base.VisualBase], list[gsp.types.transbuf.TransBuf], list[gsp.core.camera.Camera]]</code> <p>tuple[list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]: viewports, visuals, model matrices and cameras.</p> Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>@staticmethod\ndef pre_render(viewport: Viewport, scene: \"Object3D\", camera: Camera) -&gt; tuple[list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]:\n    \"\"\"Prepare the scene for rendering by updating matrices and gathering render arguments.\n\n    Args:\n        viewport (Viewport): viewport to render to.\n        scene (Object3D): root Object3D of the scene.\n        camera (Camera): camera to use for rendering.\n\n    Returns:\n        tuple[list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]: viewports, visuals, model matrices and cameras.\n    \"\"\"\n    # update all world matrices\n    scene.update_matrix_world()\n\n    # update camera view matrices\n    Object3D.update_camera_view_matrices(scene)\n\n    # gather all visuals, model matrices and cameras\n    viewports, visuals, model_matrices_buffer, cameras = Object3D.to_render_args(viewport, scene, camera)\n\n    return viewports, visuals, model_matrices_buffer, cameras\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.remove","title":"<code>remove(child: Object3D)</code>","text":"<p>Remove a child Object3D from this Object3D.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>gsp_extra.object3d.Object3D</code> <p>child to remove.</p> required Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>def remove(self, child: \"Object3D\"):\n    \"\"\"Remove a child Object3D from this Object3D.\n\n    Args:\n        child (Object3D): child to remove.\n    \"\"\"\n    self.children.remove(child)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.to_render_args","title":"<code>to_render_args(viewport: Viewport, scene: Object3D, camera: Camera) -&gt; tuple[list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]</code>  <code>staticmethod</code>","text":"<p>Render the scene using the provided renderer.</p> <p>Parameters:</p> Name Type Description Default <code>viewport</code> <code>gsp.core.Viewport</code> <p>viewport to render to.</p> required <code>scene</code> <code>gsp_extra.object3d.Object3D</code> <p>root Object3D of the scene.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>camera to use for rendering.</p> required <p>Returns:</p> Type Description <code>tuple[list[gsp.core.Viewport], list[gsp.types.visual_base.VisualBase], list[gsp.types.transbuf.TransBuf], list[gsp.core.camera.Camera]]</code> <p>tuple[list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]: viewports, visuals, model matrices and cameras.</p> Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>@staticmethod\ndef to_render_args(viewport: Viewport, scene: \"Object3D\", camera: Camera) -&gt; tuple[list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]:\n    \"\"\"Render the scene using the provided renderer.\n\n    Args:\n        viewport (Viewport): viewport to render to.\n        scene (Object3D): root Object3D of the scene.\n        camera (Camera): camera to use for rendering.\n\n    Returns:\n        tuple[list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]: viewports, visuals, model matrices and cameras.\n    \"\"\"\n    # gather all visuals, model matrices and cameras\n    visuals = [visual for object3d in scene.traverse() for visual in object3d.visuals]\n    model_matrices_numpy = [object3d.matrix_world for object3d in scene.traverse() for _ in object3d.visuals]\n    model_matrices_buffer = [Bufferx.from_numpy(np.array([model_matrix_numpy]), BufferType.mat4) for model_matrix_numpy in model_matrices_numpy]\n    model_matrices = [typing.cast(TransBuf, model_matrix_buffer) for model_matrix_buffer in model_matrices_buffer]\n    viewports = [viewport for _ in range(len(visuals))]\n    cameras = [camera for _ in range(len(visuals))]\n\n    return viewports, visuals, model_matrices, cameras\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.traverse","title":"<code>traverse()</code>","text":"<p>Generator to traverse the Object3D hierarchy.</p> Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>def traverse(self):\n    \"\"\"Generator to traverse the Object3D hierarchy.\"\"\"\n    yield self\n    for child in self.children:\n        yield from child.traverse()\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.update_camera_view_matrices","title":"<code>update_camera_view_matrices(scene: Object3D) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Update the view matrices of all cameras attached to the Object3D hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>scene</code> <code>gsp_extra.object3d.Object3D</code> <p>root Object3D of the scene.</p> required Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>@staticmethod\ndef update_camera_view_matrices(scene: \"Object3D\") -&gt; None:\n    \"\"\"Update the view matrices of all cameras attached to the Object3D hierarchy.\n\n    Args:\n        scene (Object3D): root Object3D of the scene.\n    \"\"\"\n    for object3d in scene.traverse():\n        for camera in object3d.cameras:\n            view_matrix_numpy = np.linalg.inv(object3d.matrix_world)\n            view_matrix_buffer = Bufferx.from_numpy(np.array([view_matrix_numpy]), BufferType.mat4)\n            camera.set_view_matrix(view_matrix_buffer)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.update_matrix_local","title":"<code>update_matrix_local(force_update: bool = False) -&gt; None</code>","text":"<p>Upload the local matrix from position, euler and scale.</p> <p>Parameters:</p> Name Type Description Default <code>force_update</code> <code>bool</code> <p>if True, forces the update even if dont_update_matrix_local is True. Defaults to False.</p> <code>False</code> Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>def update_matrix_local(self, force_update: bool = False) -&gt; None:\n    \"\"\"Upload the local matrix from position, euler and scale.\n\n    Args:\n        force_update (bool): if True, forces the update even if dont_update_matrix_local is True. Defaults to False.\n    \"\"\"\n    # honor dont_update_matrix_local flag\n    if self.dont_update_matrix_local and not force_update:\n        return\n\n    # compute the scale matrix\n    scale_matrix = glm.scale(self.scale)\n\n    # compute the rotation matrix in the specified order\n    rotation_matrix = np.eye(4, dtype=np.float32)\n    for axis in self.rotation_order:\n        if axis == \"X\":\n            rotation_matrix = rotation_matrix @ glm.xrotate(self.euler[0] / np.pi * 180.0)\n        elif axis == \"Y\":\n            rotation_matrix = rotation_matrix @ glm.yrotate(self.euler[1] / np.pi * 180.0)\n        elif axis == \"Z\":\n            rotation_matrix = rotation_matrix @ glm.zrotate(self.euler[2] / np.pi * 180.0)\n\n    # compute the translation matrix\n    translation_matrix = glm.translate(self.position)\n\n    # set the local matrix\n    self.matrix_local = translation_matrix @ rotation_matrix @ scale_matrix\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.object3d.Object3D.update_matrix_world","title":"<code>update_matrix_world(parent_matrix_world: np.ndarray | None = None, force_update: bool = False) -&gt; None</code>","text":"<p>Compute the world matrix from the local matrix and the parent's world matrix.</p> <p>Parameters:</p> Name Type Description Default <code>parent_matrix_world</code> <code>numpy.ndarray | None</code> <p>parent's world matrix. Defaults to None.</p> <code>None</code> <code>force_update</code> <code>bool</code> <p>if True, forces the update even if dont_update_matrix_world is True. Defaults to False.</p> <code>False</code> Source code in <code>src/gsp_extra/object3d.py</code> <pre><code>def update_matrix_world(self, parent_matrix_world: np.ndarray | None = None, force_update: bool = False) -&gt; None:\n    \"\"\"Compute the world matrix from the local matrix and the parent's world matrix.\n\n    Args:\n        parent_matrix_world (np.ndarray | None): parent's world matrix. Defaults to None.\n        force_update (bool): if True, forces the update even if dont_update_matrix_world is True. Defaults to False.\n    \"\"\"\n    # update local matrix\n    self.update_matrix_local(force_update=force_update)\n\n    # update world matrix - honor dont_update_matrix_world flag\n    if parent_matrix_world is None:\n        self.matrix_world = self.matrix_local\n    elif not self.dont_update_matrix_world or force_update:\n        self.matrix_world = parent_matrix_world @ self.matrix_local\n\n    # update children\n    for child in self.children:\n        child.update_matrix_world(self.matrix_world)\n</code></pre>"},{"location":"api/gsp_extra/#camera-controls-module","title":"Camera Controls Module","text":"<p>Camera control utilities for interactive 3D navigation.</p>"},{"location":"api/gsp_extra/#object-controls-awsd","title":"Object Controls AWSD","text":""},{"location":"api/gsp_extra/#gsp_extra.camera_controls.object_controls_awsd","title":"<code>gsp_extra.camera_controls.object_controls_awsd</code>","text":"<p>Implements camera controls using AWSD keys for movement and mouse for orientation.</p>"},{"location":"api/gsp_extra/#gsp_extra.camera_controls.object_controls_awsd.ObjectControlAwsd","title":"<code>ObjectControlAwsd</code>","text":"<p>Implements camera controls using AWSD keys for movement and mouse for orientation.</p> Source code in <code>src/gsp_extra/camera_controls/object_controls_awsd.py</code> <pre><code>class ObjectControlAwsd:\n    \"\"\"Implements camera controls using AWSD keys for movement and mouse for orientation.\"\"\"\n\n    def __init__(self, model_matrix_buffer: Buffer, viewport_events: ViewportEventsBase):\n        \"\"\"Initialize the ObjectControlAwsd.\n\n        Args:\n            model_matrix_buffer (Buffer): The buffer containing the model matrix to control.\n            viewport_events (ViewportEventsBase): The viewport events to subscribe to for keyboard input.\n        \"\"\"\n        # sanity checks\n        assert model_matrix_buffer.get_type() == BufferType.mat4, \"model_matrix must be of type mat4\"\n        assert model_matrix_buffer.get_count() == 1, \"model_matrix must have a count of 1\"\n\n        # copy arguments\n        self._model_matrix_buffer = model_matrix_buffer\n        self._model_matrix_numpy = Bufferx.to_numpy(self._model_matrix_buffer)[0]\n        self._viewport_events = viewport_events\n        self._speed_x = 0.1\n        self._speed_z = 0.1\n\n        # Subscribe to keyboard and mouse events\n        self._viewport_events.key_press_event.subscribe(self._on_key_event)\n        self._viewport_events.key_release_event.subscribe(self._on_key_event)\n\n    def close(self):\n        \"\"\"Unsubscribe from events.\"\"\"\n        self._viewport_events.key_press_event.unsubscribe(self._on_key_event)\n        self._viewport_events.key_release_event.unsubscribe(self._on_key_event)\n\n    def _on_key_event(self, key_event: KeyEvent):\n        print(f\"ObjectControlAwsd: key_event: {key_event}\")\n        if key_event.event_type == EventType.KEY_PRESS:\n            translate_vector = np.array([0, 0, 0], dtype=np.float32)\n\n            if key_event.key_name == \"w\":\n                translate_vector[2] -= self._speed_z\n            elif key_event.key_name == \"s\":\n                translate_vector[2] += self._speed_z\n            elif key_event.key_name == \"a\":\n                translate_vector[0] -= self._speed_x\n            elif key_event.key_name == \"d\":\n                translate_vector[0] += self._speed_x\n\n            # generate translate matrix\n            translate_matrix = glm.translate(translate_vector)\n            # update model_matrix_numpy\n            self._model_matrix_numpy = np.matmul(translate_matrix, self._model_matrix_numpy)\n            # update model_matrix_buffer\n            self._model_matrix_buffer.set_data(bytearray(self._model_matrix_numpy.tobytes()), 0, 1)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.camera_controls.object_controls_awsd.ObjectControlAwsd.__init__","title":"<code>__init__(model_matrix_buffer: Buffer, viewport_events: ViewportEventsBase)</code>","text":"<p>Initialize the ObjectControlAwsd.</p> <p>Parameters:</p> Name Type Description Default <code>model_matrix_buffer</code> <code>gsp.types.buffer.Buffer</code> <p>The buffer containing the model matrix to control.</p> required <code>viewport_events</code> <code>gsp.types.viewport_events_base.ViewportEventsBase</code> <p>The viewport events to subscribe to for keyboard input.</p> required Source code in <code>src/gsp_extra/camera_controls/object_controls_awsd.py</code> <pre><code>def __init__(self, model_matrix_buffer: Buffer, viewport_events: ViewportEventsBase):\n    \"\"\"Initialize the ObjectControlAwsd.\n\n    Args:\n        model_matrix_buffer (Buffer): The buffer containing the model matrix to control.\n        viewport_events (ViewportEventsBase): The viewport events to subscribe to for keyboard input.\n    \"\"\"\n    # sanity checks\n    assert model_matrix_buffer.get_type() == BufferType.mat4, \"model_matrix must be of type mat4\"\n    assert model_matrix_buffer.get_count() == 1, \"model_matrix must have a count of 1\"\n\n    # copy arguments\n    self._model_matrix_buffer = model_matrix_buffer\n    self._model_matrix_numpy = Bufferx.to_numpy(self._model_matrix_buffer)[0]\n    self._viewport_events = viewport_events\n    self._speed_x = 0.1\n    self._speed_z = 0.1\n\n    # Subscribe to keyboard and mouse events\n    self._viewport_events.key_press_event.subscribe(self._on_key_event)\n    self._viewport_events.key_release_event.subscribe(self._on_key_event)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.camera_controls.object_controls_awsd.ObjectControlAwsd.close","title":"<code>close()</code>","text":"<p>Unsubscribe from events.</p> Source code in <code>src/gsp_extra/camera_controls/object_controls_awsd.py</code> <pre><code>def close(self):\n    \"\"\"Unsubscribe from events.\"\"\"\n    self._viewport_events.key_press_event.unsubscribe(self._on_key_event)\n    self._viewport_events.key_release_event.unsubscribe(self._on_key_event)\n</code></pre>"},{"location":"api/gsp_extra/#object-controls-trackball","title":"Object Controls Trackball","text":""},{"location":"api/gsp_extra/#gsp_extra.camera_controls.object_controls_trackball","title":"<code>gsp_extra.camera_controls.object_controls_trackball</code>","text":"<p>Implements camera controls using AWSD keys for movement and mouse for orientation.</p>"},{"location":"api/gsp_extra/#gsp_extra.camera_controls.object_controls_trackball.ObjectControlsTrackball","title":"<code>ObjectControlsTrackball</code>","text":"<p>Implements camera controls using AWSD keys for movement and mouse for orientation.</p> Source code in <code>src/gsp_extra/camera_controls/object_controls_trackball.py</code> <pre><code>class ObjectControlsTrackball:\n    \"\"\"Implements camera controls using AWSD keys for movement and mouse for orientation.\"\"\"\n\n    def __init__(self, model_matrix_buffer: Buffer, viewport_events: ViewportEventsBase):\n        \"\"\"Initialize the ObjectControlsTrackball.\n\n        Args:\n            model_matrix_buffer (Buffer): The buffer containing the model matrix to control.\n            viewport_events (ViewportEventsBase): The viewport events to subscribe to for mouse input.\n        \"\"\"\n        # sanity checks\n        assert model_matrix_buffer.get_type() == BufferType.mat4, \"model_matrix must be of type mat4\"\n        assert model_matrix_buffer.get_count() == 1, \"model_matrix must have a count of 1\"\n\n        # copy arguments\n        self._model_matrix_buffer = model_matrix_buffer\n        self._model_matrix_numpy: np.ndarray = Bufferx.to_numpy(self._model_matrix_buffer)[0]\n        self._viewport_events = viewport_events\n        self._button_pressed: bool = False\n        self._trackball = Trackball()\n\n        self._start_x: float = 0.0\n        self._start_y: float = 0.0\n\n        # Subscribe to keyboard and mouse events\n        self._viewport_events.button_press_event.subscribe(self._on_button_press)\n        self._viewport_events.button_release_event.subscribe(self._on_button_release)\n        self._viewport_events.mouse_move_event.subscribe(self._on_mouse_move)\n\n    def close(self):\n        \"\"\"Unsubscribe from events.\"\"\"\n        self._viewport_events.button_press_event.unsubscribe(self._on_button_press)\n        self._viewport_events.button_release_event.unsubscribe(self._on_button_release)\n        self._viewport_events.mouse_move_event.unsubscribe(self._on_mouse_move)\n\n    def _on_button_press(self, mouse_event: MouseEvent):\n        self._button_pressed = True\n        self._start_x = mouse_event.x_ndc\n        self._start_y = mouse_event.y_ndc\n\n    def _on_button_release(self, mouse_event: MouseEvent):\n        self._button_pressed = False\n\n    def _on_mouse_move(self, mouse_event: MouseEvent):\n        # ignore if no button is pressed\n        if self._button_pressed is False:\n            return\n\n        dx = mouse_event.x_ndc - self._start_x\n        dy = mouse_event.y_ndc - self._start_y\n        self._trackball.drag_to(self._start_x, self._start_y, dx, dy)\n        self._start_x = mouse_event.x_ndc\n        self._start_y = mouse_event.y_ndc\n        # update the model matrix\n        np.copyto(self._model_matrix_numpy, self._trackball.model.T)\n        self._model_matrix_buffer.set_data(bytearray(self._model_matrix_numpy.tobytes()), 0, 1)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.camera_controls.object_controls_trackball.ObjectControlsTrackball.__init__","title":"<code>__init__(model_matrix_buffer: Buffer, viewport_events: ViewportEventsBase)</code>","text":"<p>Initialize the ObjectControlsTrackball.</p> <p>Parameters:</p> Name Type Description Default <code>model_matrix_buffer</code> <code>gsp.types.buffer.Buffer</code> <p>The buffer containing the model matrix to control.</p> required <code>viewport_events</code> <code>gsp.types.viewport_events_base.ViewportEventsBase</code> <p>The viewport events to subscribe to for mouse input.</p> required Source code in <code>src/gsp_extra/camera_controls/object_controls_trackball.py</code> <pre><code>def __init__(self, model_matrix_buffer: Buffer, viewport_events: ViewportEventsBase):\n    \"\"\"Initialize the ObjectControlsTrackball.\n\n    Args:\n        model_matrix_buffer (Buffer): The buffer containing the model matrix to control.\n        viewport_events (ViewportEventsBase): The viewport events to subscribe to for mouse input.\n    \"\"\"\n    # sanity checks\n    assert model_matrix_buffer.get_type() == BufferType.mat4, \"model_matrix must be of type mat4\"\n    assert model_matrix_buffer.get_count() == 1, \"model_matrix must have a count of 1\"\n\n    # copy arguments\n    self._model_matrix_buffer = model_matrix_buffer\n    self._model_matrix_numpy: np.ndarray = Bufferx.to_numpy(self._model_matrix_buffer)[0]\n    self._viewport_events = viewport_events\n    self._button_pressed: bool = False\n    self._trackball = Trackball()\n\n    self._start_x: float = 0.0\n    self._start_y: float = 0.0\n\n    # Subscribe to keyboard and mouse events\n    self._viewport_events.button_press_event.subscribe(self._on_button_press)\n    self._viewport_events.button_release_event.subscribe(self._on_button_release)\n    self._viewport_events.mouse_move_event.subscribe(self._on_mouse_move)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.camera_controls.object_controls_trackball.ObjectControlsTrackball.close","title":"<code>close()</code>","text":"<p>Unsubscribe from events.</p> Source code in <code>src/gsp_extra/camera_controls/object_controls_trackball.py</code> <pre><code>def close(self):\n    \"\"\"Unsubscribe from events.\"\"\"\n    self._viewport_events.button_press_event.unsubscribe(self._on_button_press)\n    self._viewport_events.button_release_event.unsubscribe(self._on_button_release)\n    self._viewport_events.mouse_move_event.unsubscribe(self._on_mouse_move)\n</code></pre>"},{"location":"api/gsp_extra/#miscellaneous-module","title":"Miscellaneous Module","text":"<p>Various utility helpers and render item definitions.</p>"},{"location":"api/gsp_extra/#render-item","title":"Render Item","text":""},{"location":"api/gsp_extra/#gsp_extra.misc.render_item","title":"<code>gsp_extra.misc.render_item</code>","text":"<p>Render item definition.</p>"},{"location":"api/gsp_extra/#gsp_extra.misc.render_item.RenderItem","title":"<code>RenderItem</code>  <code>dataclass</code>","text":"<p>Render item is a dataclasss containing all necessary information for rendering a visual in a viewport.</p> Source code in <code>src/gsp_extra/misc/render_item.py</code> <pre><code>@dataclass\nclass RenderItem:\n    \"\"\"Render item is a dataclasss containing all necessary information for rendering a visual in a viewport.\"\"\"\n\n    viewport: Viewport\n    \"\"\"Viewport where the visual will be rendered.\"\"\"\n    visual_base: VisualBase\n    \"\"\"Visual to be rendered.\"\"\"\n    model_matrix: Buffer\n    \"\"\"Model matrix for transforming the visual.\"\"\"\n    camera: Camera\n    \"\"\"Camera used for rendering the visual.\"\"\"\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.misc.render_item.RenderItem.camera","title":"<code>camera: Camera</code>  <code>instance-attribute</code>","text":"<p>Camera used for rendering the visual.</p>"},{"location":"api/gsp_extra/#gsp_extra.misc.render_item.RenderItem.model_matrix","title":"<code>model_matrix: Buffer</code>  <code>instance-attribute</code>","text":"<p>Model matrix for transforming the visual.</p>"},{"location":"api/gsp_extra/#gsp_extra.misc.render_item.RenderItem.viewport","title":"<code>viewport: Viewport</code>  <code>instance-attribute</code>","text":"<p>Viewport where the visual will be rendered.</p>"},{"location":"api/gsp_extra/#gsp_extra.misc.render_item.RenderItem.visual_base","title":"<code>visual_base: VisualBase</code>  <code>instance-attribute</code>","text":"<p>Visual to be rendered.</p>"},{"location":"api/gsp_extra/#colorama-utils","title":"Colorama Utils","text":""},{"location":"api/gsp_extra/#gsp_extra.misc.colorama_utils","title":"<code>gsp_extra.misc.colorama_utils</code>","text":"<p>Colorama utility functions.</p>"},{"location":"api/gsp_extra/#gsp_extra.misc.colorama_utils.text_cyan","title":"<code>text_cyan(text: str) -&gt; str</code>","text":"<p>Return the given text string colored in cyan.</p> Source code in <code>src/gsp_extra/misc/colorama_utils.py</code> <pre><code>def text_cyan(text: str) -&gt; str:\n    \"\"\"Return the given text string colored in cyan.\"\"\"\n    return colorama.Fore.CYAN + text + colorama.Style.RESET_ALL\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.misc.colorama_utils.text_magenta","title":"<code>text_magenta(text: str) -&gt; str</code>","text":"<p>Return the given text string colored in magenta.</p> Source code in <code>src/gsp_extra/misc/colorama_utils.py</code> <pre><code>def text_magenta(text: str) -&gt; str:\n    \"\"\"Return the given text string colored in magenta.\"\"\"\n    return colorama.Fore.MAGENTA + text + colorama.Style.RESET_ALL\n</code></pre>"},{"location":"api/gsp_extra/#mpl3d-module","title":"MPL3D Module","text":"<p>3D mathematics utilities for graphics operations.</p>"},{"location":"api/gsp_extra/#glm","title":"GLM","text":""},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm","title":"<code>gsp_extra.mpl3d.glm</code>","text":"<p>OpenGL Mathematics (GLM) utilities for numpy.</p> <p>This module provides mathematical functions commonly used in 3D graphics, including matrix transformations, projections, rotations, and vector operations. All operations are implemented using numpy for efficient computation.</p>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.align","title":"<code>align(U: np.ndarray, V: np.ndarray, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray</code>","text":"<p>Return the rotation matrix that aligns vector U to vector V.</p> <p>Parameters:</p> Name Type Description Default <code>U</code> <code>numpy.ndarray</code> <p>First vector</p> required <code>V</code> <code>numpy.ndarray</code> <p>Second vector</p> required <code>dtype</code> <code>numpy.dtype</code> <p>dtype of the resulting array</p> <code>numpy.dtype(numpy.float32)</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Rotation matrix</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def align(U: np.ndarray, V: np.ndarray, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray:\n    \"\"\"Return the rotation matrix that aligns vector U to vector V.\n\n    Args:\n        U (np.ndarray): First vector\n        V (np.ndarray): Second vector\n        dtype (np.dtype): dtype of the resulting array\n\n    Returns:\n        np.ndarray: Rotation matrix\n    \"\"\"\n    a, b = normalize(U), normalize(V)\n    v = np.cross(a, b)\n    c = np.dot(a, b)\n    s = np.linalg.norm(v)\n    K = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])\n    R = np.zeros((4, 4), dtype=dtype)\n    R[:3, :3] = np.eye(3) + K + K @ K * ((1 - c) / (s**2))\n    R[3, 3] = 1\n\n    return R\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.camera","title":"<code>camera(xrotation: float = 25.0, yrotation: float = 45.0, zoom: float = 1.0, mode: Literal['perspective', 'ortho'] = 'perspective') -&gt; np.ndarray</code>","text":"<p>Create a camera transformation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>xrotation</code> <code>float</code> <p>Rotation around the X axis in degrees.</p> <code>25.0</code> <code>yrotation</code> <code>float</code> <p>Rotation around the Y axis in degrees.</p> <code>45.0</code> <code>zoom</code> <code>float</code> <p>Zoom factor.</p> <code>1.0</code> <code>mode</code> <code>typing.Literal['perspective', 'ortho']</code> <p>Camera mode.</p> <code>'perspective'</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Camera matrix</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown camera mode is provided.</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def camera(xrotation: float = 25.0, yrotation: float = 45.0, zoom: float = 1.0, mode: Literal[\"perspective\", \"ortho\"] = \"perspective\") -&gt; np.ndarray:\n    \"\"\"Create a camera transformation matrix.\n\n    Args:\n        xrotation (float): Rotation around the X axis in degrees.\n        yrotation (float): Rotation around the Y axis in degrees.\n        zoom (float): Zoom factor.\n        mode (Literal[\"perspective\", \"ortho\"]): Camera mode.\n\n    Returns:\n        np.ndarray: Camera matrix\n\n    Raises:\n        ValueError: If an unknown camera mode is provided.\n    \"\"\"\n    xrotation = min(max(xrotation, 0), 90)\n    yrotation = min(max(yrotation, 0), 90)\n    zoom = max(0.1, zoom)\n    scale_vector = np.array([zoom, zoom, zoom], dtype=np.float32)\n    model = scale(scale_vector) @ xrotate(xrotation) @ yrotate(yrotation)\n    translate_vector = np.array([0, 0, -4.5], dtype=np.float32)\n    view = translate(translate_vector)\n    if mode == \"ortho\":\n        proj = ortho(-1, +1, -1, +1, 1, 100)\n    elif mode == \"perspective\":\n        proj = perspective(25, 1, 1, 100)\n    else:\n        raise ValueError(\"Unknown camera mode: \" + mode)\n    return proj @ view @ model\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.center","title":"<code>center(vertices: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Center vertices around the origin.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>numpy.ndarray</code> <p>Vertices to center</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: vertices centered</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def center(vertices: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Center vertices around the origin.\n\n    Args:\n        vertices (np.ndarray): Vertices to center\n\n    Returns:\n        np.ndarray: vertices centered\n    \"\"\"\n    vmin = vertices.min(axis=0)\n    vmax = vertices.max(axis=0)\n    return vertices - (vmax + vmin) / 2\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.clamp","title":"<code>clamp(V: np.ndarray, vmin: float = 0, vmax: float = 1) -&gt; np.ndarray</code>","text":"<p>Clamp values between minimum and maximum bounds.</p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>numpy.ndarray</code> <p>Array of values to clamp.</p> required <code>vmin</code> <code>float</code> <p>Minimum value (default: 0).</p> <code>0</code> <code>vmax</code> <code>float</code> <p>Maximum value (default: 1).</p> <code>1</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Array with values clamped to [vmin, vmax].</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def clamp(V: np.ndarray, vmin: float = 0, vmax: float = 1) -&gt; np.ndarray:\n    \"\"\"Clamp values between minimum and maximum bounds.\n\n    Args:\n        V: Array of values to clamp.\n        vmin: Minimum value (default: 0).\n        vmax: Maximum value (default: 1).\n\n    Returns:\n        Array with values clamped to [vmin, vmax].\n    \"\"\"\n    return np.minimum(np.maximum(V, vmin), vmax)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.fit","title":"<code>fit(vertices: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Fit vertices to the normalized cube.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>numpy.ndarray</code> <p>Vertices to fit</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: vertices contained in the normalize cube</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def fit(vertices: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Fit vertices to the normalized cube.\n\n    Args:\n        vertices (np.ndarray): Vertices to fit\n\n    Returns:\n        np.ndarray: vertices contained in the normalize cube\n    \"\"\"\n    Vmin = vertices.min(axis=0)\n    Vmax = vertices.max(axis=0)\n    # return 2*(vertices-vmin) / max(vmax-vmin)-1\n    V = 2 * (vertices - Vmin) / max(Vmax - Vmin) - 1\n    return V - (V.min(axis=0) + V.max(axis=0)) / 2\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.frontback","title":"<code>frontback(triangles: np.ndarray) -&gt; tuple[np.ndarray, np.ndarray]</code>","text":"<p>Sort front and back facing triangles.</p> <p>Parameters:</p> Name Type Description Default <code>triangles</code> <code>numpy.ndarray</code> <p>Triangles to sort</p> required <p>Returns:</p> Type Description <code>tuple[numpy.ndarray, numpy.ndarray]</code> <p>tuple[np.ndarray, np.ndarray]: front and back facing triangles as (n1,3) and (n2,3) arrays (n1+n2=n)</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def frontback(triangles: np.ndarray) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Sort front and back facing triangles.\n\n    Args:\n        triangles (np.ndarray): Triangles to sort\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: front and back facing triangles as (n1,3) and (n2,3) arrays (n1+n2=n)\n    \"\"\"\n    Z = (\n        (triangles[:, 1, 0] - triangles[:, 0, 0]) * (triangles[:, 1, 1] + triangles[:, 0, 1])\n        + (triangles[:, 2, 0] - triangles[:, 1, 0]) * (triangles[:, 2, 1] + triangles[:, 1, 1])\n        + (triangles[:, 0, 0] - triangles[:, 2, 0]) * (triangles[:, 0, 1] + triangles[:, 2, 1])\n    )\n    return Z &lt; 0, Z &gt;= 0\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.frustum","title":"<code>frustum(left: float, right: float, bottom: float, top: float, znear: float, zfar: float, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray</code>","text":"<p>Create a view frustum projection matrix.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>float</code> <p>Left coordinate of the field of view.</p> required <code>right</code> <code>float</code> <p>Right coordinate of the field of view.</p> required <code>bottom</code> <code>float</code> <p>Bottom coordinate of the field of view.</p> required <code>top</code> <code>float</code> <p>Top coordinate of the field of view.</p> required <code>znear</code> <code>float</code> <p>Near coordinate of the field of view.</p> required <code>zfar</code> <code>float</code> <p>Far coordinate of the field of view.</p> required <code>dtype</code> <code>numpy.dtype</code> <p>dtype of the resulting array</p> <code>numpy.dtype(numpy.float32)</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: View frustum matrix</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def frustum(\n    left: float,\n    right: float,\n    bottom: float,\n    top: float,\n    znear: float,\n    zfar: float,\n    dtype: np.dtype = np.dtype(np.float32),\n) -&gt; np.ndarray:\n    r\"\"\"Create a view frustum projection matrix.\n\n    Args:\n        left (float): Left coordinate of the field of view.\n        right (float): Right coordinate of the field of view.\n        bottom (float): Bottom coordinate of the field of view.\n        top (float): Top coordinate of the field of view.\n        znear (float): Near coordinate of the field of view.\n        zfar (float): Far coordinate of the field of view.\n        dtype (np.dtype): dtype of the resulting array\n\n    Returns:\n        np.ndarray: View frustum matrix\n    \"\"\"\n    M = np.zeros((4, 4), dtype=dtype)\n    M[0, 0] = +2.0 * znear / (right - left)\n    M[1, 1] = +2.0 * znear / (top - bottom)\n    M[2, 2] = -(zfar + znear) / (zfar - znear)\n    M[0, 2] = (right + left) / (right - left)\n    M[2, 1] = (top + bottom) / (top - bottom)\n    M[2, 3] = -2.0 * znear * zfar / (zfar - znear)\n    M[3, 2] = -1.0\n\n    return M\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.lookat","title":"<code>lookat(eye: tuple[float, float, float] = (0, 0, 4.5), center: tuple[float, float, float] = (0, 0, 0), up: tuple[float, float, float] = (0, 0, 1), dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray</code>","text":"<p>Create a viewing matrix derived from an eye point, reference point, and up vector.</p> <p>Parameters:</p> Name Type Description Default <code>eye</code> <code>tuple[float, float, float]</code> <p>Eye point</p> <code>(0, 0, 4.5)</code> <code>center</code> <code>tuple[float, float, float]</code> <p>Reference point</p> <code>(0, 0, 0)</code> <code>up</code> <code>tuple[float, float, float]</code> <p>Up vector</p> <code>(0, 0, 1)</code> <code>dtype</code> <code>numpy.dtype</code> <p>dtype of the resulting array</p> <code>numpy.dtype(numpy.float32)</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: View matrix</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def lookat(\n    eye: tuple[float, float, float] = (0, 0, 4.5),\n    center: tuple[float, float, float] = (0, 0, 0),\n    up: tuple[float, float, float] = (0, 0, 1),\n    dtype: np.dtype = np.dtype(np.float32),\n) -&gt; np.ndarray:\n    \"\"\"Create a viewing matrix derived from an eye point, reference point, and up vector.\n\n    Args:\n        eye (tuple[float, float, float]): Eye point\n        center (tuple[float, float, float]): Reference point\n        up (tuple[float, float, float]): Up vector\n        dtype (np.dtype): dtype of the resulting array\n\n    Returns:\n        np.ndarray: View matrix\n    \"\"\"\n    eye_np = np.array(eye)\n    center_np = np.array(center)\n    up_np = np.array(up)\n\n    Z = normalize(eye_np - center_np)\n    Y = up_np\n    X = normalize(np.cross(Y, Z))\n    Y = normalize(np.cross(Z, X))\n    return np.array(\n        [\n            [X[0], X[1], X[2], -np.dot(X, eye_np)],\n            [Y[0], Y[1], Y[2], -np.dot(Y, eye_np)],\n            [Z[0], Z[1], Z[2], -np.dot(Z, eye_np)],\n            [0, 0, 0, 1],\n        ],\n        dtype=dtype,\n    )\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.normalize","title":"<code>normalize(V: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Normalize a vector or array of vectors to unit length.</p> <p>Parameters:</p> Name Type Description Default <code>V</code> <code>numpy.ndarray</code> <p>Vector or array of vectors to normalize.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>Normalized vector(s) with unit length.</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def normalize(V: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Normalize a vector or array of vectors to unit length.\n\n    Args:\n        V: Vector or array of vectors to normalize.\n\n    Returns:\n        Normalized vector(s) with unit length.\n    \"\"\"\n    return V / (1e-16 + np.sqrt((np.array(V) ** 2).sum(axis=-1)))[..., np.newaxis]\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.ortho","title":"<code>ortho(left: float, right: float, bottom: float, top: float, znear: float, zfar: float, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray</code>","text":"<p>Create an orthographic projection matrix.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>float</code> <p>Left coordinate of the field of view.</p> required <code>right</code> <code>float</code> <p>Right coordinate of the field of view.</p> required <code>bottom</code> <code>float</code> <p>Bottom coordinate of the field of view.</p> required <code>top</code> <code>float</code> <p>Top coordinate of the field of view.</p> required <code>znear</code> <code>float</code> <p>Near coordinate of the field of view.</p> required <code>zfar</code> <code>float</code> <p>Far coordinate of the field of view.</p> required <code>dtype</code> <code>numpy.dtype</code> <p>dtype of the resulting array</p> <code>numpy.dtype(numpy.float32)</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Orthographic projection matrix</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def ortho(left: float, right: float, bottom: float, top: float, znear: float, zfar: float, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray:\n    \"\"\"Create an orthographic projection matrix.\n\n    Args:\n        left (float): Left coordinate of the field of view.\n        right (float): Right coordinate of the field of view.\n        bottom (float): Bottom coordinate of the field of view.\n        top (float): Top coordinate of the field of view.\n        znear (float): Near coordinate of the field of view.\n        zfar (float): Far coordinate of the field of view.\n        dtype (np.dtype): dtype of the resulting array\n\n    Returns:\n        np.ndarray: Orthographic projection matrix\n    \"\"\"\n    M = np.zeros((4, 4), dtype=dtype)\n    M[0, 0] = +2.0 / (right - left)\n    M[1, 1] = +2.0 / (top - bottom)\n    M[2, 2] = -2.0 / (zfar - znear)\n    M[3, 3] = 1.0\n    M[0, 2] = -(right + left) / float(right - left)\n    M[1, 3] = -(top + bottom) / float(top - bottom)\n    M[2, 3] = -(zfar + znear) / float(zfar - znear)\n\n    return M\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.perspective","title":"<code>perspective(fovy: float, aspect: float, znear: float, zfar: float, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray</code>","text":"<p>Create a perspective projection matrix.</p> <p>Parameters:</p> Name Type Description Default <code>fovy</code> <code>float</code> <p>The field of view along the y axis.</p> required <code>aspect</code> <code>float</code> <p>Aspect ratio of the view.</p> required <code>znear</code> <code>float</code> <p>Near coordinate of the field of view.</p> required <code>zfar</code> <code>float</code> <p>Far coordinate of the field of view.</p> required <code>dtype</code> <code>numpy.dtype</code> <p>dtype of the resulting array</p> <code>numpy.dtype(numpy.float32)</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Perspective projection matrix</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def perspective(\n    fovy: float,\n    aspect: float,\n    znear: float,\n    zfar: float,\n    dtype: np.dtype = np.dtype(np.float32),\n) -&gt; np.ndarray:\n    \"\"\"Create a perspective projection matrix.\n\n    Args:\n        fovy (float): The field of view along the y axis.\n        aspect (float): Aspect ratio of the view.\n        znear (float): Near coordinate of the field of view.\n        zfar (float): Far coordinate of the field of view.\n        dtype (np.dtype): dtype of the resulting array\n\n    Returns:\n        np.ndarray: Perspective projection matrix\n    \"\"\"\n    h = np.tan(0.5 * np.radians(fovy)) * znear\n    w = h * aspect\n    return frustum(-w, w, -h, h, znear, zfar, dtype)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.rotate","title":"<code>rotate(angle: float, axis: np.ndarray, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray</code>","text":"<p>Create a rotation matrix around an arbitrary axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Specifies the angle of rotation, in degrees.</p> required <code>axis</code> <code>numpy.ndarray</code> <p>Axis of rotation</p> required <code>dtype</code> <code>numpy.dtype</code> <p>dtype of the resulting array</p> <code>numpy.dtype(numpy.float32)</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Rotation matrix</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def rotate(angle: float, axis: np.ndarray, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray:\n    \"\"\"Create a rotation matrix around an arbitrary axis.\n\n    Args:\n        angle (float): Specifies the angle of rotation, in degrees.\n        axis (np.ndarray): Axis of rotation\n        dtype (np.dtype): dtype of the resulting array\n\n    Returns:\n        np.ndarray: Rotation matrix\n    \"\"\"\n    t = np.radians(angle)\n\n    axis = normalize(np.array(axis))\n    a = np.cos(t / 2)\n    b, c, d = -axis * np.sin(t / 2)\n    aa, bb, cc, dd = a * a, b * b, c * c, d * d\n    bc, ad, ac, ab, bd, cd = b * c, a * d, a * c, a * b, b * d, c * d\n    R = np.array(\n        [\n            [aa + bb - cc - dd, 2 * (bc + ad), 2 * (bd - ac), 0],\n            [2 * (bc - ad), aa + cc - bb - dd, 2 * (cd + ab), 0],\n            [2 * (bd + ac), 2 * (cd - ab), aa + dd - bb - cc, 0],\n            [0, 0, 0, 1],\n        ],\n        dtype=dtype,\n    )\n\n    return R\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.scale","title":"<code>scale(scale: np.ndarray, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray</code>","text":"<p>Create a non-uniform scaling matrix along the x, y, and z axes.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>numpy.ndarray</code> <p>Scaling vector</p> required <code>dtype</code> <code>numpy.dtype</code> <p>dtype of the resulting array</p> <code>numpy.dtype(numpy.float32)</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Scaling matrix</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def scale(scale: np.ndarray, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray:\n    \"\"\"Create a non-uniform scaling matrix along the x, y, and z axes.\n\n    Args:\n        scale (np.ndarray): Scaling vector\n        dtype (np.dtype): dtype of the resulting array\n\n    Returns:\n        np.ndarray: Scaling matrix\n    \"\"\"\n    x, y, z = np.array(scale)\n    S = np.array(\n        [\n            [x, 0, 0, 0],\n            [0, y, 0, 0],\n            [0, 0, z, 0],\n            [0, 0, 0, 1],\n        ],\n        dtype=dtype,\n    )\n\n    return S\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.translate","title":"<code>translate(translate: np.ndarray, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray</code>","text":"<p>Create a translation matrix by a given vector.</p> <p>Parameters:</p> Name Type Description Default <code>translate</code> <code>numpy.ndarray</code> <p>Translation vector.</p> required <code>dtype</code> <code>numpy.dtype</code> <p>dtype of the resulting array</p> <code>numpy.dtype(numpy.float32)</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Translation matrix</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def translate(translate: np.ndarray, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray:\n    \"\"\"Create a translation matrix by a given vector.\n\n    Args:\n        translate (np.ndarray): Translation vector.\n        dtype (np.dtype): dtype of the resulting array\n\n    Returns:\n        np.ndarray: Translation matrix\n    \"\"\"\n    x, y, z = np.array(translate)\n    T = np.array([[1, 0, 0, x], [0, 1, 0, y], [0, 0, 1, z], [0, 0, 0, 1]], dtype=dtype)\n\n    return T\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.viewport","title":"<code>viewport(x: int, y: int, w: int, h: int, d: float, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray</code>","text":"<p>Create a viewport transformation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>X origin (pixels) of the viewport (lower left)</p> required <code>y</code> <code>int</code> <p>Y origin (pixels) of the viewport (lower left)</p> required <code>w</code> <code>int</code> <p>Width (pixels) of the viewport</p> required <code>h</code> <code>int</code> <p>Height (pixels) of the viewport</p> required <code>d</code> <code>float</code> <p>Depth of the viewport.</p> required <code>dtype</code> <code>numpy.dtype</code> <p>dtype of the resulting array</p> <code>numpy.dtype(numpy.float32)</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Viewport matrix</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def viewport(x: int, y: int, w: int, h: int, d: float, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray:\n    \"\"\"Create a viewport transformation matrix.\n\n    Args:\n        x (int): X origin (pixels) of the viewport (lower left)\n        y (int): Y origin (pixels) of the viewport (lower left)\n        w (int): Width (pixels) of the viewport\n        h (int): Height (pixels) of the viewport\n        d (float): Depth of the viewport.\n        dtype (np.dtype): dtype of the resulting array\n\n    Returns:\n        np.ndarray: Viewport matrix\n    \"\"\"\n    M = np.array(\n        [\n            [w / 2, 0, 0, x + w / 2],\n            [0, h / 2, 0, y + h / 2],\n            [0, 0, d / 2, d / 2],\n            [0, 0, 0, 1],\n        ],\n        dtype=dtype,\n    )\n    return M\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.xrotate","title":"<code>xrotate(angle_x: float = 0.0, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray</code>","text":"<p>Create a rotation matrix about the X axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle_x</code> <code>float</code> <p>Specifies the angle of rotation, in degrees.</p> <code>0.0</code> <code>dtype</code> <code>numpy.dtype</code> <p>dtype of the resulting array</p> <code>numpy.dtype(numpy.float32)</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Rotation matrix</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def xrotate(angle_x: float = 0.0, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray:\n    \"\"\"Create a rotation matrix about the X axis.\n\n    Args:\n        angle_x (float):\n            Specifies the angle of rotation, in degrees.\n        dtype (np.dtype):\n            dtype of the resulting array\n\n    Returns:\n       np.ndarray: Rotation matrix\n    \"\"\"\n    t = np.radians(angle_x)\n    c, s = np.cos(t), np.sin(t)\n    R = np.array([[1, 0, 0, 0], [0, c, -s, 0], [0, s, c, 0], [0, 0, 0, 1]], dtype=dtype)\n\n    return R\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.yrotate","title":"<code>yrotate(angle_y: float = 0.0, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray</code>","text":"<p>Create a rotation matrix about the Y axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle_y</code> <code>float</code> <p>Specifies the angle of rotation, in degrees.</p> <code>0.0</code> <code>dtype</code> <code>numpy.dtype</code> <p>dtype of the resulting array</p> <code>numpy.dtype(numpy.float32)</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Rotation matrix</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def yrotate(angle_y: float = 0.0, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray:\n    \"\"\"Create a rotation matrix about the Y axis.\n\n    Args:\n        angle_y (float): Specifies the angle of rotation, in degrees.\n        dtype (np.dtype): dtype of the resulting array\n\n    Returns:\n        np.ndarray: Rotation matrix\n    \"\"\"\n    t = np.radians(angle_y)\n    c, s = np.cos(t), np.sin(t)\n    R = np.array([[c, 0, s, 0], [0, 1, 0, 0], [-s, 0, c, 0], [0, 0, 0, 1]], dtype=dtype)\n\n    return R\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.glm.zrotate","title":"<code>zrotate(angle_z: float = 0.0, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray</code>","text":"<p>Create a rotation matrix about the Z axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle_z</code> <code>float</code> <p>Specifies the angle of rotation, in degrees.</p> <code>0.0</code> <code>dtype</code> <code>numpy.dtype</code> <p>dtype of the resulting array</p> <code>numpy.dtype(numpy.float32)</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Rotation matrix</p> Source code in <code>src/gsp_extra/mpl3d/glm.py</code> <pre><code>def zrotate(angle_z: float = 0.0, dtype: np.dtype = np.dtype(np.float32)) -&gt; np.ndarray:\n    \"\"\"Create a rotation matrix about the Z axis.\n\n    Args:\n        angle_z (float): Specifies the angle of rotation, in degrees.\n        dtype (np.dtype): dtype of the resulting array\n\n    Returns:\n        np.ndarray: Rotation matrix\n    \"\"\"\n    t = np.radians(angle_z)\n    c, s = np.cos(t), np.sin(t)\n    R = np.array([[c, -s, 0, 0], [s, c, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], dtype=dtype)\n\n    return R\n</code></pre>"},{"location":"api/gsp_extra/#trackball","title":"Trackball","text":""},{"location":"api/gsp_extra/#gsp_extra.mpl3d.trackball","title":"<code>gsp_extra.mpl3d.trackball</code>","text":"<p>Provides a virtual trackball for 3D scene viewing.</p> <p>Example usage:</p> <p>trackball = Trackball(45,30)</p> <p>@window.event    def on_mouse_drag(x, y, dx, dy, button):        trackball.drag(x,y,dx,dy)</p> <p>@window.event    def on_resize(width,height):        glViewport(0, 0, window.width, window.height)        glMatrixMode(GL_PROJECTION)        glLoadIdentity()        gluPerspective(45, window.width / float(window.height), .1, 1000)        glMatrixMode (GL_MODELVIEW)        glLoadIdentity ()        glTranslatef (0, 0, -3)        glMultMatrixf(trackball.model)</p> <p>You can also set trackball orientation directly by setting theta and phi value expressed in degrees. Theta relates to the rotation angle around X axis while phi relates to the rotation angle around Z axis.</p>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.trackball.Trackball","title":"<code>Trackball</code>","text":"<p>               Bases: <code>object</code></p> <p>Virtual trackball for 3D scene viewing.</p> Source code in <code>src/gsp_extra/mpl3d/trackball.py</code> <pre><code>class Trackball(object):\n    \"\"\"Virtual trackball for 3D scene viewing.\"\"\"\n\n    def __init__(self, theta: float = 0, phi: float = 0):\n        \"\"\"Build a new trackball with specified view.\n\n        Args:\n            theta: Initial rotation angle around the X axis in degrees.\n            phi: Initial rotation angle around the Z axis in degrees.\n        \"\"\"\n        self._rotation = [0, 0, 0, 1]\n        self._count = 0\n        self._model = np.zeros((4, 4), float)\n        self._RENORMCOUNT = 97\n        self._TRACKBALLSIZE = 0.8\n        self._set_orientation(theta, phi)\n\n    def drag_to(self, x: float, y: float, dx: float, dy: float):\n        \"\"\"Move trackball view from x,y to x+dx,y+dy.\n\n        Updates the trackball rotation based on mouse drag movement.\n\n        Args:\n            x: Current x position in normalized coordinates [-1, 1].\n            y: Current y position in normalized coordinates [-1, 1].\n            dx: Change in x position.\n            dy: Change in y position.\n        \"\"\"\n        q = self._rotate(x, y, dx, dy)\n        self._rotation = _q_add(q, self._rotation)\n        self._count += 1\n        if self._count &gt; self._RENORMCOUNT:\n            self._rotation = _q_normalize(self._rotation)\n            self._count = 0\n        self._model = _q_rotmatrix(self._rotation)\n\n    @property\n    def model(self) -&gt; np.ndarray:\n        \"\"\"Model transformation (read-only).\n\n        Returns:\n            The current model transformation matrix as a 4x4 numpy array.\n        \"\"\"\n        return self._model\n\n    @property\n    def theta(self):\n        \"\"\"Angle (in degrees) around the z axis.\"\"\"\n        self._theta, _ = self._get_orientation()\n        return self._theta\n\n    @theta.setter\n    def theta(self, theta: float):\n        self._set_orientation(math.fmod(theta, 360.0), math.fmod(self._phi, 360.0))\n\n    @property\n    def phi(self):\n        \"\"\"Angle (in degrees) around the x axis.\"\"\"\n        _, self._phi = self._get_orientation()\n        return self._phi\n\n    @phi.setter\n    def phi(self, phi: float):\n        self._set_orientation(math.fmod(self._theta, 360.0), math.fmod(phi, 360.0))\n\n    def _get_orientation(self):\n        \"\"\"Return current computed orientation (theta,phi).\"\"\"\n        q0, q1, q2, q3 = self._rotation\n        ax = math.atan(2 * (q0 * q1 + q2 * q3) / (1 - 2 * (q1 * q1 + q2 * q2))) * 180.0 / math.pi\n        az = math.atan(2 * (q0 * q3 + q1 * q2) / (1 - 2 * (q2 * q2 + q3 * q3))) * 180.0 / math.pi\n        return -az, ax\n\n    def _set_orientation(self, theta: float, phi: float):\n        \"\"\"Computes rotation corresponding to theta and phi.\"\"\"\n        self._theta = theta\n        self._phi = phi\n        angle = self._theta * (math.pi / 180.0)\n        sine = math.sin(0.5 * angle)\n        xrot = [1 * sine, 0, 0, math.cos(0.5 * angle)]\n        angle = self._phi * (math.pi / 180.0)\n        sine = math.sin(0.5 * angle)\n        zrot = [0, 0, sine, math.cos(0.5 * angle)]\n        self._rotation = _q_add(xrot, zrot)\n        self._model = _q_rotmatrix(self._rotation)\n\n    def _project(self, r: float, x: float, y: float):\n        \"\"\"Project an x,y pair onto a sphere of radius r or a hyperbolic sheet.\n\n        Projects onto a hyperbolic sheet if we are away from the center of the sphere.\n\n        Args:\n            r: Sphere radius.\n            x: X coordinate.\n            y: Y coordinate.\n\n        Returns:\n            The z coordinate of the projection.\n        \"\"\"\n        d = math.sqrt(x * x + y * y)\n        if d &lt; r * 0.70710678118654752440:  # Inside sphere\n            z = math.sqrt(r * r - d * d)\n        else:  # On hyperbola\n            t = r / 1.41421356237309504880\n            z = t * t / d\n        return z\n\n    def _rotate(self, x: float, y: float, dx: float, dy: float):\n        \"\"\"Simulate a track-ball.\n\n        Project the points onto the virtual trackball, then figure out the\n        axis of rotation, which is the cross product of x,y and x+dx,y+dy.\n\n        Note: This is a deformed trackball-- this is a trackball in the\n        center, but is deformed into a hyperbolic sheet of rotation away\n        from the center.  This particular function was chosen after trying\n        out several variations.\n\n        Args:\n            x: Current x position.\n            y: Current y position.\n            dx: Change in x position.\n            dy: Change in y position.\n        \"\"\"\n        if not dx and not dy:\n            return [0.0, 0.0, 0.0, 1.0]\n        last = [x, y, self._project(self._TRACKBALLSIZE, x, y)]\n        new = [x + dx, y + dy, self._project(self._TRACKBALLSIZE, x + dx, y + dy)]\n        a = _v_cross(new, last)\n        d = _v_sub(last, new)\n        t = _v_length(d) / (2.0 * self._TRACKBALLSIZE)\n        if t &gt; 1.0:\n            t = 1.0\n        if t &lt; -1.0:\n            t = -1.0\n        phi = 2.0 * math.asin(t)\n        return _q_from_axis_angle(a, phi)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.trackball.Trackball.model","title":"<code>model: np.ndarray</code>  <code>property</code>","text":"<p>Model transformation (read-only).</p> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>The current model transformation matrix as a 4x4 numpy array.</p>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.trackball.Trackball.phi","title":"<code>phi</code>  <code>property</code> <code>writable</code>","text":"<p>Angle (in degrees) around the x axis.</p>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.trackball.Trackball.theta","title":"<code>theta</code>  <code>property</code> <code>writable</code>","text":"<p>Angle (in degrees) around the z axis.</p>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.trackball.Trackball.__init__","title":"<code>__init__(theta: float = 0, phi: float = 0)</code>","text":"<p>Build a new trackball with specified view.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Initial rotation angle around the X axis in degrees.</p> <code>0</code> <code>phi</code> <code>float</code> <p>Initial rotation angle around the Z axis in degrees.</p> <code>0</code> Source code in <code>src/gsp_extra/mpl3d/trackball.py</code> <pre><code>def __init__(self, theta: float = 0, phi: float = 0):\n    \"\"\"Build a new trackball with specified view.\n\n    Args:\n        theta: Initial rotation angle around the X axis in degrees.\n        phi: Initial rotation angle around the Z axis in degrees.\n    \"\"\"\n    self._rotation = [0, 0, 0, 1]\n    self._count = 0\n    self._model = np.zeros((4, 4), float)\n    self._RENORMCOUNT = 97\n    self._TRACKBALLSIZE = 0.8\n    self._set_orientation(theta, phi)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.mpl3d.trackball.Trackball.drag_to","title":"<code>drag_to(x: float, y: float, dx: float, dy: float)</code>","text":"<p>Move trackball view from x,y to x+dx,y+dy.</p> <p>Updates the trackball rotation based on mouse drag movement.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Current x position in normalized coordinates [-1, 1].</p> required <code>y</code> <code>float</code> <p>Current y position in normalized coordinates [-1, 1].</p> required <code>dx</code> <code>float</code> <p>Change in x position.</p> required <code>dy</code> <code>float</code> <p>Change in y position.</p> required Source code in <code>src/gsp_extra/mpl3d/trackball.py</code> <pre><code>def drag_to(self, x: float, y: float, dx: float, dy: float):\n    \"\"\"Move trackball view from x,y to x+dx,y+dy.\n\n    Updates the trackball rotation based on mouse drag movement.\n\n    Args:\n        x: Current x position in normalized coordinates [-1, 1].\n        y: Current y position in normalized coordinates [-1, 1].\n        dx: Change in x position.\n        dy: Change in y position.\n    \"\"\"\n    q = self._rotate(x, y, dx, dy)\n    self._rotation = _q_add(q, self._rotation)\n    self._count += 1\n    if self._count &gt; self._RENORMCOUNT:\n        self._rotation = _q_normalize(self._rotation)\n        self._count = 0\n    self._model = _q_rotmatrix(self._rotation)\n</code></pre>"},{"location":"api/gsp_extra/#transform-links-module","title":"Transform Links Module","text":"<p>Transform link utilities for loading and network operations.</p>"},{"location":"api/gsp_extra/#gsp_extra.transform_links","title":"<code>gsp_extra.transform_links</code>","text":"<p>\"TransformLink that loads data from a URI into a Buffer.</p>"},{"location":"api/gsp_extra/#transform-load","title":"Transform Load","text":""},{"location":"api/gsp_extra/#gsp_extra.transform_links.transform_load","title":"<code>gsp_extra.transform_links.transform_load</code>","text":"<p>TransformLink that loads data from a URI into a Buffer.</p>"},{"location":"api/gsp_extra/#gsp_extra.transform_links.transform_load.TransformLoad","title":"<code>TransformLoad</code>","text":"<p>               Bases: <code>gsp.transforms.transform_link_base.TransformLinkBase</code></p> <p>Load data from a URI into a Buffer. previous buffer is ignored.</p> Source code in <code>src/gsp_extra/transform_links/transform_load.py</code> <pre><code>class TransformLoad(TransformLinkBase):\n    \"\"\"Load data from a URI into a Buffer. previous buffer is ignored.\"\"\"\n\n    __slots__ = [\"_uri\", \"_buffer_type\"]\n\n    def __init__(self, uri: str, buffer_type: BufferType) -&gt; None:\n        \"\"\"Initialize the TransformLoad.\n\n        Args:\n            uri (str): The URI to load data from.\n            buffer_type (BufferType): The type of buffer to create.\n        \"\"\"\n        self._uri = uri\n        self._buffer_type = buffer_type\n\n    def apply(self, buffer_src: Buffer | None) -&gt; Buffer:\n        \"\"\"Load data from the URI into a new Buffer.\n\n        Args:\n            buffer_src (Buffer | None): Ignored.\n\n        Returns:\n            Buffer: The loaded buffer.\n        \"\"\"\n        item_size = BufferType.get_item_size(self._buffer_type)\n\n        is_image = os.path.splitext(self._uri)[1].lower() in [\".png\", \".jpg\", \".jpeg\", \".bmp\", \".tiff\"]\n        is_npy = os.path.splitext(self._uri)[1].lower() in [\".npy\"]\n        if is_npy:\n            # If the URI points to a .npy file, use numpy to load it\n\n            # 1. Create a session object\n            requests_session = requests.Session()\n            # 2. Mount the FileAdapter for the 'file://' scheme\n            requests_session.mount(\"file://\", requests_file.FileAdapter())\n\n            # Load numpy array\n            response = requests_session.get(self._uri)\n\n            response.raise_for_status()\n            array = np.load(BytesIO(response.content))\n\n            # sanity check\n            assert array.nbytes % item_size == 0, f\"Numpy array data size {array.nbytes} is not aligned with buffer type item size {item_size}\"\n\n            # Build a new buffer\n            count = array.nbytes // item_size\n            new_buffer = Buffer(count, self._buffer_type)\n            new_buffer.set_data(bytearray(array.tobytes()), 0, count)\n            return new_buffer\n        elif is_image:\n            # If the URI points to an image, use imageio to load it\n\n            # Load image data\n            image_data = imageio.v3.imread(self._uri)\n\n            # sanity check\n            assert image_data.nbytes % item_size == 0, f\"Image data size {image_data.nbytes} is not aligned with buffer type item size {item_size}\"\n\n            # Build a new buffer\n            count = image_data.nbytes // item_size\n            new_buffer = Buffer(count, self._buffer_type)\n            new_buffer.set_data(bytearray(image_data.tobytes()), 0, count)\n            return new_buffer\n        else:\n            # Load data from URI\n            response = requests.get(self._uri)\n            response.raise_for_status()\n            content = response.content\n\n            # sanity check\n            assert len(content) % item_size == 0, f\"Data size {len(content)} is not a multiple of item size {item_size} for buffer type {self._buffer_type}\"\n\n            count = len(content) // item_size\n            new_buffer = Buffer(count, self._buffer_type)\n            new_buffer.set_data(bytearray(content), 0, count)\n            return new_buffer\n\n    # =============================================================================\n    # Serialization functions\n    # =============================================================================\n\n    def serialize(self) -&gt; dict[str, Any]:\n        \"\"\"Serialize the TransformLoad to a dictionary.\n\n        Returns:\n            dict[str, Any]: The serialized TransformLoad.\n        \"\"\"\n        return {\n            \"link_type\": \"TransformLoad\",\n            \"link_data\": {\n                \"uri\": self._uri,\n                \"buffer_type\": self._buffer_type.name,\n            },\n        }\n\n    @staticmethod\n    def deserialize(data: dict[str, Any]) -&gt; \"TransformLoad\":\n        \"\"\"Deserialize a TransformLoad from a dictionary.\n\n        Args:\n            data (dict[str, Any]): The serialized TransformLoad.\n\n        Returns:\n            TransformLoad: The deserialized TransformLoad instance.\n        \"\"\"\n        assert data[\"link_type\"] == \"TransformLoad\", \"Invalid type for TransformLoad deserialization\"\n        uri: str = data[\"link_data\"][\"uri\"]\n        buffer_type_str: str = data[\"link_data\"][\"buffer_type\"]\n        buffer_type = BufferType[buffer_type_str]\n        return TransformLoad(uri, buffer_type)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.transform_links.transform_load.TransformLoad.__init__","title":"<code>__init__(uri: str, buffer_type: BufferType) -&gt; None</code>","text":"<p>Initialize the TransformLoad.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The URI to load data from.</p> required <code>buffer_type</code> <code>gsp.types.buffer_type.BufferType</code> <p>The type of buffer to create.</p> required Source code in <code>src/gsp_extra/transform_links/transform_load.py</code> <pre><code>def __init__(self, uri: str, buffer_type: BufferType) -&gt; None:\n    \"\"\"Initialize the TransformLoad.\n\n    Args:\n        uri (str): The URI to load data from.\n        buffer_type (BufferType): The type of buffer to create.\n    \"\"\"\n    self._uri = uri\n    self._buffer_type = buffer_type\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.transform_links.transform_load.TransformLoad.apply","title":"<code>apply(buffer_src: Buffer | None) -&gt; Buffer</code>","text":"<p>Load data from the URI into a new Buffer.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_src</code> <code>gsp.types.buffer.Buffer | None</code> <p>Ignored.</p> required <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.buffer.Buffer</code> <p>The loaded buffer.</p> Source code in <code>src/gsp_extra/transform_links/transform_load.py</code> <pre><code>def apply(self, buffer_src: Buffer | None) -&gt; Buffer:\n    \"\"\"Load data from the URI into a new Buffer.\n\n    Args:\n        buffer_src (Buffer | None): Ignored.\n\n    Returns:\n        Buffer: The loaded buffer.\n    \"\"\"\n    item_size = BufferType.get_item_size(self._buffer_type)\n\n    is_image = os.path.splitext(self._uri)[1].lower() in [\".png\", \".jpg\", \".jpeg\", \".bmp\", \".tiff\"]\n    is_npy = os.path.splitext(self._uri)[1].lower() in [\".npy\"]\n    if is_npy:\n        # If the URI points to a .npy file, use numpy to load it\n\n        # 1. Create a session object\n        requests_session = requests.Session()\n        # 2. Mount the FileAdapter for the 'file://' scheme\n        requests_session.mount(\"file://\", requests_file.FileAdapter())\n\n        # Load numpy array\n        response = requests_session.get(self._uri)\n\n        response.raise_for_status()\n        array = np.load(BytesIO(response.content))\n\n        # sanity check\n        assert array.nbytes % item_size == 0, f\"Numpy array data size {array.nbytes} is not aligned with buffer type item size {item_size}\"\n\n        # Build a new buffer\n        count = array.nbytes // item_size\n        new_buffer = Buffer(count, self._buffer_type)\n        new_buffer.set_data(bytearray(array.tobytes()), 0, count)\n        return new_buffer\n    elif is_image:\n        # If the URI points to an image, use imageio to load it\n\n        # Load image data\n        image_data = imageio.v3.imread(self._uri)\n\n        # sanity check\n        assert image_data.nbytes % item_size == 0, f\"Image data size {image_data.nbytes} is not aligned with buffer type item size {item_size}\"\n\n        # Build a new buffer\n        count = image_data.nbytes // item_size\n        new_buffer = Buffer(count, self._buffer_type)\n        new_buffer.set_data(bytearray(image_data.tobytes()), 0, count)\n        return new_buffer\n    else:\n        # Load data from URI\n        response = requests.get(self._uri)\n        response.raise_for_status()\n        content = response.content\n\n        # sanity check\n        assert len(content) % item_size == 0, f\"Data size {len(content)} is not a multiple of item size {item_size} for buffer type {self._buffer_type}\"\n\n        count = len(content) // item_size\n        new_buffer = Buffer(count, self._buffer_type)\n        new_buffer.set_data(bytearray(content), 0, count)\n        return new_buffer\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.transform_links.transform_load.TransformLoad.deserialize","title":"<code>deserialize(data: dict[str, Any]) -&gt; TransformLoad</code>  <code>staticmethod</code>","text":"<p>Deserialize a TransformLoad from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, typing.Any]</code> <p>The serialized TransformLoad.</p> required <p>Returns:</p> Name Type Description <code>TransformLoad</code> <code>gsp_extra.transform_links.transform_load.TransformLoad</code> <p>The deserialized TransformLoad instance.</p> Source code in <code>src/gsp_extra/transform_links/transform_load.py</code> <pre><code>@staticmethod\ndef deserialize(data: dict[str, Any]) -&gt; \"TransformLoad\":\n    \"\"\"Deserialize a TransformLoad from a dictionary.\n\n    Args:\n        data (dict[str, Any]): The serialized TransformLoad.\n\n    Returns:\n        TransformLoad: The deserialized TransformLoad instance.\n    \"\"\"\n    assert data[\"link_type\"] == \"TransformLoad\", \"Invalid type for TransformLoad deserialization\"\n    uri: str = data[\"link_data\"][\"uri\"]\n    buffer_type_str: str = data[\"link_data\"][\"buffer_type\"]\n    buffer_type = BufferType[buffer_type_str]\n    return TransformLoad(uri, buffer_type)\n</code></pre>"},{"location":"api/gsp_extra/#gsp_extra.transform_links.transform_load.TransformLoad.serialize","title":"<code>serialize() -&gt; dict[str, Any]</code>","text":"<p>Serialize the TransformLoad to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>dict[str, Any]: The serialized TransformLoad.</p> Source code in <code>src/gsp_extra/transform_links/transform_load.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n    \"\"\"Serialize the TransformLoad to a dictionary.\n\n    Returns:\n        dict[str, Any]: The serialized TransformLoad.\n    \"\"\"\n    return {\n        \"link_type\": \"TransformLoad\",\n        \"link_data\": {\n            \"uri\": self._uri,\n            \"buffer_type\": self._buffer_type.name,\n        },\n    }\n</code></pre>"},{"location":"api/gsp_extra/#transform-network-server","title":"Transform Network Server","text":""},{"location":"api/gsp_extra/#gsp_extra.transform_links.transform_network_server","title":"<code>gsp_extra.transform_links.transform_network_server</code>","text":"<p>Starts a network server with user-space transforms registered.</p>"},{"location":"api/gsp_matplotlib/","title":"GSP Matplotlib API Reference","text":"<p>The GSP Matplotlib backend provides rendering using the Matplotlib library, enabling integration with the Python scientific visualization ecosystem.</p>"},{"location":"api/gsp_matplotlib/#overview","title":"Overview","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib","title":"<code>gsp_matplotlib</code>","text":"<p>GSP Matplotlib package initialization.</p>"},{"location":"api/gsp_matplotlib/#renderer-module","title":"Renderer Module","text":"<p>The renderer module contains the main Matplotlib renderer implementation and specialized renderers for different visual types.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer","title":"<code>gsp_matplotlib.renderer</code>","text":"<p>Matplotlib Renderer Package.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer","title":"<code>MatplotlibRenderer</code>","text":"<p>               Bases: <code>gsp.types.renderer_base.RendererBase</code></p> <p>Matplotlib-based renderer for GSP visuals.</p> <p>This renderer implements the GSP rendering interface using Matplotlib as the backend. It creates and manages a Matplotlib figure with multiple axes for different viewports, and renders various visual types (pixels, points, paths, markers, segments, texts) into them.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>class MatplotlibRenderer(RendererBase):\n    \"\"\"Matplotlib-based renderer for GSP visuals.\n\n    This renderer implements the GSP rendering interface using Matplotlib as the backend.\n    It creates and manages a Matplotlib figure with multiple axes for different viewports,\n    and renders various visual types (pixels, points, paths, markers, segments, texts) into them.\n    \"\"\"\n\n    def __init__(self, canvas: Canvas):\n        \"\"\"Initialize the Matplotlib renderer.\n\n        Args:\n            canvas: The canvas defining the rendering surface dimensions and DPI.\n        \"\"\"\n        self.canvas = canvas\n        # Store mapping of viewport UUIDs to axes\n        self._axes: dict[str, matplotlib.axes.Axes] = {}\n        # Store mapping of visual UUIDs to matplotlib artists\n        self._artists: dict[str, matplotlib.artist.Artist] = {}\n        # Store group count per visual UUID\n        self._group_count: dict[str, int] = {}\n\n        # Create a figure\n        figure_width = canvas.get_width() / canvas.get_dpi()\n        figure_height = canvas.get_height() / canvas.get_dpi()\n        self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=canvas.get_dpi())\n        assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n        self._figure.canvas.manager.set_window_title(\"Matplotlib\")\n\n    def get_canvas(self) -&gt; Canvas:\n        \"\"\"Get the canvas associated with this renderer.\n\n        Returns:\n            The canvas instance.\n        \"\"\"\n        return self.canvas\n\n    def close(self) -&gt; None:\n        \"\"\"Close the renderer and release resources.\n\n        Stops the Matplotlib event loop and closes the figure.\n        \"\"\"\n        # warnings.warn(f\"Closing NetworkRenderer does not release any resources.\", UserWarning)\n        # stop the event loop if any - thus .show(block=True) will return\n        self._figure.canvas.stop_event_loop()\n        # close the figure\n        matplotlib.pyplot.close(self._figure)\n        self._figure = None  # type: ignore\n\n    def show(self) -&gt; None:\n        \"\"\"Display the rendered figure in an interactive window.\n\n        This method shows the Matplotlib figure. It does nothing when running\n        in test mode (GSP_TEST environment variable set to \"True\").\n        \"\"\"\n        # handle non-interactive mode for tests\n        in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n        if in_test:\n            return\n\n        matplotlib.pyplot.show()\n\n    def render(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n        return_image: bool = True,\n        image_format: str = \"png\",\n    ) -&gt; bytes:\n        \"\"\"Render the scene to an image.\n\n        Args:\n            viewports: Sequence of viewport regions to render into.\n            visuals: Sequence of visual elements to render.\n            model_matrices: Sequence of model transformation matrices for each visual.\n            cameras: Sequence of cameras defining view and projection for each visual.\n            return_image: Whether to return the rendered image as bytes.\n            image_format: Format for the output image (e.g., \"png\", \"jpg\").\n\n        Returns:\n            The rendered image as bytes in the specified format, or empty bytes if return_image is False.\n\n        Raises:\n            AssertionError: If the sequences don't all have the same length.\n        \"\"\"\n        # =============================================================================\n        # Sanity checks\n        # =============================================================================\n\n        assert (\n            len(viewports) == len(visuals) == len(model_matrices) == len(cameras)\n        ), f\"All length MUST be equal. Mismatched lengths: {len(viewports)} viewports, {len(visuals)} visuals, {len(model_matrices)} model matrices, {len(cameras)} cameras\"\n\n        # =============================================================================\n        # Create all the axes if needed\n        # =============================================================================\n        for viewport in viewports:\n            if viewport.get_uuid() in self._axes:\n                continue\n            axes_rect = (\n                viewport.get_x() / self.canvas.get_width(),\n                viewport.get_y() / self.canvas.get_height(),\n                viewport.get_width() / self.canvas.get_width(),\n                viewport.get_height() / self.canvas.get_height(),\n            )\n            axes: matplotlib.axes.Axes = matplotlib.pyplot.axes(axes_rect)\n            # this should be -1 to 1 - from normalized device coordinates - https://en.wikipedia.org/wiki/Graphics_pipeline\n            # - https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection\n            axes.set_xlim(-1, 1)\n            axes.set_ylim(-1, 1)\n            # hide the borders\n            axes.axis(\"off\")\n            # store axes for this viewport\n            self._axes[viewport.get_uuid()] = axes\n\n        # =============================================================================\n        # Render each visual\n        # =============================================================================\n\n        for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n            self._render_visual(viewport, visual, model_matrix, camera)\n\n        # =============================================================================\n        # Render the output image\n        # =============================================================================\n        image_png_data = b\"\"\n\n        # honor return_image option\n        if return_image:\n            # Render the image to a PNG buffer\n            image_png_buffer = io.BytesIO()\n            self._figure.savefig(image_png_buffer, format=image_format, dpi=self.canvas.get_dpi())\n\n            image_png_buffer.seek(0)\n            image_png_data = image_png_buffer.getvalue()\n            image_png_buffer.close()\n\n        return image_png_data\n\n    def _render_visual(self, viewport: Viewport, visual: VisualBase, model_matrix: TransBuf, camera: Camera):\n        \"\"\"Render a single visual in a given viewport using the specified camera.\"\"\"\n        if isinstance(visual, Image):\n            from gsp_matplotlib.renderer.matplotlib_renderer_image import RendererImage\n\n            RendererImage.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Pixels):\n            from gsp_matplotlib.renderer.matplotlib_renderer_pixels import RendererPixels\n\n            RendererPixels.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Points):\n            from gsp_matplotlib.renderer.matplotlib_renderer_points import RendererPoints\n\n            RendererPoints.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Paths):\n            from gsp_matplotlib.renderer.matplotlib_renderer_paths import RendererPaths\n\n            RendererPaths.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Markers):\n            from gsp_matplotlib.renderer.matplotlib_renderer_markers import RendererMarkers\n\n            RendererMarkers.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Segments):\n            from gsp_matplotlib.renderer.matplotlib_renderer_segments import RendererSegments\n\n            RendererSegments.render(self, viewport, visual, model_matrix, camera)\n\n        elif isinstance(visual, Texts):\n            from gsp_matplotlib.renderer.matplotlib_renderer_texts import RendererTexts\n\n            RendererTexts.render(self, viewport, visual, model_matrix, camera)\n        else:\n            raise NotImplementedError(f\"Rendering for visual type {type(visual)} is not implemented.\")\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    def get_mpl_axes_for_viewport(self, viewport: Viewport) -&gt; matplotlib.axes.Axes:\n        \"\"\"Get the Matplotlib axes associated with a viewport.\n\n        Args:\n            viewport: The viewport to get axes for.\n\n        Returns:\n            The Matplotlib Axes object for the given viewport.\n        \"\"\"\n        return self._axes[viewport.get_uuid()]\n\n    def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n        \"\"\"Get the underlying Matplotlib figure.\n\n        Returns:\n            The Matplotlib Figure object used by this renderer.\n        \"\"\"\n        return self._figure\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.__init__","title":"<code>__init__(canvas: Canvas)</code>","text":"<p>Initialize the Matplotlib renderer.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>gsp.core.canvas.Canvas</code> <p>The canvas defining the rendering surface dimensions and DPI.</p> required Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def __init__(self, canvas: Canvas):\n    \"\"\"Initialize the Matplotlib renderer.\n\n    Args:\n        canvas: The canvas defining the rendering surface dimensions and DPI.\n    \"\"\"\n    self.canvas = canvas\n    # Store mapping of viewport UUIDs to axes\n    self._axes: dict[str, matplotlib.axes.Axes] = {}\n    # Store mapping of visual UUIDs to matplotlib artists\n    self._artists: dict[str, matplotlib.artist.Artist] = {}\n    # Store group count per visual UUID\n    self._group_count: dict[str, int] = {}\n\n    # Create a figure\n    figure_width = canvas.get_width() / canvas.get_dpi()\n    figure_height = canvas.get_height() / canvas.get_dpi()\n    self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=canvas.get_dpi())\n    assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n    self._figure.canvas.manager.set_window_title(\"Matplotlib\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.get_canvas","title":"<code>get_canvas() -&gt; Canvas</code>","text":"<p>Get the canvas associated with this renderer.</p> <p>Returns:</p> Type Description <code>gsp.core.canvas.Canvas</code> <p>The canvas instance.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def get_canvas(self) -&gt; Canvas:\n    \"\"\"Get the canvas associated with this renderer.\n\n    Returns:\n        The canvas instance.\n    \"\"\"\n    return self.canvas\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the renderer and release resources.</p> <p>Stops the Matplotlib event loop and closes the figure.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the renderer and release resources.\n\n    Stops the Matplotlib event loop and closes the figure.\n    \"\"\"\n    # warnings.warn(f\"Closing NetworkRenderer does not release any resources.\", UserWarning)\n    # stop the event loop if any - thus .show(block=True) will return\n    self._figure.canvas.stop_event_loop()\n    # close the figure\n    matplotlib.pyplot.close(self._figure)\n    self._figure = None  # type: ignore\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.show","title":"<code>show() -&gt; None</code>","text":"<p>Display the rendered figure in an interactive window.</p> <p>This method shows the Matplotlib figure. It does nothing when running in test mode (GSP_TEST environment variable set to \"True\").</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Display the rendered figure in an interactive window.\n\n    This method shows the Matplotlib figure. It does nothing when running\n    in test mode (GSP_TEST environment variable set to \"True\").\n    \"\"\"\n    # handle non-interactive mode for tests\n    in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n    if in_test:\n        return\n\n    matplotlib.pyplot.show()\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.render","title":"<code>render(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera], return_image: bool = True, image_format: str = 'png') -&gt; bytes</code>","text":"<p>Render the scene to an image.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>Sequence of viewport regions to render into.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>Sequence of visual elements to render.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>Sequence of model transformation matrices for each visual.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>Sequence of cameras defining view and projection for each visual.</p> required <code>return_image</code> <code>bool</code> <p>Whether to return the rendered image as bytes.</p> <code>True</code> <code>image_format</code> <code>str</code> <p>Format for the output image (e.g., \"png\", \"jpg\").</p> <code>'png'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The rendered image as bytes in the specified format, or empty bytes if return_image is False.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the sequences don't all have the same length.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def render(\n    self,\n    viewports: Sequence[Viewport],\n    visuals: Sequence[VisualBase],\n    model_matrices: Sequence[TransBuf],\n    cameras: Sequence[Camera],\n    return_image: bool = True,\n    image_format: str = \"png\",\n) -&gt; bytes:\n    \"\"\"Render the scene to an image.\n\n    Args:\n        viewports: Sequence of viewport regions to render into.\n        visuals: Sequence of visual elements to render.\n        model_matrices: Sequence of model transformation matrices for each visual.\n        cameras: Sequence of cameras defining view and projection for each visual.\n        return_image: Whether to return the rendered image as bytes.\n        image_format: Format for the output image (e.g., \"png\", \"jpg\").\n\n    Returns:\n        The rendered image as bytes in the specified format, or empty bytes if return_image is False.\n\n    Raises:\n        AssertionError: If the sequences don't all have the same length.\n    \"\"\"\n    # =============================================================================\n    # Sanity checks\n    # =============================================================================\n\n    assert (\n        len(viewports) == len(visuals) == len(model_matrices) == len(cameras)\n    ), f\"All length MUST be equal. Mismatched lengths: {len(viewports)} viewports, {len(visuals)} visuals, {len(model_matrices)} model matrices, {len(cameras)} cameras\"\n\n    # =============================================================================\n    # Create all the axes if needed\n    # =============================================================================\n    for viewport in viewports:\n        if viewport.get_uuid() in self._axes:\n            continue\n        axes_rect = (\n            viewport.get_x() / self.canvas.get_width(),\n            viewport.get_y() / self.canvas.get_height(),\n            viewport.get_width() / self.canvas.get_width(),\n            viewport.get_height() / self.canvas.get_height(),\n        )\n        axes: matplotlib.axes.Axes = matplotlib.pyplot.axes(axes_rect)\n        # this should be -1 to 1 - from normalized device coordinates - https://en.wikipedia.org/wiki/Graphics_pipeline\n        # - https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection\n        axes.set_xlim(-1, 1)\n        axes.set_ylim(-1, 1)\n        # hide the borders\n        axes.axis(\"off\")\n        # store axes for this viewport\n        self._axes[viewport.get_uuid()] = axes\n\n    # =============================================================================\n    # Render each visual\n    # =============================================================================\n\n    for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n        self._render_visual(viewport, visual, model_matrix, camera)\n\n    # =============================================================================\n    # Render the output image\n    # =============================================================================\n    image_png_data = b\"\"\n\n    # honor return_image option\n    if return_image:\n        # Render the image to a PNG buffer\n        image_png_buffer = io.BytesIO()\n        self._figure.savefig(image_png_buffer, format=image_format, dpi=self.canvas.get_dpi())\n\n        image_png_buffer.seek(0)\n        image_png_data = image_png_buffer.getvalue()\n        image_png_buffer.close()\n\n    return image_png_data\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.get_mpl_axes_for_viewport","title":"<code>get_mpl_axes_for_viewport(viewport: Viewport) -&gt; matplotlib.axes.Axes</code>","text":"<p>Get the Matplotlib axes associated with a viewport.</p> <p>Parameters:</p> Name Type Description Default <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to get axes for.</p> required <p>Returns:</p> Type Description <code>matplotlib.axes.Axes</code> <p>The Matplotlib Axes object for the given viewport.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def get_mpl_axes_for_viewport(self, viewport: Viewport) -&gt; matplotlib.axes.Axes:\n    \"\"\"Get the Matplotlib axes associated with a viewport.\n\n    Args:\n        viewport: The viewport to get axes for.\n\n    Returns:\n        The Matplotlib Axes object for the given viewport.\n    \"\"\"\n    return self._axes[viewport.get_uuid()]\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.get_mpl_figure","title":"<code>get_mpl_figure() -&gt; matplotlib.figure.Figure</code>","text":"<p>Get the underlying Matplotlib figure.</p> <p>Returns:</p> Type Description <code>matplotlib.figure.Figure</code> <p>The Matplotlib Figure object used by this renderer.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n    \"\"\"Get the underlying Matplotlib figure.\n\n    Returns:\n        The Matplotlib Figure object used by this renderer.\n    \"\"\"\n    return self._figure\n</code></pre>"},{"location":"api/gsp_matplotlib/#matplotlib-renderer","title":"Matplotlib Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer</code>","text":"<p>Matplotlib renderer for GSP visuals.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer","title":"<code>MatplotlibRenderer</code>","text":"<p>               Bases: <code>gsp.types.renderer_base.RendererBase</code></p> <p>Matplotlib-based renderer for GSP visuals.</p> <p>This renderer implements the GSP rendering interface using Matplotlib as the backend. It creates and manages a Matplotlib figure with multiple axes for different viewports, and renders various visual types (pixels, points, paths, markers, segments, texts) into them.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>class MatplotlibRenderer(RendererBase):\n    \"\"\"Matplotlib-based renderer for GSP visuals.\n\n    This renderer implements the GSP rendering interface using Matplotlib as the backend.\n    It creates and manages a Matplotlib figure with multiple axes for different viewports,\n    and renders various visual types (pixels, points, paths, markers, segments, texts) into them.\n    \"\"\"\n\n    def __init__(self, canvas: Canvas):\n        \"\"\"Initialize the Matplotlib renderer.\n\n        Args:\n            canvas: The canvas defining the rendering surface dimensions and DPI.\n        \"\"\"\n        self.canvas = canvas\n        # Store mapping of viewport UUIDs to axes\n        self._axes: dict[str, matplotlib.axes.Axes] = {}\n        # Store mapping of visual UUIDs to matplotlib artists\n        self._artists: dict[str, matplotlib.artist.Artist] = {}\n        # Store group count per visual UUID\n        self._group_count: dict[str, int] = {}\n\n        # Create a figure\n        figure_width = canvas.get_width() / canvas.get_dpi()\n        figure_height = canvas.get_height() / canvas.get_dpi()\n        self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=canvas.get_dpi())\n        assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n        self._figure.canvas.manager.set_window_title(\"Matplotlib\")\n\n    def get_canvas(self) -&gt; Canvas:\n        \"\"\"Get the canvas associated with this renderer.\n\n        Returns:\n            The canvas instance.\n        \"\"\"\n        return self.canvas\n\n    def close(self) -&gt; None:\n        \"\"\"Close the renderer and release resources.\n\n        Stops the Matplotlib event loop and closes the figure.\n        \"\"\"\n        # warnings.warn(f\"Closing NetworkRenderer does not release any resources.\", UserWarning)\n        # stop the event loop if any - thus .show(block=True) will return\n        self._figure.canvas.stop_event_loop()\n        # close the figure\n        matplotlib.pyplot.close(self._figure)\n        self._figure = None  # type: ignore\n\n    def show(self) -&gt; None:\n        \"\"\"Display the rendered figure in an interactive window.\n\n        This method shows the Matplotlib figure. It does nothing when running\n        in test mode (GSP_TEST environment variable set to \"True\").\n        \"\"\"\n        # handle non-interactive mode for tests\n        in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n        if in_test:\n            return\n\n        matplotlib.pyplot.show()\n\n    def render(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n        return_image: bool = True,\n        image_format: str = \"png\",\n    ) -&gt; bytes:\n        \"\"\"Render the scene to an image.\n\n        Args:\n            viewports: Sequence of viewport regions to render into.\n            visuals: Sequence of visual elements to render.\n            model_matrices: Sequence of model transformation matrices for each visual.\n            cameras: Sequence of cameras defining view and projection for each visual.\n            return_image: Whether to return the rendered image as bytes.\n            image_format: Format for the output image (e.g., \"png\", \"jpg\").\n\n        Returns:\n            The rendered image as bytes in the specified format, or empty bytes if return_image is False.\n\n        Raises:\n            AssertionError: If the sequences don't all have the same length.\n        \"\"\"\n        # =============================================================================\n        # Sanity checks\n        # =============================================================================\n\n        assert (\n            len(viewports) == len(visuals) == len(model_matrices) == len(cameras)\n        ), f\"All length MUST be equal. Mismatched lengths: {len(viewports)} viewports, {len(visuals)} visuals, {len(model_matrices)} model matrices, {len(cameras)} cameras\"\n\n        # =============================================================================\n        # Create all the axes if needed\n        # =============================================================================\n        for viewport in viewports:\n            if viewport.get_uuid() in self._axes:\n                continue\n            axes_rect = (\n                viewport.get_x() / self.canvas.get_width(),\n                viewport.get_y() / self.canvas.get_height(),\n                viewport.get_width() / self.canvas.get_width(),\n                viewport.get_height() / self.canvas.get_height(),\n            )\n            axes: matplotlib.axes.Axes = matplotlib.pyplot.axes(axes_rect)\n            # this should be -1 to 1 - from normalized device coordinates - https://en.wikipedia.org/wiki/Graphics_pipeline\n            # - https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection\n            axes.set_xlim(-1, 1)\n            axes.set_ylim(-1, 1)\n            # hide the borders\n            axes.axis(\"off\")\n            # store axes for this viewport\n            self._axes[viewport.get_uuid()] = axes\n\n        # =============================================================================\n        # Render each visual\n        # =============================================================================\n\n        for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n            self._render_visual(viewport, visual, model_matrix, camera)\n\n        # =============================================================================\n        # Render the output image\n        # =============================================================================\n        image_png_data = b\"\"\n\n        # honor return_image option\n        if return_image:\n            # Render the image to a PNG buffer\n            image_png_buffer = io.BytesIO()\n            self._figure.savefig(image_png_buffer, format=image_format, dpi=self.canvas.get_dpi())\n\n            image_png_buffer.seek(0)\n            image_png_data = image_png_buffer.getvalue()\n            image_png_buffer.close()\n\n        return image_png_data\n\n    def _render_visual(self, viewport: Viewport, visual: VisualBase, model_matrix: TransBuf, camera: Camera):\n        \"\"\"Render a single visual in a given viewport using the specified camera.\"\"\"\n        if isinstance(visual, Image):\n            from gsp_matplotlib.renderer.matplotlib_renderer_image import RendererImage\n\n            RendererImage.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Pixels):\n            from gsp_matplotlib.renderer.matplotlib_renderer_pixels import RendererPixels\n\n            RendererPixels.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Points):\n            from gsp_matplotlib.renderer.matplotlib_renderer_points import RendererPoints\n\n            RendererPoints.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Paths):\n            from gsp_matplotlib.renderer.matplotlib_renderer_paths import RendererPaths\n\n            RendererPaths.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Markers):\n            from gsp_matplotlib.renderer.matplotlib_renderer_markers import RendererMarkers\n\n            RendererMarkers.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Segments):\n            from gsp_matplotlib.renderer.matplotlib_renderer_segments import RendererSegments\n\n            RendererSegments.render(self, viewport, visual, model_matrix, camera)\n\n        elif isinstance(visual, Texts):\n            from gsp_matplotlib.renderer.matplotlib_renderer_texts import RendererTexts\n\n            RendererTexts.render(self, viewport, visual, model_matrix, camera)\n        else:\n            raise NotImplementedError(f\"Rendering for visual type {type(visual)} is not implemented.\")\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    def get_mpl_axes_for_viewport(self, viewport: Viewport) -&gt; matplotlib.axes.Axes:\n        \"\"\"Get the Matplotlib axes associated with a viewport.\n\n        Args:\n            viewport: The viewport to get axes for.\n\n        Returns:\n            The Matplotlib Axes object for the given viewport.\n        \"\"\"\n        return self._axes[viewport.get_uuid()]\n\n    def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n        \"\"\"Get the underlying Matplotlib figure.\n\n        Returns:\n            The Matplotlib Figure object used by this renderer.\n        \"\"\"\n        return self._figure\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.__init__","title":"<code>__init__(canvas: Canvas)</code>","text":"<p>Initialize the Matplotlib renderer.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>gsp.core.canvas.Canvas</code> <p>The canvas defining the rendering surface dimensions and DPI.</p> required Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def __init__(self, canvas: Canvas):\n    \"\"\"Initialize the Matplotlib renderer.\n\n    Args:\n        canvas: The canvas defining the rendering surface dimensions and DPI.\n    \"\"\"\n    self.canvas = canvas\n    # Store mapping of viewport UUIDs to axes\n    self._axes: dict[str, matplotlib.axes.Axes] = {}\n    # Store mapping of visual UUIDs to matplotlib artists\n    self._artists: dict[str, matplotlib.artist.Artist] = {}\n    # Store group count per visual UUID\n    self._group_count: dict[str, int] = {}\n\n    # Create a figure\n    figure_width = canvas.get_width() / canvas.get_dpi()\n    figure_height = canvas.get_height() / canvas.get_dpi()\n    self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=canvas.get_dpi())\n    assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n    self._figure.canvas.manager.set_window_title(\"Matplotlib\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the renderer and release resources.</p> <p>Stops the Matplotlib event loop and closes the figure.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the renderer and release resources.\n\n    Stops the Matplotlib event loop and closes the figure.\n    \"\"\"\n    # warnings.warn(f\"Closing NetworkRenderer does not release any resources.\", UserWarning)\n    # stop the event loop if any - thus .show(block=True) will return\n    self._figure.canvas.stop_event_loop()\n    # close the figure\n    matplotlib.pyplot.close(self._figure)\n    self._figure = None  # type: ignore\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.get_canvas","title":"<code>get_canvas() -&gt; Canvas</code>","text":"<p>Get the canvas associated with this renderer.</p> <p>Returns:</p> Type Description <code>gsp.core.canvas.Canvas</code> <p>The canvas instance.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def get_canvas(self) -&gt; Canvas:\n    \"\"\"Get the canvas associated with this renderer.\n\n    Returns:\n        The canvas instance.\n    \"\"\"\n    return self.canvas\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.get_mpl_axes_for_viewport","title":"<code>get_mpl_axes_for_viewport(viewport: Viewport) -&gt; matplotlib.axes.Axes</code>","text":"<p>Get the Matplotlib axes associated with a viewport.</p> <p>Parameters:</p> Name Type Description Default <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to get axes for.</p> required <p>Returns:</p> Type Description <code>matplotlib.axes.Axes</code> <p>The Matplotlib Axes object for the given viewport.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def get_mpl_axes_for_viewport(self, viewport: Viewport) -&gt; matplotlib.axes.Axes:\n    \"\"\"Get the Matplotlib axes associated with a viewport.\n\n    Args:\n        viewport: The viewport to get axes for.\n\n    Returns:\n        The Matplotlib Axes object for the given viewport.\n    \"\"\"\n    return self._axes[viewport.get_uuid()]\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.get_mpl_figure","title":"<code>get_mpl_figure() -&gt; matplotlib.figure.Figure</code>","text":"<p>Get the underlying Matplotlib figure.</p> <p>Returns:</p> Type Description <code>matplotlib.figure.Figure</code> <p>The Matplotlib Figure object used by this renderer.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n    \"\"\"Get the underlying Matplotlib figure.\n\n    Returns:\n        The Matplotlib Figure object used by this renderer.\n    \"\"\"\n    return self._figure\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.render","title":"<code>render(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera], return_image: bool = True, image_format: str = 'png') -&gt; bytes</code>","text":"<p>Render the scene to an image.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>Sequence of viewport regions to render into.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>Sequence of visual elements to render.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>Sequence of model transformation matrices for each visual.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>Sequence of cameras defining view and projection for each visual.</p> required <code>return_image</code> <code>bool</code> <p>Whether to return the rendered image as bytes.</p> <code>True</code> <code>image_format</code> <code>str</code> <p>Format for the output image (e.g., \"png\", \"jpg\").</p> <code>'png'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The rendered image as bytes in the specified format, or empty bytes if return_image is False.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the sequences don't all have the same length.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def render(\n    self,\n    viewports: Sequence[Viewport],\n    visuals: Sequence[VisualBase],\n    model_matrices: Sequence[TransBuf],\n    cameras: Sequence[Camera],\n    return_image: bool = True,\n    image_format: str = \"png\",\n) -&gt; bytes:\n    \"\"\"Render the scene to an image.\n\n    Args:\n        viewports: Sequence of viewport regions to render into.\n        visuals: Sequence of visual elements to render.\n        model_matrices: Sequence of model transformation matrices for each visual.\n        cameras: Sequence of cameras defining view and projection for each visual.\n        return_image: Whether to return the rendered image as bytes.\n        image_format: Format for the output image (e.g., \"png\", \"jpg\").\n\n    Returns:\n        The rendered image as bytes in the specified format, or empty bytes if return_image is False.\n\n    Raises:\n        AssertionError: If the sequences don't all have the same length.\n    \"\"\"\n    # =============================================================================\n    # Sanity checks\n    # =============================================================================\n\n    assert (\n        len(viewports) == len(visuals) == len(model_matrices) == len(cameras)\n    ), f\"All length MUST be equal. Mismatched lengths: {len(viewports)} viewports, {len(visuals)} visuals, {len(model_matrices)} model matrices, {len(cameras)} cameras\"\n\n    # =============================================================================\n    # Create all the axes if needed\n    # =============================================================================\n    for viewport in viewports:\n        if viewport.get_uuid() in self._axes:\n            continue\n        axes_rect = (\n            viewport.get_x() / self.canvas.get_width(),\n            viewport.get_y() / self.canvas.get_height(),\n            viewport.get_width() / self.canvas.get_width(),\n            viewport.get_height() / self.canvas.get_height(),\n        )\n        axes: matplotlib.axes.Axes = matplotlib.pyplot.axes(axes_rect)\n        # this should be -1 to 1 - from normalized device coordinates - https://en.wikipedia.org/wiki/Graphics_pipeline\n        # - https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection\n        axes.set_xlim(-1, 1)\n        axes.set_ylim(-1, 1)\n        # hide the borders\n        axes.axis(\"off\")\n        # store axes for this viewport\n        self._axes[viewport.get_uuid()] = axes\n\n    # =============================================================================\n    # Render each visual\n    # =============================================================================\n\n    for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n        self._render_visual(viewport, visual, model_matrix, camera)\n\n    # =============================================================================\n    # Render the output image\n    # =============================================================================\n    image_png_data = b\"\"\n\n    # honor return_image option\n    if return_image:\n        # Render the image to a PNG buffer\n        image_png_buffer = io.BytesIO()\n        self._figure.savefig(image_png_buffer, format=image_format, dpi=self.canvas.get_dpi())\n\n        image_png_buffer.seek(0)\n        image_png_data = image_png_buffer.getvalue()\n        image_png_buffer.close()\n\n    return image_png_data\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.show","title":"<code>show() -&gt; None</code>","text":"<p>Display the rendered figure in an interactive window.</p> <p>This method shows the Matplotlib figure. It does nothing when running in test mode (GSP_TEST environment variable set to \"True\").</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Display the rendered figure in an interactive window.\n\n    This method shows the Matplotlib figure. It does nothing when running\n    in test mode (GSP_TEST environment variable set to \"True\").\n    \"\"\"\n    # handle non-interactive mode for tests\n    in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n    if in_test:\n        return\n\n    matplotlib.pyplot.show()\n</code></pre>"},{"location":"api/gsp_matplotlib/#markers-renderer","title":"Markers Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_markers","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_markers</code>","text":"<p>Matplotlib renderer for Markers objects.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_markers.RendererMarkers","title":"<code>RendererMarkers</code>","text":"<p>Renderer for Markers objects using Matplotlib.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_markers.py</code> <pre><code>class RendererMarkers:\n    \"\"\"Renderer for Markers objects using Matplotlib.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: MatplotlibRenderer,\n        viewport: Viewport,\n        markers: Markers,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Render the given Markers object onto the specified viewport using Matplotlib.\n\n        Args:\n            renderer (MatplotlibRenderer): The renderer instance.\n            viewport (Viewport): The viewport to render onto.\n            markers (Markers): The Markers object containing marker data.\n            model_matrix (TransBuf): The model transformation matrix.\n            camera (Camera): The camera providing view and projection matrices.\n\n        Returns:\n            list[matplotlib.artist.Artist]: A list of Matplotlib artist objects created or updated\n        \"\"\"\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(markers.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 2D - shape (N, 2)\n        vertices_2d = vertices_3d_transformed[:, :2]\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        # Convert all attributes to buffer\n        sizes_buffer = TransBufUtils.to_buffer(markers.get_sizes())\n        face_colors_buffer = TransBufUtils.to_buffer(markers.get_face_colors())\n        edge_colors_buffer = TransBufUtils.to_buffer(markers.get_edge_colors())\n        edge_widths_buffer = TransBufUtils.to_buffer(markers.get_edge_widths())\n\n        # Convert buffers to numpy arrays\n        sizes_numpy = Bufferx.to_numpy(sizes_buffer).reshape(-1)\n        face_colors_numpy = Bufferx.to_numpy(face_colors_buffer) / 255.0  # normalize to [0, 1] range\n        edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer) / 255.0  # normalize to [0, 1] range\n        edge_widths_numpy = Bufferx.to_numpy(edge_widths_buffer).flatten()\n\n        # =============================================================================\n        # Sanity checks attributes buffers\n        # =============================================================================\n\n        Markers.sanity_check_attributes_buffer(\n            markers.get_marker_shape(),\n            vertices_buffer,\n            sizes_buffer,\n            face_colors_buffer,\n            edge_colors_buffer,\n            edge_widths_buffer,\n        )\n\n        # =============================================================================\n        # Create the artists if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{markers.get_uuid()}\"\n\n        if artist_uuid not in renderer._artists:\n            axes = renderer.get_mpl_axes_for_viewport(viewport)\n            mpl_marker_shape = ConverterUtils.marker_shape_gsp_to_mpl(markers.get_marker_shape())\n            mpl_path_collection = axes.scatter([], [], marker=mpl_marker_shape)\n            mpl_path_collection.set_visible(False)\n            # hide until properly positioned and sized\n            renderer._artists[artist_uuid] = mpl_path_collection\n            axes.add_artist(mpl_path_collection)\n\n        # =============================================================================\n        # Get existing artists\n        # =============================================================================\n\n        mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[artist_uuid])\n        mpl_path_collection.set_visible(True)\n\n        # =============================================================================\n        # Update artists\n        # =============================================================================\n\n        mpl_path_collection.set_offsets(offsets=vertices_2d)\n        mpl_path_collection.set_sizes(typing.cast(list, sizes_numpy))\n        mpl_path_collection.set_facecolor(typing.cast(list, face_colors_numpy))\n        mpl_path_collection.set_edgecolor(typing.cast(list, edge_colors_numpy))\n        mpl_path_collection.set_linewidth(typing.cast(list, edge_widths_numpy))\n\n        # Return the list of artists created/updated\n        return [mpl_path_collection]\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_markers.RendererMarkers.render","title":"<code>render(renderer: MatplotlibRenderer, viewport: Viewport, markers: Markers, model_matrix: TransBuf, camera: Camera) -&gt; list[matplotlib.artist.Artist]</code>  <code>staticmethod</code>","text":"<p>Render the given Markers object onto the specified viewport using Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer</code> <p>The renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render onto.</p> required <code>markers</code> <code>gsp.visuals.Markers</code> <p>The Markers object containing marker data.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model transformation matrix.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera providing view and projection matrices.</p> required <p>Returns:</p> Type Description <code>list[matplotlib.artist.Artist]</code> <p>list[matplotlib.artist.Artist]: A list of Matplotlib artist objects created or updated</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_markers.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: MatplotlibRenderer,\n    viewport: Viewport,\n    markers: Markers,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; list[matplotlib.artist.Artist]:\n    \"\"\"Render the given Markers object onto the specified viewport using Matplotlib.\n\n    Args:\n        renderer (MatplotlibRenderer): The renderer instance.\n        viewport (Viewport): The viewport to render onto.\n        markers (Markers): The Markers object containing marker data.\n        model_matrix (TransBuf): The model transformation matrix.\n        camera (Camera): The camera providing view and projection matrices.\n\n    Returns:\n        list[matplotlib.artist.Artist]: A list of Matplotlib artist objects created or updated\n    \"\"\"\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(markers.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 2D - shape (N, 2)\n    vertices_2d = vertices_3d_transformed[:, :2]\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    # Convert all attributes to buffer\n    sizes_buffer = TransBufUtils.to_buffer(markers.get_sizes())\n    face_colors_buffer = TransBufUtils.to_buffer(markers.get_face_colors())\n    edge_colors_buffer = TransBufUtils.to_buffer(markers.get_edge_colors())\n    edge_widths_buffer = TransBufUtils.to_buffer(markers.get_edge_widths())\n\n    # Convert buffers to numpy arrays\n    sizes_numpy = Bufferx.to_numpy(sizes_buffer).reshape(-1)\n    face_colors_numpy = Bufferx.to_numpy(face_colors_buffer) / 255.0  # normalize to [0, 1] range\n    edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer) / 255.0  # normalize to [0, 1] range\n    edge_widths_numpy = Bufferx.to_numpy(edge_widths_buffer).flatten()\n\n    # =============================================================================\n    # Sanity checks attributes buffers\n    # =============================================================================\n\n    Markers.sanity_check_attributes_buffer(\n        markers.get_marker_shape(),\n        vertices_buffer,\n        sizes_buffer,\n        face_colors_buffer,\n        edge_colors_buffer,\n        edge_widths_buffer,\n    )\n\n    # =============================================================================\n    # Create the artists if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{markers.get_uuid()}\"\n\n    if artist_uuid not in renderer._artists:\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        mpl_marker_shape = ConverterUtils.marker_shape_gsp_to_mpl(markers.get_marker_shape())\n        mpl_path_collection = axes.scatter([], [], marker=mpl_marker_shape)\n        mpl_path_collection.set_visible(False)\n        # hide until properly positioned and sized\n        renderer._artists[artist_uuid] = mpl_path_collection\n        axes.add_artist(mpl_path_collection)\n\n    # =============================================================================\n    # Get existing artists\n    # =============================================================================\n\n    mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[artist_uuid])\n    mpl_path_collection.set_visible(True)\n\n    # =============================================================================\n    # Update artists\n    # =============================================================================\n\n    mpl_path_collection.set_offsets(offsets=vertices_2d)\n    mpl_path_collection.set_sizes(typing.cast(list, sizes_numpy))\n    mpl_path_collection.set_facecolor(typing.cast(list, face_colors_numpy))\n    mpl_path_collection.set_edgecolor(typing.cast(list, edge_colors_numpy))\n    mpl_path_collection.set_linewidth(typing.cast(list, edge_widths_numpy))\n\n    # Return the list of artists created/updated\n    return [mpl_path_collection]\n</code></pre>"},{"location":"api/gsp_matplotlib/#paths-renderer","title":"Paths Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_paths","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_paths</code>","text":"<p>Matplotlib renderer for Paths objects.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_paths.RendererPaths","title":"<code>RendererPaths</code>","text":"<p>Renderer for Paths objects using Matplotlib.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_paths.py</code> <pre><code>class RendererPaths:\n    \"\"\"Renderer for Paths objects using Matplotlib.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: MatplotlibRenderer,\n        viewport: Viewport,\n        paths: Paths,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Render the given Paths object onto the specified viewport using Matplotlib.\n\n        Args:\n            renderer (MatplotlibRenderer): The renderer instance.\n            viewport (Viewport): The viewport to render onto.\n            paths (Paths): The Paths object containing path data.\n            model_matrix (TransBuf): The model transformation matrix.\n            camera (Camera): The camera providing view and projection matrices.\n\n        Returns:\n            list[matplotlib.artist.Artist]: A list of Matplotlib artist objects created or updated\n        \"\"\"\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(paths.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 2D - shape (N, 2)\n        vertices_2d = vertices_3d_transformed[:, :2]\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        # Convert all attributes to buffer\n        path_sizes_buffer = TransBufUtils.to_buffer(paths.get_path_sizes())\n        colors_buffer = TransBufUtils.to_buffer(paths.get_colors())\n        line_widths_buffer = TransBufUtils.to_buffer(paths.get_line_widths())\n\n        # Convert buffers to numpy arrays\n        path_sizes_numpy = Bufferx.to_numpy(path_sizes_buffer)\n        colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n        line_widths_numpy = Bufferx.to_numpy(line_widths_buffer)\n        line_widths_numpy = line_widths_numpy.reshape(-1)\n\n        # =============================================================================\n        #\n        # =============================================================================\n        # mpl_paths is of shape (M, 2, 2) where M is total number of line segments across all paths\n        mpl_paths = np.zeros((0, 2, 2), dtype=np.float32)\n        # mpl_colors is of shape (M, 4)\n        mpl_colors = np.zeros((0, 4), dtype=np.float32)\n        # mpl_line_widths is of shape (M,)\n        mpl_line_widths = np.zeros((0,), dtype=np.float32)\n\n        for path_index, path_size in enumerate(path_sizes_numpy):\n            path_start = int(np.sum(path_sizes_numpy[:path_index]))\n            path_size_int = int(path_size)\n            path_vertices_2d = vertices_2d[path_start : path_start + path_size_int]\n\n            # Create segments for this path\n            path_mpl_paths = np.concatenate([path_vertices_2d[:-1].reshape(-1, 1, 2), path_vertices_2d[1:].reshape(-1, 1, 2)], axis=1)\n            mpl_paths = np.vstack([mpl_paths, path_mpl_paths])\n\n            mpl_colors = np.vstack([mpl_colors, colors_numpy[path_start : path_start + path_size_int - 1]])\n            mpl_line_widths = np.hstack([mpl_line_widths, line_widths_numpy[path_start : path_start + path_size_int - 1]])\n\n        # =============================================================================\n        # Sanity checks attributes buffers\n        # =============================================================================\n\n        Paths.sanity_check_attributes_buffer(\n            vertices_buffer,\n            path_sizes_buffer,\n            colors_buffer,\n            line_widths_buffer,\n            paths.get_cap_style(),\n            paths.get_join_style(),\n        )\n\n        # =============================================================================\n        # Create the artists if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{paths.get_uuid()}\"\n\n        if artist_uuid not in renderer._artists:\n            mpl_line_collection = matplotlib.collections.LineCollection([])\n            mpl_line_collection.set_visible(False)\n            # hide until properly positioned and sized\n            renderer._artists[artist_uuid] = mpl_line_collection\n            axes = renderer.get_mpl_axes_for_viewport(viewport)\n            axes.add_artist(mpl_line_collection)\n\n        # =============================================================================\n        # Get existing artists\n        # =============================================================================\n\n        mpl_line_collection = typing.cast(matplotlib.collections.LineCollection, renderer._artists[artist_uuid])\n        mpl_line_collection.set_visible(True)\n\n        # =============================================================================\n        # Update artists\n        # =============================================================================\n\n        mpl_line_collection.set_paths(typing.cast(list, mpl_paths))\n        mpl_line_collection.set_color(typing.cast(list, mpl_colors))\n        mpl_line_collection.set_linewidth(typing.cast(list, mpl_line_widths))\n        mpl_line_collection.set_capstyle(ConverterUtils.cap_style_gsp_to_mpl(paths.get_cap_style()))\n        mpl_line_collection.set_joinstyle(ConverterUtils.join_style_gsp_to_mpl(paths.get_join_style()))\n\n        # Return the list of artists created/updated\n        changed_artists: list[matplotlib.artist.Artist] = []\n        changed_artists.append(mpl_line_collection)\n        return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_paths.RendererPaths.render","title":"<code>render(renderer: MatplotlibRenderer, viewport: Viewport, paths: Paths, model_matrix: TransBuf, camera: Camera) -&gt; list[matplotlib.artist.Artist]</code>  <code>staticmethod</code>","text":"<p>Render the given Paths object onto the specified viewport using Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer</code> <p>The renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render onto.</p> required <code>paths</code> <code>gsp.visuals.paths.Paths</code> <p>The Paths object containing path data.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model transformation matrix.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera providing view and projection matrices.</p> required <p>Returns:</p> Type Description <code>list[matplotlib.artist.Artist]</code> <p>list[matplotlib.artist.Artist]: A list of Matplotlib artist objects created or updated</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_paths.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: MatplotlibRenderer,\n    viewport: Viewport,\n    paths: Paths,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; list[matplotlib.artist.Artist]:\n    \"\"\"Render the given Paths object onto the specified viewport using Matplotlib.\n\n    Args:\n        renderer (MatplotlibRenderer): The renderer instance.\n        viewport (Viewport): The viewport to render onto.\n        paths (Paths): The Paths object containing path data.\n        model_matrix (TransBuf): The model transformation matrix.\n        camera (Camera): The camera providing view and projection matrices.\n\n    Returns:\n        list[matplotlib.artist.Artist]: A list of Matplotlib artist objects created or updated\n    \"\"\"\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(paths.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 2D - shape (N, 2)\n    vertices_2d = vertices_3d_transformed[:, :2]\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    # Convert all attributes to buffer\n    path_sizes_buffer = TransBufUtils.to_buffer(paths.get_path_sizes())\n    colors_buffer = TransBufUtils.to_buffer(paths.get_colors())\n    line_widths_buffer = TransBufUtils.to_buffer(paths.get_line_widths())\n\n    # Convert buffers to numpy arrays\n    path_sizes_numpy = Bufferx.to_numpy(path_sizes_buffer)\n    colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n    line_widths_numpy = Bufferx.to_numpy(line_widths_buffer)\n    line_widths_numpy = line_widths_numpy.reshape(-1)\n\n    # =============================================================================\n    #\n    # =============================================================================\n    # mpl_paths is of shape (M, 2, 2) where M is total number of line segments across all paths\n    mpl_paths = np.zeros((0, 2, 2), dtype=np.float32)\n    # mpl_colors is of shape (M, 4)\n    mpl_colors = np.zeros((0, 4), dtype=np.float32)\n    # mpl_line_widths is of shape (M,)\n    mpl_line_widths = np.zeros((0,), dtype=np.float32)\n\n    for path_index, path_size in enumerate(path_sizes_numpy):\n        path_start = int(np.sum(path_sizes_numpy[:path_index]))\n        path_size_int = int(path_size)\n        path_vertices_2d = vertices_2d[path_start : path_start + path_size_int]\n\n        # Create segments for this path\n        path_mpl_paths = np.concatenate([path_vertices_2d[:-1].reshape(-1, 1, 2), path_vertices_2d[1:].reshape(-1, 1, 2)], axis=1)\n        mpl_paths = np.vstack([mpl_paths, path_mpl_paths])\n\n        mpl_colors = np.vstack([mpl_colors, colors_numpy[path_start : path_start + path_size_int - 1]])\n        mpl_line_widths = np.hstack([mpl_line_widths, line_widths_numpy[path_start : path_start + path_size_int - 1]])\n\n    # =============================================================================\n    # Sanity checks attributes buffers\n    # =============================================================================\n\n    Paths.sanity_check_attributes_buffer(\n        vertices_buffer,\n        path_sizes_buffer,\n        colors_buffer,\n        line_widths_buffer,\n        paths.get_cap_style(),\n        paths.get_join_style(),\n    )\n\n    # =============================================================================\n    # Create the artists if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{paths.get_uuid()}\"\n\n    if artist_uuid not in renderer._artists:\n        mpl_line_collection = matplotlib.collections.LineCollection([])\n        mpl_line_collection.set_visible(False)\n        # hide until properly positioned and sized\n        renderer._artists[artist_uuid] = mpl_line_collection\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        axes.add_artist(mpl_line_collection)\n\n    # =============================================================================\n    # Get existing artists\n    # =============================================================================\n\n    mpl_line_collection = typing.cast(matplotlib.collections.LineCollection, renderer._artists[artist_uuid])\n    mpl_line_collection.set_visible(True)\n\n    # =============================================================================\n    # Update artists\n    # =============================================================================\n\n    mpl_line_collection.set_paths(typing.cast(list, mpl_paths))\n    mpl_line_collection.set_color(typing.cast(list, mpl_colors))\n    mpl_line_collection.set_linewidth(typing.cast(list, mpl_line_widths))\n    mpl_line_collection.set_capstyle(ConverterUtils.cap_style_gsp_to_mpl(paths.get_cap_style()))\n    mpl_line_collection.set_joinstyle(ConverterUtils.join_style_gsp_to_mpl(paths.get_join_style()))\n\n    # Return the list of artists created/updated\n    changed_artists: list[matplotlib.artist.Artist] = []\n    changed_artists.append(mpl_line_collection)\n    return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#pixels-renderer","title":"Pixels Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_pixels</code>","text":"<p>Renderer for Pixels using Matplotlib.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels.RendererPixels","title":"<code>RendererPixels</code>","text":"<p>Renderer for Pixels using Matplotlib.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_pixels.py</code> <pre><code>class RendererPixels:\n    \"\"\"Renderer for Pixels using Matplotlib.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: MatplotlibRenderer,\n        viewport: Viewport,\n        pixels: Pixels,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Render Pixels visual using Matplotlib.\n\n        Args:\n            renderer: The MatplotlibRenderer instance.\n            viewport: The Viewport in which to render.\n            pixels: The Pixels visual to render.\n            model_matrix: The model transformation matrix as a TransBuf.\n            camera: The Camera providing view and projection matrices.\n\n        Returns:\n            list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n        \"\"\"\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(pixels.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 2D - shape (N, 2)\n        vertices_2d = vertices_3d_transformed[:, :2]\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        # Convert all attributes to buffer\n        colors_buffer = TransBufUtils.to_buffer(pixels.get_colors())\n\n        # Convert buffers to numpy arrays\n        colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n\n        # =============================================================================\n        # Sanity checks attributes buffers\n        # =============================================================================\n\n        Pixels.sanity_check_attributes_buffer(vertices_buffer, colors_buffer, pixels.get_groups())\n\n        # =============================================================================\n        #   Compute indices_per_group for groups depending on the type of groups\n        # =============================================================================\n\n        indices_per_group = GroupUtils.compute_indices_per_group(vertices_numpy.__len__(), pixels.get_groups())\n        group_count = GroupUtils.get_group_count(vertices_numpy.__len__(), pixels.get_groups())\n\n        # =============================================================================\n        # Create the artists if needed\n        # =============================================================================\n\n        artist_uuid_prefix = f\"{viewport.get_uuid()}_{pixels.get_uuid()}\"\n\n        # update stored group count\n        old_group_count = None\n        if artist_uuid_prefix in renderer._group_count:\n            old_group_count = renderer._group_count[artist_uuid_prefix]\n        renderer._group_count[artist_uuid_prefix] = group_count\n\n        # If the group count has changed, destroy old artists\n        if old_group_count is not None and old_group_count != group_count:\n            RendererPixels.destroy_artists(renderer, viewport, pixels, old_group_count)\n\n        # Create artists if they do not exist\n        artist_uuid_sample = f\"{artist_uuid_prefix}_group_0\"\n        if artist_uuid_sample not in renderer._artists:\n            RendererPixels.create_artists(renderer, viewport, pixels, group_count)\n\n        # =============================================================================\n        # Update matplotlib for each group\n        # =============================================================================\n\n        changed_artists: list[matplotlib.artist.Artist] = []\n        for group_index in range(group_count):\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n\n            # =============================================================================\n            # Get existing artists\n            # =============================================================================\n\n            mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[group_uuid])\n            mpl_path_collection.set_visible(True)\n            changed_artists.append(mpl_path_collection)\n\n            # =============================================================================\n            # Update artists\n            # =============================================================================\n\n            mpl_path_collection.set_offsets(offsets=vertices_2d[indices_per_group[group_index]])\n            mpl_path_collection.set_facecolor(typing.cast(list, colors_numpy[group_index]))\n\n        # Return the list of artists created/updated\n        return changed_artists\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    @staticmethod\n    def create_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None:\n        \"\"\"Create the artists associated with the given visual and group count.\n\n        Args:\n            renderer: The Matplotlib renderer.\n            viewport: The viewport for which to create the artists.\n            visual: The visual for which to create the artists.\n            group_count: The number of groups in the visual.\n        \"\"\"\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        artist_uuid_prefix = f\"{viewport.get_uuid()}_{visual.get_uuid()}\"\n        # compute 1 pixel size in points squared for matplotlib sizing\n        assert axes.figure.get_dpi() is not None, \"Canvas DPI must be set for proper pixel sizing\"\n        size_pt = UnitUtils.pixel_to_point(1.0, axes.figure.get_dpi())\n        size_squared_pt = size_pt * size_pt\n\n        for group_index in range(group_count):\n            mpl_path_collection = axes.scatter([], [], s=size_squared_pt, marker=\"o\")\n            mpl_path_collection.set_antialiased(True)\n            mpl_path_collection.set_linewidth(0)\n            mpl_path_collection.set_visible(False)\n            # hide until properly positioned and sized\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n            renderer._artists[group_uuid] = mpl_path_collection\n            axes.add_artist(mpl_path_collection)\n\n    @staticmethod\n    def destroy_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None:\n        \"\"\"Destroy the artists associated with the given visual and group count.\n\n        Trigger a bug in matplotlib where artists are not properly removed from the axes.\n        \"\"\"\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        artist_uuid_prefix = f\"{viewport.get_uuid()}_{visual.get_uuid()}\"\n        for group_index in range(group_count):\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n            mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[group_uuid])\n            del renderer._artists[group_uuid]\n            mpl_path_collection.remove()\n\n            # axes.collections.remove(mpl_path_collection)\n            # axes.collections.remove(axes.collections.index(mpl_path_collection))\n\n            ax = axes\n            artist = mpl_path_collection\n\n            print(\"Artist:\", artist)\n            print(\"In ax.artists?\", artist in ax.artists)\n            print(\"In ax.patches?\", artist in ax.patches)\n            print(\"In ax.lines?\", artist in ax.lines)\n            print(\"In ax.collections?\", artist in ax.collections)\n            print(\"In ax.texts?\", artist in ax.texts)\n            print(\"Figure art?\", artist in getattr(ax.figure, \"artists\", []))\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels.RendererPixels.create_artists","title":"<code>create_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Create the artists associated with the given visual and group count.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.MatplotlibRenderer</code> <p>The Matplotlib renderer.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport for which to create the artists.</p> required <code>visual</code> <code>gsp.types.visual_base.VisualBase</code> <p>The visual for which to create the artists.</p> required <code>group_count</code> <code>int</code> <p>The number of groups in the visual.</p> required Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_pixels.py</code> <pre><code>@staticmethod\ndef create_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None:\n    \"\"\"Create the artists associated with the given visual and group count.\n\n    Args:\n        renderer: The Matplotlib renderer.\n        viewport: The viewport for which to create the artists.\n        visual: The visual for which to create the artists.\n        group_count: The number of groups in the visual.\n    \"\"\"\n    axes = renderer.get_mpl_axes_for_viewport(viewport)\n    artist_uuid_prefix = f\"{viewport.get_uuid()}_{visual.get_uuid()}\"\n    # compute 1 pixel size in points squared for matplotlib sizing\n    assert axes.figure.get_dpi() is not None, \"Canvas DPI must be set for proper pixel sizing\"\n    size_pt = UnitUtils.pixel_to_point(1.0, axes.figure.get_dpi())\n    size_squared_pt = size_pt * size_pt\n\n    for group_index in range(group_count):\n        mpl_path_collection = axes.scatter([], [], s=size_squared_pt, marker=\"o\")\n        mpl_path_collection.set_antialiased(True)\n        mpl_path_collection.set_linewidth(0)\n        mpl_path_collection.set_visible(False)\n        # hide until properly positioned and sized\n        group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n        renderer._artists[group_uuid] = mpl_path_collection\n        axes.add_artist(mpl_path_collection)\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels.RendererPixels.destroy_artists","title":"<code>destroy_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Destroy the artists associated with the given visual and group count.</p> <p>Trigger a bug in matplotlib where artists are not properly removed from the axes.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_pixels.py</code> <pre><code>@staticmethod\ndef destroy_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None:\n    \"\"\"Destroy the artists associated with the given visual and group count.\n\n    Trigger a bug in matplotlib where artists are not properly removed from the axes.\n    \"\"\"\n    axes = renderer.get_mpl_axes_for_viewport(viewport)\n    artist_uuid_prefix = f\"{viewport.get_uuid()}_{visual.get_uuid()}\"\n    for group_index in range(group_count):\n        group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n        mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[group_uuid])\n        del renderer._artists[group_uuid]\n        mpl_path_collection.remove()\n\n        # axes.collections.remove(mpl_path_collection)\n        # axes.collections.remove(axes.collections.index(mpl_path_collection))\n\n        ax = axes\n        artist = mpl_path_collection\n\n        print(\"Artist:\", artist)\n        print(\"In ax.artists?\", artist in ax.artists)\n        print(\"In ax.patches?\", artist in ax.patches)\n        print(\"In ax.lines?\", artist in ax.lines)\n        print(\"In ax.collections?\", artist in ax.collections)\n        print(\"In ax.texts?\", artist in ax.texts)\n        print(\"Figure art?\", artist in getattr(ax.figure, \"artists\", []))\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels.RendererPixels.render","title":"<code>render(renderer: MatplotlibRenderer, viewport: Viewport, pixels: Pixels, model_matrix: TransBuf, camera: Camera) -&gt; list[matplotlib.artist.Artist]</code>  <code>staticmethod</code>","text":"<p>Render Pixels visual using Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.MatplotlibRenderer</code> <p>The MatplotlibRenderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The Viewport in which to render.</p> required <code>pixels</code> <code>gsp.visuals.pixels.Pixels</code> <p>The Pixels visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model transformation matrix as a TransBuf.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The Camera providing view and projection matrices.</p> required <p>Returns:</p> Type Description <code>list[matplotlib.artist.Artist]</code> <p>list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_pixels.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: MatplotlibRenderer,\n    viewport: Viewport,\n    pixels: Pixels,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; list[matplotlib.artist.Artist]:\n    \"\"\"Render Pixels visual using Matplotlib.\n\n    Args:\n        renderer: The MatplotlibRenderer instance.\n        viewport: The Viewport in which to render.\n        pixels: The Pixels visual to render.\n        model_matrix: The model transformation matrix as a TransBuf.\n        camera: The Camera providing view and projection matrices.\n\n    Returns:\n        list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n    \"\"\"\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(pixels.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 2D - shape (N, 2)\n    vertices_2d = vertices_3d_transformed[:, :2]\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    # Convert all attributes to buffer\n    colors_buffer = TransBufUtils.to_buffer(pixels.get_colors())\n\n    # Convert buffers to numpy arrays\n    colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n\n    # =============================================================================\n    # Sanity checks attributes buffers\n    # =============================================================================\n\n    Pixels.sanity_check_attributes_buffer(vertices_buffer, colors_buffer, pixels.get_groups())\n\n    # =============================================================================\n    #   Compute indices_per_group for groups depending on the type of groups\n    # =============================================================================\n\n    indices_per_group = GroupUtils.compute_indices_per_group(vertices_numpy.__len__(), pixels.get_groups())\n    group_count = GroupUtils.get_group_count(vertices_numpy.__len__(), pixels.get_groups())\n\n    # =============================================================================\n    # Create the artists if needed\n    # =============================================================================\n\n    artist_uuid_prefix = f\"{viewport.get_uuid()}_{pixels.get_uuid()}\"\n\n    # update stored group count\n    old_group_count = None\n    if artist_uuid_prefix in renderer._group_count:\n        old_group_count = renderer._group_count[artist_uuid_prefix]\n    renderer._group_count[artist_uuid_prefix] = group_count\n\n    # If the group count has changed, destroy old artists\n    if old_group_count is not None and old_group_count != group_count:\n        RendererPixels.destroy_artists(renderer, viewport, pixels, old_group_count)\n\n    # Create artists if they do not exist\n    artist_uuid_sample = f\"{artist_uuid_prefix}_group_0\"\n    if artist_uuid_sample not in renderer._artists:\n        RendererPixels.create_artists(renderer, viewport, pixels, group_count)\n\n    # =============================================================================\n    # Update matplotlib for each group\n    # =============================================================================\n\n    changed_artists: list[matplotlib.artist.Artist] = []\n    for group_index in range(group_count):\n        group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n\n        # =============================================================================\n        # Get existing artists\n        # =============================================================================\n\n        mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[group_uuid])\n        mpl_path_collection.set_visible(True)\n        changed_artists.append(mpl_path_collection)\n\n        # =============================================================================\n        # Update artists\n        # =============================================================================\n\n        mpl_path_collection.set_offsets(offsets=vertices_2d[indices_per_group[group_index]])\n        mpl_path_collection.set_facecolor(typing.cast(list, colors_numpy[group_index]))\n\n    # Return the list of artists created/updated\n    return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#points-renderer","title":"Points Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_points","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_points</code>","text":"<p>Renderer for Points using Matplotlib.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_points.RendererPoints","title":"<code>RendererPoints</code>","text":"<p>Renderer for Points using Matplotlib.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_points.py</code> <pre><code>class RendererPoints:\n    \"\"\"Renderer for Points using Matplotlib.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: MatplotlibRenderer,\n        viewport: Viewport,\n        points: Points,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Render Points visual using Matplotlib.\n\n        Args:\n            renderer: The MatplotlibRenderer instance.\n            viewport: The Viewport in which to render.\n            points: The Points visual to render.\n            model_matrix: The model transformation matrix as a TransBuf.\n            camera: The Camera providing view and projection matrices.\n\n        Returns:\n            list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n        \"\"\"\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(points.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 2D - shape (N, 2)\n        vertices_2d = vertices_3d_transformed[:, :2]\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        # Convert all attributes to buffer\n        sizes_buffer = TransBufUtils.to_buffer(points.get_sizes())\n        face_colors_buffer = TransBufUtils.to_buffer(points.get_face_colors())\n        edge_colors_buffer = TransBufUtils.to_buffer(points.get_edge_colors())\n        edge_widths_buffer = TransBufUtils.to_buffer(points.get_edge_widths())\n\n        # Convert buffers to numpy arrays\n        sizes_numpy = Bufferx.to_numpy(sizes_buffer).flatten()\n        face_colors_numpy = Bufferx.to_numpy(face_colors_buffer) / 255.0  # normalize to [0, 1] range\n        edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer) / 255.0  # normalize to [0, 1] range\n        edge_widths_numpy = Bufferx.to_numpy(edge_widths_buffer).flatten()\n\n        # =============================================================================\n        # Sanity checks attributes buffers\n        # =============================================================================\n\n        Points.sanity_check_attributes_buffer(\n            vertices_buffer,\n            sizes_buffer,\n            face_colors_buffer,\n            edge_colors_buffer,\n            edge_widths_buffer,\n        )\n\n        # =============================================================================\n        # Create the artists if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{points.get_uuid()}\"\n        if artist_uuid not in renderer._artists:\n            axes = renderer.get_mpl_axes_for_viewport(viewport)\n            mpl_path_collection = axes.scatter([], [])\n            mpl_path_collection.set_visible(False)\n            # hide until properly positioned and sized\n            renderer._artists[artist_uuid] = mpl_path_collection\n            axes.add_artist(mpl_path_collection)\n\n        # =============================================================================\n        # Get existing artists\n        # =============================================================================\n\n        mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[artist_uuid])\n        mpl_path_collection.set_visible(True)\n\n        # =============================================================================\n        # Update artists\n        # =============================================================================\n\n        mpl_path_collection.set_offsets(offsets=vertices_2d)\n        mpl_path_collection.set_sizes(typing.cast(list, sizes_numpy))\n        mpl_path_collection.set_facecolor(typing.cast(list, face_colors_numpy))\n        mpl_path_collection.set_edgecolor(typing.cast(list, edge_colors_numpy))\n        mpl_path_collection.set_linewidth(typing.cast(list, edge_widths_numpy))\n\n        # Return the list of artists created/updated\n        changed_artists: list[matplotlib.artist.Artist] = []\n        changed_artists.append(mpl_path_collection)\n        return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_points.RendererPoints.render","title":"<code>render(renderer: MatplotlibRenderer, viewport: Viewport, points: Points, model_matrix: TransBuf, camera: Camera) -&gt; list[matplotlib.artist.Artist]</code>  <code>staticmethod</code>","text":"<p>Render Points visual using Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer</code> <p>The MatplotlibRenderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The Viewport in which to render.</p> required <code>points</code> <code>gsp.visuals.points.Points</code> <p>The Points visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model transformation matrix as a TransBuf.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The Camera providing view and projection matrices.</p> required <p>Returns:</p> Type Description <code>list[matplotlib.artist.Artist]</code> <p>list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_points.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: MatplotlibRenderer,\n    viewport: Viewport,\n    points: Points,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; list[matplotlib.artist.Artist]:\n    \"\"\"Render Points visual using Matplotlib.\n\n    Args:\n        renderer: The MatplotlibRenderer instance.\n        viewport: The Viewport in which to render.\n        points: The Points visual to render.\n        model_matrix: The model transformation matrix as a TransBuf.\n        camera: The Camera providing view and projection matrices.\n\n    Returns:\n        list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n    \"\"\"\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(points.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 2D - shape (N, 2)\n    vertices_2d = vertices_3d_transformed[:, :2]\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    # Convert all attributes to buffer\n    sizes_buffer = TransBufUtils.to_buffer(points.get_sizes())\n    face_colors_buffer = TransBufUtils.to_buffer(points.get_face_colors())\n    edge_colors_buffer = TransBufUtils.to_buffer(points.get_edge_colors())\n    edge_widths_buffer = TransBufUtils.to_buffer(points.get_edge_widths())\n\n    # Convert buffers to numpy arrays\n    sizes_numpy = Bufferx.to_numpy(sizes_buffer).flatten()\n    face_colors_numpy = Bufferx.to_numpy(face_colors_buffer) / 255.0  # normalize to [0, 1] range\n    edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer) / 255.0  # normalize to [0, 1] range\n    edge_widths_numpy = Bufferx.to_numpy(edge_widths_buffer).flatten()\n\n    # =============================================================================\n    # Sanity checks attributes buffers\n    # =============================================================================\n\n    Points.sanity_check_attributes_buffer(\n        vertices_buffer,\n        sizes_buffer,\n        face_colors_buffer,\n        edge_colors_buffer,\n        edge_widths_buffer,\n    )\n\n    # =============================================================================\n    # Create the artists if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{points.get_uuid()}\"\n    if artist_uuid not in renderer._artists:\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        mpl_path_collection = axes.scatter([], [])\n        mpl_path_collection.set_visible(False)\n        # hide until properly positioned and sized\n        renderer._artists[artist_uuid] = mpl_path_collection\n        axes.add_artist(mpl_path_collection)\n\n    # =============================================================================\n    # Get existing artists\n    # =============================================================================\n\n    mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[artist_uuid])\n    mpl_path_collection.set_visible(True)\n\n    # =============================================================================\n    # Update artists\n    # =============================================================================\n\n    mpl_path_collection.set_offsets(offsets=vertices_2d)\n    mpl_path_collection.set_sizes(typing.cast(list, sizes_numpy))\n    mpl_path_collection.set_facecolor(typing.cast(list, face_colors_numpy))\n    mpl_path_collection.set_edgecolor(typing.cast(list, edge_colors_numpy))\n    mpl_path_collection.set_linewidth(typing.cast(list, edge_widths_numpy))\n\n    # Return the list of artists created/updated\n    changed_artists: list[matplotlib.artist.Artist] = []\n    changed_artists.append(mpl_path_collection)\n    return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#segments-renderer","title":"Segments Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_segments","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_segments</code>","text":"<p>Renderer for Segments using Matplotlib.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_segments.RendererSegments","title":"<code>RendererSegments</code>","text":"<p>Renderer for Segments using Matplotlib.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_segments.py</code> <pre><code>class RendererSegments:\n    \"\"\"Renderer for Segments using Matplotlib.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: MatplotlibRenderer,\n        viewport: Viewport,\n        segments: Segments,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Render Segments visual using Matplotlib.\n\n        Args:\n            renderer: The MatplotlibRenderer instance.\n            viewport: The Viewport in which to render.\n            segments: The Segments visual to render.\n            model_matrix: The model transformation matrix as a TransBuf.\n            camera: The Camera providing view and projection matrices.\n\n        Returns:\n            list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n        \"\"\"\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(segments.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 2D - shape (N, 2)\n        vertices_2d = vertices_3d_transformed[:, :2]\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        # Convert all attributes to buffer\n        colors_buffer = TransBufUtils.to_buffer(segments.get_colors())\n        line_widths_buffer = TransBufUtils.to_buffer(segments.get_line_widths())\n\n        # Convert buffers to numpy arrays\n        positions_numpy = vertices_2d.reshape(-1, 2, 2)\n        colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n        line_widths_numpy = Bufferx.to_numpy(line_widths_buffer)\n        line_widths_numpy = line_widths_numpy.reshape(-1)\n\n        # =============================================================================\n        # Sanity checks attributes buffers\n        # =============================================================================\n\n        Segments.sanity_check_attributes_buffer(\n            vertices_buffer,\n            line_widths_buffer,\n            segments.get_cap_style(),\n            colors_buffer,\n        )\n\n        # =============================================================================\n        # Create the artists if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{segments.get_uuid()}\"\n        if artist_uuid not in renderer._artists:\n            mpl_line_collection = matplotlib.collections.LineCollection([])\n            mpl_line_collection.set_visible(False)\n            # hide until properly positioned and sized\n            renderer._artists[artist_uuid] = mpl_line_collection\n            axes = renderer.get_mpl_axes_for_viewport(viewport)\n            axes.add_artist(mpl_line_collection)\n\n        # =============================================================================\n        # Get existing artists\n        # =============================================================================\n\n        mpl_line_collection = typing.cast(matplotlib.collections.LineCollection, renderer._artists[artist_uuid])\n        mpl_line_collection.set_visible(True)\n\n        # =============================================================================\n        # Update artists\n        # =============================================================================\n\n        mpl_line_collection.set_paths(typing.cast(list, positions_numpy))\n        mpl_line_collection.set_color(typing.cast(list, colors_numpy))\n        mpl_line_collection.set_linewidth(typing.cast(list, line_widths_numpy))\n        mpl_line_collection.set_capstyle(ConverterUtils.cap_style_gsp_to_mpl(segments.get_cap_style()))\n\n        # Return the list of artists created/updated\n        changed_artists: list[matplotlib.artist.Artist] = []\n        changed_artists.append(mpl_line_collection)\n        return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_segments.RendererSegments.render","title":"<code>render(renderer: MatplotlibRenderer, viewport: Viewport, segments: Segments, model_matrix: TransBuf, camera: Camera) -&gt; list[matplotlib.artist.Artist]</code>  <code>staticmethod</code>","text":"<p>Render Segments visual using Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer</code> <p>The MatplotlibRenderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The Viewport in which to render.</p> required <code>segments</code> <code>gsp.visuals.segments.Segments</code> <p>The Segments visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model transformation matrix as a TransBuf.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The Camera providing view and projection matrices.</p> required <p>Returns:</p> Type Description <code>list[matplotlib.artist.Artist]</code> <p>list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_segments.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: MatplotlibRenderer,\n    viewport: Viewport,\n    segments: Segments,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; list[matplotlib.artist.Artist]:\n    \"\"\"Render Segments visual using Matplotlib.\n\n    Args:\n        renderer: The MatplotlibRenderer instance.\n        viewport: The Viewport in which to render.\n        segments: The Segments visual to render.\n        model_matrix: The model transformation matrix as a TransBuf.\n        camera: The Camera providing view and projection matrices.\n\n    Returns:\n        list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n    \"\"\"\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(segments.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 2D - shape (N, 2)\n    vertices_2d = vertices_3d_transformed[:, :2]\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    # Convert all attributes to buffer\n    colors_buffer = TransBufUtils.to_buffer(segments.get_colors())\n    line_widths_buffer = TransBufUtils.to_buffer(segments.get_line_widths())\n\n    # Convert buffers to numpy arrays\n    positions_numpy = vertices_2d.reshape(-1, 2, 2)\n    colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n    line_widths_numpy = Bufferx.to_numpy(line_widths_buffer)\n    line_widths_numpy = line_widths_numpy.reshape(-1)\n\n    # =============================================================================\n    # Sanity checks attributes buffers\n    # =============================================================================\n\n    Segments.sanity_check_attributes_buffer(\n        vertices_buffer,\n        line_widths_buffer,\n        segments.get_cap_style(),\n        colors_buffer,\n    )\n\n    # =============================================================================\n    # Create the artists if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{segments.get_uuid()}\"\n    if artist_uuid not in renderer._artists:\n        mpl_line_collection = matplotlib.collections.LineCollection([])\n        mpl_line_collection.set_visible(False)\n        # hide until properly positioned and sized\n        renderer._artists[artist_uuid] = mpl_line_collection\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        axes.add_artist(mpl_line_collection)\n\n    # =============================================================================\n    # Get existing artists\n    # =============================================================================\n\n    mpl_line_collection = typing.cast(matplotlib.collections.LineCollection, renderer._artists[artist_uuid])\n    mpl_line_collection.set_visible(True)\n\n    # =============================================================================\n    # Update artists\n    # =============================================================================\n\n    mpl_line_collection.set_paths(typing.cast(list, positions_numpy))\n    mpl_line_collection.set_color(typing.cast(list, colors_numpy))\n    mpl_line_collection.set_linewidth(typing.cast(list, line_widths_numpy))\n    mpl_line_collection.set_capstyle(ConverterUtils.cap_style_gsp_to_mpl(segments.get_cap_style()))\n\n    # Return the list of artists created/updated\n    changed_artists: list[matplotlib.artist.Artist] = []\n    changed_artists.append(mpl_line_collection)\n    return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#texts-renderer","title":"Texts Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_texts","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_texts</code>","text":"<p>Renderer for Texts using Matplotlib.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_texts.RendererTexts","title":"<code>RendererTexts</code>","text":"<p>Renderer for Texts using Matplotlib.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_texts.py</code> <pre><code>class RendererTexts:\n    \"\"\"Renderer for Texts using Matplotlib.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: MatplotlibRenderer,\n        viewport: Viewport,\n        texts: Texts,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Render Texts visual using Matplotlib.\n\n        Args:\n            renderer: The MatplotlibRenderer instance.\n            viewport: The Viewport in which to render.\n            texts: The Texts visual to render.\n            model_matrix: The model transformation matrix as a TransBuf.\n            camera: The Camera providing view and projection matrices.\n\n        Returns:\n            list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n        \"\"\"\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(texts.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 2D - shape (N, 2)\n        vertices_2d = vertices_3d_transformed[:, :2]\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        # Convert all attributes to buffer\n        colors_buffer = TransBufUtils.to_buffer(texts.get_colors())\n        font_sizes_buffer = TransBufUtils.to_buffer(texts.get_font_sizes())\n        anchors_buffer = TransBufUtils.to_buffer(texts.get_anchors())\n        angles_buffer = TransBufUtils.to_buffer(texts.get_angles())\n\n        # Convert buffers to numpy arrays\n        font_sizes_numpy = Bufferx.to_numpy(font_sizes_buffer).flatten()\n        colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n        anchors_numpy = Bufferx.to_numpy(anchors_buffer)\n        angles_numpy = Bufferx.to_numpy(angles_buffer).flatten()\n\n        # =============================================================================\n        # Sanity checks attributes buffers\n        # =============================================================================\n\n        Texts.sanity_check_attributes_buffer(\n            vertices_buffer,\n            texts.get_strings(),\n            colors_buffer,\n            font_sizes_buffer,\n            anchors_buffer,\n            angles_buffer,\n            texts.get_font_name(),\n        )\n\n        # =============================================================================\n        # Create the artists if needed\n        # =============================================================================\n\n        artist_uuid_base = f\"{viewport.get_uuid()}_{texts.get_uuid()}\"\n        for text_index in range(len(texts.get_strings())):\n            artist_uuid = f\"{artist_uuid_base}_{text_index}\"\n            if artist_uuid in renderer._artists:\n                continue\n            mpl_text = matplotlib.text.Text()\n            mpl_text.set_visible(False)\n            # hide until properly positioned and sized\n            renderer._artists[artist_uuid] = mpl_text\n            mpl_axes = renderer.get_mpl_axes_for_viewport(viewport)\n            mpl_axes.add_artist(mpl_text)\n\n        # Remove extra artists if the number of text strings has decreased\n        existing_artist_uuids = [f\"{artist_uuid_base}_{i}\" for i in range(len(texts.get_strings()))]\n        artists_to_remove = [uuid for uuid in renderer._artists.keys() if uuid.startswith(artist_uuid_base) and uuid not in existing_artist_uuids]\n        for artist_uuid in artists_to_remove:\n            mpl_text = typing.cast(matplotlib.text.Text, renderer._artists[artist_uuid])\n            mpl_text.remove()  # remove from axes\n            del renderer._artists[artist_uuid]  # remove from renderer's artist dict\n\n        # =============================================================================\n        # Get existing artists\n        # =============================================================================\n\n        changed_artists: list[matplotlib.artist.Artist] = []\n        for text_index in range(len(texts.get_strings())):\n            artist_uuid = f\"{artist_uuid_base}_{text_index}\"\n            mpl_text = typing.cast(matplotlib.text.Text, renderer._artists[artist_uuid])\n            mpl_text.set_visible(True)\n\n            # =============================================================================\n            # Update artists\n            # =============================================================================\n\n            mpl_text.set_x(vertices_2d[text_index, 0])\n            mpl_text.set_y(vertices_2d[text_index, 1])\n            mpl_text.set_text(texts.get_strings()[text_index])\n            mpl_text.set_rotation(angles_numpy[text_index] / np.pi * 180.0)  # convert rad to deg\n            # print(f\"angles_numpy[{text_index}]: {angles_numpy[text_index]}\")\n\n            ha_label = \"center\" if anchors_numpy[text_index, 0] == 0.0 else \"right\" if anchors_numpy[text_index, 0] == 1.0 else \"left\"\n            mpl_text.set_horizontalalignment(ha_label)\n            va_label = \"center\" if anchors_numpy[text_index, 1] == 0.0 else \"top\" if anchors_numpy[text_index, 1] == 1.0 else \"bottom\"\n            mpl_text.set_verticalalignment(va_label)\n\n            mpl_text.set_fontfamily(texts.get_font_name())\n            mpl_text.set_fontsize(font_sizes_numpy[text_index])\n            mpl_text.set_color(typing.cast(tuple, colors_numpy[text_index]))\n\n            # Return the list of artists created/updated\n            changed_artists.append(mpl_text)\n\n        return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_texts.RendererTexts.render","title":"<code>render(renderer: MatplotlibRenderer, viewport: Viewport, texts: Texts, model_matrix: TransBuf, camera: Camera) -&gt; list[matplotlib.artist.Artist]</code>  <code>staticmethod</code>","text":"<p>Render Texts visual using Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer</code> <p>The MatplotlibRenderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The Viewport in which to render.</p> required <code>texts</code> <code>gsp.visuals.texts.Texts</code> <p>The Texts visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model transformation matrix as a TransBuf.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The Camera providing view and projection matrices.</p> required <p>Returns:</p> Type Description <code>list[matplotlib.artist.Artist]</code> <p>list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_texts.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: MatplotlibRenderer,\n    viewport: Viewport,\n    texts: Texts,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; list[matplotlib.artist.Artist]:\n    \"\"\"Render Texts visual using Matplotlib.\n\n    Args:\n        renderer: The MatplotlibRenderer instance.\n        viewport: The Viewport in which to render.\n        texts: The Texts visual to render.\n        model_matrix: The model transformation matrix as a TransBuf.\n        camera: The Camera providing view and projection matrices.\n\n    Returns:\n        list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n    \"\"\"\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(texts.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 2D - shape (N, 2)\n    vertices_2d = vertices_3d_transformed[:, :2]\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    # Convert all attributes to buffer\n    colors_buffer = TransBufUtils.to_buffer(texts.get_colors())\n    font_sizes_buffer = TransBufUtils.to_buffer(texts.get_font_sizes())\n    anchors_buffer = TransBufUtils.to_buffer(texts.get_anchors())\n    angles_buffer = TransBufUtils.to_buffer(texts.get_angles())\n\n    # Convert buffers to numpy arrays\n    font_sizes_numpy = Bufferx.to_numpy(font_sizes_buffer).flatten()\n    colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n    anchors_numpy = Bufferx.to_numpy(anchors_buffer)\n    angles_numpy = Bufferx.to_numpy(angles_buffer).flatten()\n\n    # =============================================================================\n    # Sanity checks attributes buffers\n    # =============================================================================\n\n    Texts.sanity_check_attributes_buffer(\n        vertices_buffer,\n        texts.get_strings(),\n        colors_buffer,\n        font_sizes_buffer,\n        anchors_buffer,\n        angles_buffer,\n        texts.get_font_name(),\n    )\n\n    # =============================================================================\n    # Create the artists if needed\n    # =============================================================================\n\n    artist_uuid_base = f\"{viewport.get_uuid()}_{texts.get_uuid()}\"\n    for text_index in range(len(texts.get_strings())):\n        artist_uuid = f\"{artist_uuid_base}_{text_index}\"\n        if artist_uuid in renderer._artists:\n            continue\n        mpl_text = matplotlib.text.Text()\n        mpl_text.set_visible(False)\n        # hide until properly positioned and sized\n        renderer._artists[artist_uuid] = mpl_text\n        mpl_axes = renderer.get_mpl_axes_for_viewport(viewport)\n        mpl_axes.add_artist(mpl_text)\n\n    # Remove extra artists if the number of text strings has decreased\n    existing_artist_uuids = [f\"{artist_uuid_base}_{i}\" for i in range(len(texts.get_strings()))]\n    artists_to_remove = [uuid for uuid in renderer._artists.keys() if uuid.startswith(artist_uuid_base) and uuid not in existing_artist_uuids]\n    for artist_uuid in artists_to_remove:\n        mpl_text = typing.cast(matplotlib.text.Text, renderer._artists[artist_uuid])\n        mpl_text.remove()  # remove from axes\n        del renderer._artists[artist_uuid]  # remove from renderer's artist dict\n\n    # =============================================================================\n    # Get existing artists\n    # =============================================================================\n\n    changed_artists: list[matplotlib.artist.Artist] = []\n    for text_index in range(len(texts.get_strings())):\n        artist_uuid = f\"{artist_uuid_base}_{text_index}\"\n        mpl_text = typing.cast(matplotlib.text.Text, renderer._artists[artist_uuid])\n        mpl_text.set_visible(True)\n\n        # =============================================================================\n        # Update artists\n        # =============================================================================\n\n        mpl_text.set_x(vertices_2d[text_index, 0])\n        mpl_text.set_y(vertices_2d[text_index, 1])\n        mpl_text.set_text(texts.get_strings()[text_index])\n        mpl_text.set_rotation(angles_numpy[text_index] / np.pi * 180.0)  # convert rad to deg\n        # print(f\"angles_numpy[{text_index}]: {angles_numpy[text_index]}\")\n\n        ha_label = \"center\" if anchors_numpy[text_index, 0] == 0.0 else \"right\" if anchors_numpy[text_index, 0] == 1.0 else \"left\"\n        mpl_text.set_horizontalalignment(ha_label)\n        va_label = \"center\" if anchors_numpy[text_index, 1] == 0.0 else \"top\" if anchors_numpy[text_index, 1] == 1.0 else \"bottom\"\n        mpl_text.set_verticalalignment(va_label)\n\n        mpl_text.set_fontfamily(texts.get_font_name())\n        mpl_text.set_fontsize(font_sizes_numpy[text_index])\n        mpl_text.set_color(typing.cast(tuple, colors_numpy[text_index]))\n\n        # Return the list of artists created/updated\n        changed_artists.append(mpl_text)\n\n    return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#extra-module","title":"Extra Module","text":"<p>The extra module provides additional utilities and extensions for Matplotlib rendering.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra","title":"<code>gsp_matplotlib.extra</code>","text":"<p>GSP Matplotlib extra utilities package initialization.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.Bufferx","title":"<code>Bufferx</code>","text":"<p>Utility class for Buffer extended functionality using numpy.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>class Bufferx:\n    \"\"\"Utility class for Buffer extended functionality using numpy.\"\"\"\n\n    # =============================================================================\n    # Matrix functions\n    # =============================================================================\n\n    @staticmethod\n    def mat4_identity() -&gt; Buffer:\n        \"\"\"Create a Buffer containing a 4x4 identity matrix.\"\"\"\n        mat4_numpy = np.asarray([np.identity(4, dtype=np.float32)])\n        buffer = Bufferx.from_numpy(mat4_numpy, BufferType.mat4)\n        return buffer\n\n    # =============================================================================\n    # .to_numpy/.from_numpy\n    # =============================================================================\n    @staticmethod\n    def to_numpy(buffer: Buffer) -&gt; np.ndarray:\n        \"\"\"Convert a Buffer to a numpy array.\"\"\"\n        if buffer.get_type() == BufferType.float32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.int8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.int8).reshape((count, 1))\n        elif buffer.get_type() == BufferType.int32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.int32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.uint8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 1))\n        elif buffer.get_type() == BufferType.uint32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.vec2:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 2))\n        elif buffer.get_type() == BufferType.vec3:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 3))\n        elif buffer.get_type() == BufferType.vec4:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4))\n        elif buffer.get_type() == BufferType.mat4:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4, 4))\n        elif buffer.get_type() == BufferType.rgba8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 4))\n        else:\n            raise NotImplementedError(f\"unable to convert buffer {buffer} to numpy array\")\n\n    @staticmethod\n    def from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer:\n        \"\"\"Create a Buffer from a numpy array.\"\"\"\n        if bufferType == BufferType.float32:\n            # sanity check\n            assert array_numpy.dtype == np.float32, f\"Numpy array must be of dtype float32, got {array_numpy.dtype}\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.uint32:\n            # sanity check\n            assert array_numpy.dtype == np.uint32, f\"Numpy array must be of dtype uint32, got {array_numpy.dtype}\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.vec2:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 2, f\"Numpy array must be of shape (2,), got {array_numpy.shape}\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.vec3:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 3, f\"Numpy array must be of shape (3,), got {array_numpy.shape}\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.mat4:\n            # sanity check\n            assert (\n                array_numpy.shape.__len__() == 3 and array_numpy.shape[1] == 4 and array_numpy.shape[2] == 4\n            ), f\"Numpy array must be of shape (4, 4), got {array_numpy.shape}\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, 1)\n            return buffer\n        elif bufferType == BufferType.rgba8:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 4, f\"Numpy array must be of shape (4,), got {array_numpy.shape} \"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.uint8).tobytes()), 0, count)\n            return buffer\n        else:\n            raise NotImplementedError(f\"unable to create a {bufferType} buffer from numpy array of shape {array_numpy.shape} and dtype {array_numpy.dtype}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.Bufferx.mat4_identity","title":"<code>mat4_identity() -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Create a Buffer containing a 4x4 identity matrix.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef mat4_identity() -&gt; Buffer:\n    \"\"\"Create a Buffer containing a 4x4 identity matrix.\"\"\"\n    mat4_numpy = np.asarray([np.identity(4, dtype=np.float32)])\n    buffer = Bufferx.from_numpy(mat4_numpy, BufferType.mat4)\n    return buffer\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.Bufferx.to_numpy","title":"<code>to_numpy(buffer: Buffer) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Convert a Buffer to a numpy array.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef to_numpy(buffer: Buffer) -&gt; np.ndarray:\n    \"\"\"Convert a Buffer to a numpy array.\"\"\"\n    if buffer.get_type() == BufferType.float32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.int8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.int8).reshape((count, 1))\n    elif buffer.get_type() == BufferType.int32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.int32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.uint8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 1))\n    elif buffer.get_type() == BufferType.uint32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.vec2:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 2))\n    elif buffer.get_type() == BufferType.vec3:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 3))\n    elif buffer.get_type() == BufferType.vec4:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4))\n    elif buffer.get_type() == BufferType.mat4:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4, 4))\n    elif buffer.get_type() == BufferType.rgba8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 4))\n    else:\n        raise NotImplementedError(f\"unable to convert buffer {buffer} to numpy array\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.Bufferx.from_numpy","title":"<code>from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Create a Buffer from a numpy array.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer:\n    \"\"\"Create a Buffer from a numpy array.\"\"\"\n    if bufferType == BufferType.float32:\n        # sanity check\n        assert array_numpy.dtype == np.float32, f\"Numpy array must be of dtype float32, got {array_numpy.dtype}\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.uint32:\n        # sanity check\n        assert array_numpy.dtype == np.uint32, f\"Numpy array must be of dtype uint32, got {array_numpy.dtype}\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.vec2:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 2, f\"Numpy array must be of shape (2,), got {array_numpy.shape}\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.vec3:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 3, f\"Numpy array must be of shape (3,), got {array_numpy.shape}\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.mat4:\n        # sanity check\n        assert (\n            array_numpy.shape.__len__() == 3 and array_numpy.shape[1] == 4 and array_numpy.shape[2] == 4\n        ), f\"Numpy array must be of shape (4, 4), got {array_numpy.shape}\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, 1)\n        return buffer\n    elif bufferType == BufferType.rgba8:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 4, f\"Numpy array must be of shape (4,), got {array_numpy.shape} \"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.uint8).tobytes()), 0, count)\n        return buffer\n    else:\n        raise NotImplementedError(f\"unable to create a {bufferType} buffer from numpy array of shape {array_numpy.shape} and dtype {array_numpy.dtype}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#bufferx","title":"Bufferx","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx","title":"<code>gsp_matplotlib.extra.bufferx</code>","text":"<p>Utility class for Buffer extended functionality using numpy.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx.Bufferx","title":"<code>Bufferx</code>","text":"<p>Utility class for Buffer extended functionality using numpy.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>class Bufferx:\n    \"\"\"Utility class for Buffer extended functionality using numpy.\"\"\"\n\n    # =============================================================================\n    # Matrix functions\n    # =============================================================================\n\n    @staticmethod\n    def mat4_identity() -&gt; Buffer:\n        \"\"\"Create a Buffer containing a 4x4 identity matrix.\"\"\"\n        mat4_numpy = np.asarray([np.identity(4, dtype=np.float32)])\n        buffer = Bufferx.from_numpy(mat4_numpy, BufferType.mat4)\n        return buffer\n\n    # =============================================================================\n    # .to_numpy/.from_numpy\n    # =============================================================================\n    @staticmethod\n    def to_numpy(buffer: Buffer) -&gt; np.ndarray:\n        \"\"\"Convert a Buffer to a numpy array.\"\"\"\n        if buffer.get_type() == BufferType.float32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.int8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.int8).reshape((count, 1))\n        elif buffer.get_type() == BufferType.int32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.int32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.uint8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 1))\n        elif buffer.get_type() == BufferType.uint32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.vec2:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 2))\n        elif buffer.get_type() == BufferType.vec3:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 3))\n        elif buffer.get_type() == BufferType.vec4:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4))\n        elif buffer.get_type() == BufferType.mat4:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4, 4))\n        elif buffer.get_type() == BufferType.rgba8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 4))\n        else:\n            raise NotImplementedError(f\"unable to convert buffer {buffer} to numpy array\")\n\n    @staticmethod\n    def from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer:\n        \"\"\"Create a Buffer from a numpy array.\"\"\"\n        if bufferType == BufferType.float32:\n            # sanity check\n            assert array_numpy.dtype == np.float32, f\"Numpy array must be of dtype float32, got {array_numpy.dtype}\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.uint32:\n            # sanity check\n            assert array_numpy.dtype == np.uint32, f\"Numpy array must be of dtype uint32, got {array_numpy.dtype}\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.vec2:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 2, f\"Numpy array must be of shape (2,), got {array_numpy.shape}\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.vec3:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 3, f\"Numpy array must be of shape (3,), got {array_numpy.shape}\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.mat4:\n            # sanity check\n            assert (\n                array_numpy.shape.__len__() == 3 and array_numpy.shape[1] == 4 and array_numpy.shape[2] == 4\n            ), f\"Numpy array must be of shape (4, 4), got {array_numpy.shape}\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, 1)\n            return buffer\n        elif bufferType == BufferType.rgba8:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 4, f\"Numpy array must be of shape (4,), got {array_numpy.shape} \"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.uint8).tobytes()), 0, count)\n            return buffer\n        else:\n            raise NotImplementedError(f\"unable to create a {bufferType} buffer from numpy array of shape {array_numpy.shape} and dtype {array_numpy.dtype}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx.Bufferx.from_numpy","title":"<code>from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Create a Buffer from a numpy array.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer:\n    \"\"\"Create a Buffer from a numpy array.\"\"\"\n    if bufferType == BufferType.float32:\n        # sanity check\n        assert array_numpy.dtype == np.float32, f\"Numpy array must be of dtype float32, got {array_numpy.dtype}\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.uint32:\n        # sanity check\n        assert array_numpy.dtype == np.uint32, f\"Numpy array must be of dtype uint32, got {array_numpy.dtype}\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.vec2:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 2, f\"Numpy array must be of shape (2,), got {array_numpy.shape}\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.vec3:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 3, f\"Numpy array must be of shape (3,), got {array_numpy.shape}\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.mat4:\n        # sanity check\n        assert (\n            array_numpy.shape.__len__() == 3 and array_numpy.shape[1] == 4 and array_numpy.shape[2] == 4\n        ), f\"Numpy array must be of shape (4, 4), got {array_numpy.shape}\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, 1)\n        return buffer\n    elif bufferType == BufferType.rgba8:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 4, f\"Numpy array must be of shape (4,), got {array_numpy.shape} \"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.uint8).tobytes()), 0, count)\n        return buffer\n    else:\n        raise NotImplementedError(f\"unable to create a {bufferType} buffer from numpy array of shape {array_numpy.shape} and dtype {array_numpy.dtype}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx.Bufferx.mat4_identity","title":"<code>mat4_identity() -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Create a Buffer containing a 4x4 identity matrix.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef mat4_identity() -&gt; Buffer:\n    \"\"\"Create a Buffer containing a 4x4 identity matrix.\"\"\"\n    mat4_numpy = np.asarray([np.identity(4, dtype=np.float32)])\n    buffer = Bufferx.from_numpy(mat4_numpy, BufferType.mat4)\n    return buffer\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx.Bufferx.to_numpy","title":"<code>to_numpy(buffer: Buffer) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Convert a Buffer to a numpy array.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef to_numpy(buffer: Buffer) -&gt; np.ndarray:\n    \"\"\"Convert a Buffer to a numpy array.\"\"\"\n    if buffer.get_type() == BufferType.float32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.int8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.int8).reshape((count, 1))\n    elif buffer.get_type() == BufferType.int32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.int32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.uint8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 1))\n    elif buffer.get_type() == BufferType.uint32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.vec2:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 2))\n    elif buffer.get_type() == BufferType.vec3:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 3))\n    elif buffer.get_type() == BufferType.vec4:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4))\n    elif buffer.get_type() == BufferType.mat4:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4, 4))\n    elif buffer.get_type() == BufferType.rgba8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 4))\n    else:\n        raise NotImplementedError(f\"unable to convert buffer {buffer} to numpy array\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#utils-module","title":"Utils Module","text":"<p>The utils module provides converter utilities for the Matplotlib backend.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils","title":"<code>gsp_matplotlib.utils</code>","text":"<p>Utility module for GSP Matplotlib conversions.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.ConverterUtils","title":"<code>ConverterUtils</code>","text":"<p>Utility class for converting GSP types to Matplotlib types.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>class ConverterUtils:\n    \"\"\"Utility class for converting GSP types to Matplotlib types.\"\"\"\n\n    @staticmethod\n    def cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal[\"butt\", \"round\", \"projecting\"]:\n        \"\"\"Convert CapStyle enum to Matplotlib string.\n\n        Args:\n            gsp_cap_style (CapStyle): The GSP cap style.\n\n        Returns:\n            str: The corresponding Matplotlib cap style.\n        \"\"\"\n        if gsp_cap_style == CapStyle.BUTT:\n            return \"butt\"\n        elif gsp_cap_style == CapStyle.ROUND:\n            return \"round\"\n        elif gsp_cap_style == CapStyle.PROJECTING:\n            return \"projecting\"\n        else:\n            raise ValueError(f\"Unsupported CapStyle: {gsp_cap_style}\")\n\n    @staticmethod\n    def join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal[\"miter\", \"round\", \"bevel\"]:\n        \"\"\"Convert JoinStyle enum to Matplotlib string.\n\n        Args:\n            gsp_join_style (JoinStyle): The GSP join style.\n\n        Returns:\n            str: The corresponding Matplotlib join style.\n        \"\"\"\n        if gsp_join_style == JoinStyle.MITER:\n            return \"miter\"\n        elif gsp_join_style == JoinStyle.ROUND:\n            return \"round\"\n        elif gsp_join_style == JoinStyle.BEVEL:\n            return \"bevel\"\n        else:\n            raise ValueError(f\"Unsupported JoinStyle: {gsp_join_style}\")\n\n    @staticmethod\n    def marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str:\n        \"\"\"Convert GSP marker shape to Matplotlib marker shape.\n\n        Args:\n            gsp_marker_shape (MarkerShape): The GSP marker shape.\n\n        Returns:\n            str: The corresponding Matplotlib marker shape.\n        \"\"\"\n        if gsp_marker_shape == MarkerShape.disc:\n            mpl_marker_shape = \"o\"\n        elif gsp_marker_shape == MarkerShape.square:\n            mpl_marker_shape = \"s\"\n        elif gsp_marker_shape == MarkerShape.club:\n            mpl_marker_shape = r\"$\\clubsuit$\"\n        else:\n            raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n        return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.ConverterUtils.cap_style_gsp_to_mpl","title":"<code>cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal['butt', 'round', 'projecting']</code>  <code>staticmethod</code>","text":"<p>Convert CapStyle enum to Matplotlib string.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_cap_style</code> <code>gsp.types.CapStyle</code> <p>The GSP cap style.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>typing.Literal['butt', 'round', 'projecting']</code> <p>The corresponding Matplotlib cap style.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal[\"butt\", \"round\", \"projecting\"]:\n    \"\"\"Convert CapStyle enum to Matplotlib string.\n\n    Args:\n        gsp_cap_style (CapStyle): The GSP cap style.\n\n    Returns:\n        str: The corresponding Matplotlib cap style.\n    \"\"\"\n    if gsp_cap_style == CapStyle.BUTT:\n        return \"butt\"\n    elif gsp_cap_style == CapStyle.ROUND:\n        return \"round\"\n    elif gsp_cap_style == CapStyle.PROJECTING:\n        return \"projecting\"\n    else:\n        raise ValueError(f\"Unsupported CapStyle: {gsp_cap_style}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.ConverterUtils.join_style_gsp_to_mpl","title":"<code>join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal['miter', 'round', 'bevel']</code>  <code>staticmethod</code>","text":"<p>Convert JoinStyle enum to Matplotlib string.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_join_style</code> <code>gsp.types.JoinStyle</code> <p>The GSP join style.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>typing.Literal['miter', 'round', 'bevel']</code> <p>The corresponding Matplotlib join style.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal[\"miter\", \"round\", \"bevel\"]:\n    \"\"\"Convert JoinStyle enum to Matplotlib string.\n\n    Args:\n        gsp_join_style (JoinStyle): The GSP join style.\n\n    Returns:\n        str: The corresponding Matplotlib join style.\n    \"\"\"\n    if gsp_join_style == JoinStyle.MITER:\n        return \"miter\"\n    elif gsp_join_style == JoinStyle.ROUND:\n        return \"round\"\n    elif gsp_join_style == JoinStyle.BEVEL:\n        return \"bevel\"\n    else:\n        raise ValueError(f\"Unsupported JoinStyle: {gsp_join_style}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.ConverterUtils.marker_shape_gsp_to_mpl","title":"<code>marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert GSP marker shape to Matplotlib marker shape.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_marker_shape</code> <code>gsp.types.MarkerShape</code> <p>The GSP marker shape.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The corresponding Matplotlib marker shape.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str:\n    \"\"\"Convert GSP marker shape to Matplotlib marker shape.\n\n    Args:\n        gsp_marker_shape (MarkerShape): The GSP marker shape.\n\n    Returns:\n        str: The corresponding Matplotlib marker shape.\n    \"\"\"\n    if gsp_marker_shape == MarkerShape.disc:\n        mpl_marker_shape = \"o\"\n    elif gsp_marker_shape == MarkerShape.square:\n        mpl_marker_shape = \"s\"\n    elif gsp_marker_shape == MarkerShape.club:\n        mpl_marker_shape = r\"$\\clubsuit$\"\n    else:\n        raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n    return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_matplotlib/#converter-utils","title":"Converter Utils","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils","title":"<code>gsp_matplotlib.utils.converter_utils</code>","text":"<p>Utility class for converting GSP types to Matplotlib types.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils.ConverterUtils","title":"<code>ConverterUtils</code>","text":"<p>Utility class for converting GSP types to Matplotlib types.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>class ConverterUtils:\n    \"\"\"Utility class for converting GSP types to Matplotlib types.\"\"\"\n\n    @staticmethod\n    def cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal[\"butt\", \"round\", \"projecting\"]:\n        \"\"\"Convert CapStyle enum to Matplotlib string.\n\n        Args:\n            gsp_cap_style (CapStyle): The GSP cap style.\n\n        Returns:\n            str: The corresponding Matplotlib cap style.\n        \"\"\"\n        if gsp_cap_style == CapStyle.BUTT:\n            return \"butt\"\n        elif gsp_cap_style == CapStyle.ROUND:\n            return \"round\"\n        elif gsp_cap_style == CapStyle.PROJECTING:\n            return \"projecting\"\n        else:\n            raise ValueError(f\"Unsupported CapStyle: {gsp_cap_style}\")\n\n    @staticmethod\n    def join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal[\"miter\", \"round\", \"bevel\"]:\n        \"\"\"Convert JoinStyle enum to Matplotlib string.\n\n        Args:\n            gsp_join_style (JoinStyle): The GSP join style.\n\n        Returns:\n            str: The corresponding Matplotlib join style.\n        \"\"\"\n        if gsp_join_style == JoinStyle.MITER:\n            return \"miter\"\n        elif gsp_join_style == JoinStyle.ROUND:\n            return \"round\"\n        elif gsp_join_style == JoinStyle.BEVEL:\n            return \"bevel\"\n        else:\n            raise ValueError(f\"Unsupported JoinStyle: {gsp_join_style}\")\n\n    @staticmethod\n    def marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str:\n        \"\"\"Convert GSP marker shape to Matplotlib marker shape.\n\n        Args:\n            gsp_marker_shape (MarkerShape): The GSP marker shape.\n\n        Returns:\n            str: The corresponding Matplotlib marker shape.\n        \"\"\"\n        if gsp_marker_shape == MarkerShape.disc:\n            mpl_marker_shape = \"o\"\n        elif gsp_marker_shape == MarkerShape.square:\n            mpl_marker_shape = \"s\"\n        elif gsp_marker_shape == MarkerShape.club:\n            mpl_marker_shape = r\"$\\clubsuit$\"\n        else:\n            raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n        return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils.ConverterUtils.cap_style_gsp_to_mpl","title":"<code>cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal['butt', 'round', 'projecting']</code>  <code>staticmethod</code>","text":"<p>Convert CapStyle enum to Matplotlib string.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_cap_style</code> <code>gsp.types.CapStyle</code> <p>The GSP cap style.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>typing.Literal['butt', 'round', 'projecting']</code> <p>The corresponding Matplotlib cap style.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal[\"butt\", \"round\", \"projecting\"]:\n    \"\"\"Convert CapStyle enum to Matplotlib string.\n\n    Args:\n        gsp_cap_style (CapStyle): The GSP cap style.\n\n    Returns:\n        str: The corresponding Matplotlib cap style.\n    \"\"\"\n    if gsp_cap_style == CapStyle.BUTT:\n        return \"butt\"\n    elif gsp_cap_style == CapStyle.ROUND:\n        return \"round\"\n    elif gsp_cap_style == CapStyle.PROJECTING:\n        return \"projecting\"\n    else:\n        raise ValueError(f\"Unsupported CapStyle: {gsp_cap_style}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils.ConverterUtils.join_style_gsp_to_mpl","title":"<code>join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal['miter', 'round', 'bevel']</code>  <code>staticmethod</code>","text":"<p>Convert JoinStyle enum to Matplotlib string.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_join_style</code> <code>gsp.types.JoinStyle</code> <p>The GSP join style.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>typing.Literal['miter', 'round', 'bevel']</code> <p>The corresponding Matplotlib join style.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal[\"miter\", \"round\", \"bevel\"]:\n    \"\"\"Convert JoinStyle enum to Matplotlib string.\n\n    Args:\n        gsp_join_style (JoinStyle): The GSP join style.\n\n    Returns:\n        str: The corresponding Matplotlib join style.\n    \"\"\"\n    if gsp_join_style == JoinStyle.MITER:\n        return \"miter\"\n    elif gsp_join_style == JoinStyle.ROUND:\n        return \"round\"\n    elif gsp_join_style == JoinStyle.BEVEL:\n        return \"bevel\"\n    else:\n        raise ValueError(f\"Unsupported JoinStyle: {gsp_join_style}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils.ConverterUtils.marker_shape_gsp_to_mpl","title":"<code>marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert GSP marker shape to Matplotlib marker shape.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_marker_shape</code> <code>gsp.types.MarkerShape</code> <p>The GSP marker shape.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The corresponding Matplotlib marker shape.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str:\n    \"\"\"Convert GSP marker shape to Matplotlib marker shape.\n\n    Args:\n        gsp_marker_shape (MarkerShape): The GSP marker shape.\n\n    Returns:\n        str: The corresponding Matplotlib marker shape.\n    \"\"\"\n    if gsp_marker_shape == MarkerShape.disc:\n        mpl_marker_shape = \"o\"\n    elif gsp_marker_shape == MarkerShape.square:\n        mpl_marker_shape = \"s\"\n    elif gsp_marker_shape == MarkerShape.club:\n        mpl_marker_shape = r\"$\\clubsuit$\"\n    else:\n        raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n    return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_matplotlib/#viewport-events-matplotlib","title":"Viewport Events Matplotlib","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.viewport_events.viewport_events_matplotlib","title":"<code>gsp_matplotlib.viewport_events.viewport_events_matplotlib</code>","text":"<p>MatplotlibRenderer event handler for viewport events.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.viewport_events.viewport_events_matplotlib.ViewportEventsMatplotlib","title":"<code>ViewportEventsMatplotlib</code>","text":"<p>               Bases: <code>gsp.types.viewport_events_base.ViewportEventsBase</code></p> <p>MatplotlibRenderer event handler for viewport.</p> Source code in <code>src/gsp_matplotlib/viewport_events/viewport_events_matplotlib.py</code> <pre><code>class ViewportEventsMatplotlib(ViewportEventsBase):\n    \"\"\"MatplotlibRenderer event handler for viewport.\"\"\"\n\n    __slots__ = [\n        \"_renderer\",\n        \"_viewport\",\n        \"_has_key_focus\",\n        \"_mpl_key_press_cid\",\n        \"_mpl_key_release_cid\",\n        \"_mpl_button_press_cid\",\n        \"_mpl_button_release_cid\",\n        \"_mpl_mouse_move_cid\",\n        \"_mpl_scroll_event_cid\",\n        \"_mpl_resize_event_cid\",\n    ]\n\n    def __init__(self, renderer: MatplotlibRenderer, viewport: Viewport) -&gt; None:\n        \"\"\"Initialize the Matplotlib viewport event handler.\n\n        Args:\n            renderer: MatplotlibRenderer associated with this event handler.\n            viewport: Viewport associated with this event handler.\n        \"\"\"\n        self._renderer = renderer\n        \"\"\"MatplotlibRenderer associated with this event handler\"\"\"\n        self._viewport = viewport\n        \"\"\"viewport associated with this event handler\"\"\"\n        self._has_key_focus = False\n        \"\"\"True if this viewport has the keyboard focus\"\"\"\n\n        # Intanciate events\n        self.key_press_event = Event[KeyboardEventCallback]()\n        self.key_release_event = Event[KeyboardEventCallback]()\n        self.button_press_event = Event[MouseEventCallback]()\n        self.button_release_event = Event[MouseEventCallback]()\n        self.mouse_move_event = Event[MouseEventCallback]()\n        self.mouse_scroll_event = Event[MouseEventCallback]()\n        self.canvas_resize_event = Event[CanvasResizeEventCallback]()\n\n        # event connections\n        mpl_canvas: matplotlib.backend_bases.FigureCanvasBase = self._renderer.get_mpl_figure().canvas\n        self._mpl_key_press_cid = mpl_canvas.mpl_connect(\"key_press_event\", typing.cast(Any, self._on_key_press))\n        self._mpl_key_release_cid = mpl_canvas.mpl_connect(\"key_release_event\", typing.cast(Any, self._on_key_release))\n        self._mpl_button_press_cid = mpl_canvas.mpl_connect(\"button_press_event\", typing.cast(Any, self._on_button_press))\n        self._mpl_button_release_cid = mpl_canvas.mpl_connect(\"button_release_event\", typing.cast(Any, self._on_button_release))\n        self._mpl_mouse_move_cid = mpl_canvas.mpl_connect(\"motion_notify_event\", typing.cast(Any, self._on_mouse_move))\n        self._mpl_scroll_event_cid = mpl_canvas.mpl_connect(\"scroll_event\", typing.cast(Any, self._on_mouse_scroll))\n        self._mpl_resize_event_cid = mpl_canvas.mpl_connect(\"resize_event\", typing.cast(Any, self._on_canvas_resize))\n\n    def close(self):\n        \"\"\"Close the event handler and release resources.\"\"\"\n        mpl_canvas: matplotlib.backend_bases.FigureCanvasBase = self._renderer.get_mpl_figure().canvas\n        if self._mpl_key_press_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_key_press_cid)\n            self._mpl_key_press_cid = None\n        if self._mpl_key_release_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_key_release_cid)\n            self._mpl_key_release_cid = None\n        if self._mpl_button_press_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_button_press_cid)\n            self._mpl_button_press_cid = None\n        if self._mpl_button_release_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_button_release_cid)\n            self._mpl_button_release_cid = None\n        if self._mpl_mouse_move_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_mouse_move_cid)\n            self._mpl_mouse_move_cid = None\n        if self._mpl_scroll_event_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_scroll_event_cid)\n            self._mpl_scroll_event_cid = None\n        if self._mpl_resize_event_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_resize_event_cid)\n            self._mpl_resize_event_cid = None\n\n    # =============================================================================\n    # Matplotlib event handler\n    # =============================================================================\n\n    def _on_key_press(self, mpl_key_event: matplotlib.backend_bases.KeyEvent) -&gt; None:\n        # discard events outside the viewport\n        if self._has_key_focus is False:\n            return\n        # convert and dispatch event\n        keyboard_event = self._mpl_key_event_to_gsp(mpl_key_event, EventType.KEY_PRESS)\n        self.key_press_event.dispatch(keyboard_event)\n\n    def _on_key_release(self, mpl_key_event: matplotlib.backend_bases.KeyEvent) -&gt; None:\n        # discard events outside the viewport\n        if self._has_key_focus is False:\n            return\n        # convert and dispatch event\n        keyboard_event = self._mpl_key_event_to_gsp(mpl_key_event, EventType.KEY_RELEASE)\n        self.key_release_event.dispatch(keyboard_event)\n\n    def _on_button_press(self, mpl_mouse_event: matplotlib.backend_bases.MouseEvent) -&gt; None:\n        # print(\"matplotlib button press event:\", mpl_mouse_event)\n        # Set key focus if the event is inside the viewport, otherwise remove key focus\n        if self._viewport_contains_mpl_mouse_event(mpl_mouse_event):\n            self._has_key_focus = True\n        else:\n            self._has_key_focus = False\n\n        # discard events outside the viewport\n        if self._viewport_contains_mpl_mouse_event(mpl_mouse_event) is False:\n            return\n\n        # convert and dispatch event\n        mouse_event = self._mpl_mouse_event_to_gsp(mpl_mouse_event, EventType.BUTTON_PRESS)\n        self.button_press_event.dispatch(mouse_event)\n\n    def _on_button_release(self, mpl_mouse_event: matplotlib.backend_bases.MouseEvent) -&gt; None:\n        # print(\"matplotlib button release event:\", mpl_mouse_event)\n\n        # discard events outside the viewport\n        if self._viewport_contains_mpl_mouse_event(mpl_mouse_event) is False:\n            return\n        # convert and dispatch event\n        mouse_event = self._mpl_mouse_event_to_gsp(mpl_mouse_event, EventType.BUTTON_RELEASE)\n        self.button_release_event.dispatch(mouse_event)\n\n    def _on_mouse_move(self, mpl_mouse_event: matplotlib.backend_bases.MouseEvent) -&gt; None:\n        # discard events outside the viewport\n        if self._viewport_contains_mpl_mouse_event(mpl_mouse_event) is False:\n            return\n        # convert and dispatch event\n        mouse_event = self._mpl_mouse_event_to_gsp(mpl_mouse_event, EventType.MOUSE_MOVE)\n        self.mouse_move_event.dispatch(mouse_event)\n\n    def _on_mouse_scroll(self, mpl_mouse_event: matplotlib.backend_bases.MouseEvent) -&gt; None:\n        # discard events outside the viewport\n        if self._viewport_contains_mpl_mouse_event(mpl_mouse_event) is False:\n            return\n        # convert and dispatch event\n        mouse_event = self._mpl_mouse_event_to_gsp(mpl_mouse_event, EventType.MOUSE_SCROLL)\n        self.mouse_scroll_event.dispatch(mouse_event)\n\n    def _on_canvas_resize(self, mpl_resize_event: matplotlib.backend_bases.ResizeEvent) -&gt; None:\n        # dispatch canvas resize event\n        canvas_resize_event = CanvasResizeEvent(\n            viewport_uuid=self._viewport.get_uuid(),\n            event_type=EventType.CANVAS_RESIZE,\n            canvas_width_px=mpl_resize_event.width,\n            canvas_height_px=mpl_resize_event.height,\n        )\n        self.canvas_resize_event.dispatch(canvas_resize_event)\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    def _viewport_contains_mpl_mouse_event(self, mpl_mouse_event: matplotlib.backend_bases.MouseEvent) -&gt; bool:\n        \"\"\"Check if the matplotlib mouse event is inside this viewport.\n\n        Args:\n            mpl_mouse_event: Matplotlib mouse event.\n\n        Returns:\n            True if the mouse event is inside this viewport, False otherwise.\n        \"\"\"\n        mouse_x = mpl_mouse_event.x / UnitUtils.device_pixel_ratio()\n        mouse_y = mpl_mouse_event.y / UnitUtils.device_pixel_ratio()\n        if mouse_x &lt; self._viewport.get_x():\n            return False\n        if mouse_x &gt;= self._viewport.get_x() + self._viewport.get_width():\n            return False\n        if mouse_y &lt; self._viewport.get_y():\n            return False\n        if mouse_y &gt;= self._viewport.get_y() + self._viewport.get_height():\n            return False\n        return True\n\n    # =============================================================================\n    # Conversion matplotlib event to gsp events\n    # =============================================================================\n    def _mpl_mouse_event_to_gsp(self, mpl_mouse_event: matplotlib.backend_bases.MouseEvent, event_type: EventType) -&gt; MouseEvent:\n        # Sanity check\n        assert self._viewport_contains_mpl_mouse_event(mpl_mouse_event), \"Mouse event is outside the viewport\"\n\n        mouse_x = mpl_mouse_event.x / UnitUtils.device_pixel_ratio()\n        mouse_y = mpl_mouse_event.y / UnitUtils.device_pixel_ratio()\n        event_x: float = ((mouse_x - self._viewport.get_x()) / self._viewport.get_width() - 0.5) * 2.0\n        event_y: float = ((mouse_y - self._viewport.get_y()) / self._viewport.get_height() - 0.5) * 2.0\n\n        # print(f\"Converted mouse_x: {mouse_x}, mouse_y: {mouse_y} to event_x: {event_x}, event_y: {event_y}\")\n\n        mouse_event = MouseEvent(\n            viewport_uuid=self._viewport.get_uuid(),\n            event_type=event_type,\n            x_ndc=event_x,\n            y_ndc=event_y,\n            left_button=mpl_mouse_event.button == 1,\n            middle_button=mpl_mouse_event.button == 2,\n            right_button=mpl_mouse_event.button == 3,\n            scroll_steps=mpl_mouse_event.step if hasattr(mpl_mouse_event, \"step\") else 0.0,\n        )\n        return mouse_event\n\n    def _mpl_key_event_to_gsp(self, mpl_key_event: matplotlib.backend_bases.KeyEvent, event_type: EventType) -&gt; KeyEvent:\n        assert mpl_key_event.key is not None\n        keyboard_event = KeyEvent(\n            viewport_uuid=self._viewport.get_uuid(),\n            event_type=event_type,\n            key_name=mpl_key_event.key,\n        )\n        return keyboard_event\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.viewport_events.viewport_events_matplotlib.ViewportEventsMatplotlib.__init__","title":"<code>__init__(renderer: MatplotlibRenderer, viewport: Viewport) -&gt; None</code>","text":"<p>Initialize the Matplotlib viewport event handler.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.MatplotlibRenderer</code> <p>MatplotlibRenderer associated with this event handler.</p> required <code>viewport</code> <code>gsp.core.Viewport</code> <p>Viewport associated with this event handler.</p> required Source code in <code>src/gsp_matplotlib/viewport_events/viewport_events_matplotlib.py</code> <pre><code>def __init__(self, renderer: MatplotlibRenderer, viewport: Viewport) -&gt; None:\n    \"\"\"Initialize the Matplotlib viewport event handler.\n\n    Args:\n        renderer: MatplotlibRenderer associated with this event handler.\n        viewport: Viewport associated with this event handler.\n    \"\"\"\n    self._renderer = renderer\n    \"\"\"MatplotlibRenderer associated with this event handler\"\"\"\n    self._viewport = viewport\n    \"\"\"viewport associated with this event handler\"\"\"\n    self._has_key_focus = False\n    \"\"\"True if this viewport has the keyboard focus\"\"\"\n\n    # Intanciate events\n    self.key_press_event = Event[KeyboardEventCallback]()\n    self.key_release_event = Event[KeyboardEventCallback]()\n    self.button_press_event = Event[MouseEventCallback]()\n    self.button_release_event = Event[MouseEventCallback]()\n    self.mouse_move_event = Event[MouseEventCallback]()\n    self.mouse_scroll_event = Event[MouseEventCallback]()\n    self.canvas_resize_event = Event[CanvasResizeEventCallback]()\n\n    # event connections\n    mpl_canvas: matplotlib.backend_bases.FigureCanvasBase = self._renderer.get_mpl_figure().canvas\n    self._mpl_key_press_cid = mpl_canvas.mpl_connect(\"key_press_event\", typing.cast(Any, self._on_key_press))\n    self._mpl_key_release_cid = mpl_canvas.mpl_connect(\"key_release_event\", typing.cast(Any, self._on_key_release))\n    self._mpl_button_press_cid = mpl_canvas.mpl_connect(\"button_press_event\", typing.cast(Any, self._on_button_press))\n    self._mpl_button_release_cid = mpl_canvas.mpl_connect(\"button_release_event\", typing.cast(Any, self._on_button_release))\n    self._mpl_mouse_move_cid = mpl_canvas.mpl_connect(\"motion_notify_event\", typing.cast(Any, self._on_mouse_move))\n    self._mpl_scroll_event_cid = mpl_canvas.mpl_connect(\"scroll_event\", typing.cast(Any, self._on_mouse_scroll))\n    self._mpl_resize_event_cid = mpl_canvas.mpl_connect(\"resize_event\", typing.cast(Any, self._on_canvas_resize))\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.viewport_events.viewport_events_matplotlib.ViewportEventsMatplotlib.close","title":"<code>close()</code>","text":"<p>Close the event handler and release resources.</p> Source code in <code>src/gsp_matplotlib/viewport_events/viewport_events_matplotlib.py</code> <pre><code>def close(self):\n    \"\"\"Close the event handler and release resources.\"\"\"\n    mpl_canvas: matplotlib.backend_bases.FigureCanvasBase = self._renderer.get_mpl_figure().canvas\n    if self._mpl_key_press_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_key_press_cid)\n        self._mpl_key_press_cid = None\n    if self._mpl_key_release_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_key_release_cid)\n        self._mpl_key_release_cid = None\n    if self._mpl_button_press_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_button_press_cid)\n        self._mpl_button_press_cid = None\n    if self._mpl_button_release_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_button_release_cid)\n        self._mpl_button_release_cid = None\n    if self._mpl_mouse_move_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_mouse_move_cid)\n        self._mpl_mouse_move_cid = None\n    if self._mpl_scroll_event_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_scroll_event_cid)\n        self._mpl_scroll_event_cid = None\n    if self._mpl_resize_event_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_resize_event_cid)\n        self._mpl_resize_event_cid = None\n</code></pre>"},{"location":"api/gsp_matplotlib/#animator-matplotlib","title":"Animator Matplotlib","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.animator.animator_matplotlib","title":"<code>gsp_matplotlib.animator.animator_matplotlib</code>","text":"<p>Matplotlib-based animator for GSP scenes.</p> <p>Provides animation capabilities using a MatplotlibRenderer backend with support for real-time animation display and video export.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.animator.animator_matplotlib.AnimatorMatplotlib","title":"<code>AnimatorMatplotlib</code>","text":"<p>               Bases: <code>gsp.types.animator_base.AnimatorBase</code></p> <p>Animator for GSP scenes using a Matplotlib renderer.</p> <p>Manages animation loops with callback functions that update visuals each frame. Supports real-time display and video export in various formats. Uses Matplotlib's FuncAnimation for efficient rendering updates.</p> Source code in <code>src/gsp_matplotlib/animator/animator_matplotlib.py</code> <pre><code>class AnimatorMatplotlib(AnimatorBase):\n    \"\"\"Animator for GSP scenes using a Matplotlib renderer.\n\n    Manages animation loops with callback functions that update visuals each frame.\n    Supports real-time display and video export in various formats. Uses Matplotlib's\n    FuncAnimation for efficient rendering updates.\n    \"\"\"\n\n    def __init__(\n        self,\n        matplotlib_renderer: MatplotlibRenderer,\n        fps: int = 50,\n        video_duration: float = 10.0,\n        video_path: str | None = None,\n        video_writer: str | None = None,\n    ):\n        \"\"\"Initialize the Matplotlib animator.\n\n        Args:\n            matplotlib_renderer: The Matplotlib renderer to use for rendering frames.\n            fps: Target frames per second for the animation.\n            video_duration: Total duration of the animation in seconds.\n            video_path: Path where the video should be saved. If None, no video is saved.\n            video_writer: Video writer to use (\"ffmpeg\" or \"pillow\"). If None, auto-detected from extension.\n\n        Raises:\n            ValueError: If the video format is not supported.\n        \"\"\"\n        self._callbacks: list[AnimatorFunc] = []\n        self._matplotlib_renderer = matplotlib_renderer\n        self._fps = fps\n        self._video_duration = video_duration\n        self._video_path = video_path\n        self._video_writer: str | None = None\n        self._time_last_update: float | None = None\n\n        self._funcAnimation: matplotlib.animation.FuncAnimation | None = None\n\n        self._canvas: Canvas | None = None\n        self._viewports: Sequence[Viewport] | None = None\n        self._visuals: Sequence[VisualBase] | None = None\n        self._model_matrices: Sequence[TransBuf] | None = None\n        self._cameras: Sequence[Camera] | None = None\n\n        self.on_video_saved = Event[VideoSavedCalledback]()\n        \"\"\"Event triggered when the video has been successfully saved to disk.\"\"\"\n\n        # guess the video writer from the file extension if not provided\n        if self._video_path is not None:\n            if video_writer is not None:\n                self._video_writer = video_writer\n            else:\n                video_ext = os.path.splitext(self._video_path)[1].lower()\n                if video_ext in [\".mp4\", \".m4v\", \".mov\"]:\n                    self._video_writer = \"ffmpeg\"\n                elif video_ext in [\".gif\", \".apng\", \".webp\"]:\n                    self._video_writer = \"pillow\"\n                else:\n                    raise ValueError(f\"Unsupported video format: {video_ext}\")\n\n    # =============================================================================\n    # .add_callback/.remove_callback/.decorator\n    # =============================================================================\n\n    def add_callback(self, func: AnimatorFunc) -&gt; None:\n        \"\"\"Add a callback to the animation loop.\n\n        Args:\n            func: The animator function to call on each frame.\n        \"\"\"\n        self._callbacks.append(func)\n\n    def remove_callback(self, func: AnimatorFunc) -&gt; None:\n        \"\"\"Remove a callback from the animation loop.\n\n        Args:\n            func: The animator function to remove.\n        \"\"\"\n        self._callbacks.remove(func)\n\n    def event_listener(self, func: AnimatorFunc) -&gt; AnimatorFunc:\n        \"\"\"Decorator to add a callback to the animation loop.\n\n        Args:\n            func: The animator function to register as a callback.\n\n        Returns:\n            The wrapped animator function.\n\n        Usage:\n            ```python\n                @animation_loop.event_listener\n                def my_callback(delta_time: float) -&gt; Sequence[VisualBase]:\n                    ...\n\n                # later, if needed\n                animation_loop.remove_callback(my_callback)\n            ```\n        \"\"\"\n        self.add_callback(func)\n\n        def wrapper(delta_time: float) -&gt; Sequence[VisualBase]:\n            # print(\"Before the function runs\")\n            result = func(delta_time)\n            # print(\"After the function runs\")\n            return result\n\n        return wrapper\n\n    # =============================================================================\n    # .start()\n    # =============================================================================\n    def start(self, viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; None:\n        \"\"\"Start the animation loop.\n\n        Begins rendering frames using registered callbacks to update visuals.\n        In test mode (GSP_TEST=True), saves a single preview image instead of animating.\n\n        Args:\n            viewports: Sequence of viewport regions to render into.\n            visuals: Sequence of visual elements to render and animate.\n            model_matrices: Sequence of model transformation matrices.\n            cameras: Sequence of cameras defining view and projection.\n        \"\"\"\n        self._canvas = self._matplotlib_renderer.get_canvas()\n        self._viewports = viewports\n        self._visuals = visuals\n        self._model_matrices = model_matrices\n        self._cameras = cameras\n        self._time_last_update = time.time()\n\n        # =============================================================================\n        # Render the image once\n        # =============================================================================\n\n        self._matplotlib_renderer.render(viewports, visuals, model_matrices, cameras)\n\n        # =============================================================================\n        # Handle GSP_TEST=True\n        # =============================================================================\n\n        # detect if we are in not interactive mode - used during testing\n        in_test = \"GSP_TEST\" in os.environ and os.environ[\"GSP_TEST\"] == \"True\"\n\n        # if we are not in interactive mode, save a preview image and return\n        if in_test == True:\n            # notify all animator callbacks\n            changed_visuals: list[VisualBase] = []\n            for animator_callback in self._callbacks:\n                _changed_visuals = animator_callback(1.0 / self._fps)\n                changed_visuals.extend(_changed_visuals)\n\n            # render the scene to get the new image\n            image_png_data = self._matplotlib_renderer.render(viewports, visuals, model_matrices, cameras, return_image=True, image_format=\"png\")\n            # get the main script name\n            main_script_name = os.path.basename(__main__.__file__) if hasattr(__main__, \"__file__\") else \"interactive\"\n            main_script_basename = os.path.splitext(main_script_name)[0]\n            # buid the output image path\n            image_path = os.path.join(__dirname__, \"../../../examples/output\", f\"{main_script_basename}_animator_matplotlib.png\")\n            image_path = os.path.abspath(image_path)\n            # save image_png_data in a image file\n            with open(image_path, \"wb\") as image_file:\n                image_file.write(image_png_data)\n            # log the event\n            print(f\"Saved animation preview image to: {image_path}\")\n            return\n\n        # NOTE: here we are in interactive mode!!\n\n        # =============================================================================\n        # Initialize the animation\n        # =============================================================================\n\n        figure = self._matplotlib_renderer.get_mpl_figure()\n        self._funcAnimation = matplotlib.animation.FuncAnimation(\n            figure, self._mpl_animate, frames=int(self._video_duration * self._fps), interval=1000.0 / self._fps\n        )\n\n        # save the animation if a path is provided\n        if self._video_path is not None:\n            self._funcAnimation.save(self._video_path, writer=self._video_writer, fps=self._fps)\n            # Dispatch the video saved event\n            self.on_video_saved.dispatch()\n\n        # =============================================================================\n        # Show the animation\n        # =============================================================================\n\n        self._matplotlib_renderer.show()\n\n    # =============================================================================\n    # .stop()\n    # =============================================================================\n    def stop(self):\n        \"\"\"Stop the animation loop.\n\n        Stops the Matplotlib animation timer and clears internal state.\n        \"\"\"\n        self._canvas = None\n        self._viewports = None\n        self._time_last_update = None\n\n        # stop the animation function timer\n        if self._funcAnimation is not None:\n            self._funcAnimation.event_source.stop()\n            self._funcAnimation = None\n\n    # =============================================================================\n    # ._mpl_animate()\n    # =============================================================================\n\n    def _mpl_animate(self, frame_index: int) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Internal callback for Matplotlib animation.\n\n        Called by Matplotlib's FuncAnimation on each frame to update the display.\n        Notifies all registered callbacks and re-renders changed visuals.\n\n        Args:\n            frame_index: The current frame number in the animation sequence.\n\n        Returns:\n            List of Matplotlib artists that were updated during this frame.\n        \"\"\"\n        # sanity checks\n        assert self._canvas is not None, \"Canvas MUST be set during the animation\"\n        assert self._viewports is not None, \"Viewports MUST be set during the animation\"\n        assert self._visuals is not None, \"Visuals MUST be set during the animation\"\n        assert self._model_matrices is not None, \"Model matrices MUST be set during the animation\"\n        assert self._cameras is not None, \"Cameras MUST be set during the animation\"\n\n        # compute delta time\n        present = time.time()\n        delta_time = (present - self._time_last_update) if self._time_last_update is not None else (1 / self._fps)\n        self._time_last_update = present\n\n        # notify all animator callbacks\n        changed_visuals: list[VisualBase] = []\n        for callback in self._callbacks:\n            _changed_visuals = callback(delta_time)\n            changed_visuals.extend(_changed_visuals)\n\n        # Render the scene to update the visuals\n        self._matplotlib_renderer.render(self._viewports, self._visuals, self._model_matrices, self._cameras)\n\n        # convert all changed visuals to mpl artists\n        changed_mpl_artists: list[matplotlib.artist.Artist] = []\n        for visual in changed_visuals:\n            mpl_artists = self._get_mpl_artists(self._viewports, self._visuals, visual)\n            changed_mpl_artists.extend(mpl_artists)\n\n        # return the changed mpl artists\n        return changed_mpl_artists\n\n    # =============================================================================\n    # ._get_mpl_artists()\n    # =============================================================================\n\n    def _get_mpl_artists(self, viewports: Sequence[Viewport], visuals: Sequence[VisualBase], visual_base: VisualBase) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Get the Matplotlib artists corresponding to a given visual.\n\n        This is needed for Matplotlib's FuncAnimation to update only the relevant artists\n        that have changed, improving rendering performance.\n\n        Args:\n            viewports: Sequence of all viewports in the scene.\n            visuals: Sequence of all visuals in the scene.\n            visual_base: The specific visual to get artists for.\n\n        Returns:\n            List of Matplotlib Artist objects corresponding to the visual.\n\n        Raises:\n            NotImplementedError: If the visual type is not supported.\n        \"\"\"\n        mpl_artists: list[matplotlib.artist.Artist] = []\n\n        # Find the index of the visual in the visuals list\n        visual_index = visuals.index(visual_base)\n        visual = visuals[visual_index]\n        viewport = viewports[visual_index]\n\n        if isinstance(visual, Pixels):\n            pixels: Pixels = visual\n            positions_buffer = TransBufUtils.to_buffer(pixels.get_positions())\n            group_count = GroupUtils.get_group_count(positions_buffer.get_count(), pixels.get_groups())\n            artist_uuid_prefix = f\"{viewport.get_uuid()}_{visual.get_uuid()}\"\n            for group_index in range(group_count):\n                group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n                mpl_artists.append(self._matplotlib_renderer._artists[group_uuid])\n        elif isinstance(visual, Points):\n            points: Points = visual\n            artist_uuid = f\"{viewport.get_uuid()}_{points.get_uuid()}\"\n            mpl_artist = self._matplotlib_renderer._artists[artist_uuid]\n            mpl_artists.append(mpl_artist)\n        elif isinstance(visual, Texts):\n            texts: Texts = visual\n            for text_index in range(len(texts.get_strings())):\n                artist_uuid = f\"{viewport.get_uuid()}_{texts.get_uuid()}_{text_index}\"\n                mpl_artist = self._matplotlib_renderer._artists[artist_uuid]\n                mpl_artists.append(mpl_artist)\n        else:\n            raise NotImplementedError(f\"Getting mpl artists for visual type {type(visual)} is not implemented.\")\n\n        return mpl_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.animator.animator_matplotlib.AnimatorMatplotlib.on_video_saved","title":"<code>on_video_saved = Event[VideoSavedCalledback]()</code>  <code>instance-attribute</code>","text":"<p>Event triggered when the video has been successfully saved to disk.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.animator.animator_matplotlib.AnimatorMatplotlib.__init__","title":"<code>__init__(matplotlib_renderer: MatplotlibRenderer, fps: int = 50, video_duration: float = 10.0, video_path: str | None = None, video_writer: str | None = None)</code>","text":"<p>Initialize the Matplotlib animator.</p> <p>Parameters:</p> Name Type Description Default <code>matplotlib_renderer</code> <code>gsp_matplotlib.renderer.MatplotlibRenderer</code> <p>The Matplotlib renderer to use for rendering frames.</p> required <code>fps</code> <code>int</code> <p>Target frames per second for the animation.</p> <code>50</code> <code>video_duration</code> <code>float</code> <p>Total duration of the animation in seconds.</p> <code>10.0</code> <code>video_path</code> <code>str | None</code> <p>Path where the video should be saved. If None, no video is saved.</p> <code>None</code> <code>video_writer</code> <code>str | None</code> <p>Video writer to use (\"ffmpeg\" or \"pillow\"). If None, auto-detected from extension.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the video format is not supported.</p> Source code in <code>src/gsp_matplotlib/animator/animator_matplotlib.py</code> <pre><code>def __init__(\n    self,\n    matplotlib_renderer: MatplotlibRenderer,\n    fps: int = 50,\n    video_duration: float = 10.0,\n    video_path: str | None = None,\n    video_writer: str | None = None,\n):\n    \"\"\"Initialize the Matplotlib animator.\n\n    Args:\n        matplotlib_renderer: The Matplotlib renderer to use for rendering frames.\n        fps: Target frames per second for the animation.\n        video_duration: Total duration of the animation in seconds.\n        video_path: Path where the video should be saved. If None, no video is saved.\n        video_writer: Video writer to use (\"ffmpeg\" or \"pillow\"). If None, auto-detected from extension.\n\n    Raises:\n        ValueError: If the video format is not supported.\n    \"\"\"\n    self._callbacks: list[AnimatorFunc] = []\n    self._matplotlib_renderer = matplotlib_renderer\n    self._fps = fps\n    self._video_duration = video_duration\n    self._video_path = video_path\n    self._video_writer: str | None = None\n    self._time_last_update: float | None = None\n\n    self._funcAnimation: matplotlib.animation.FuncAnimation | None = None\n\n    self._canvas: Canvas | None = None\n    self._viewports: Sequence[Viewport] | None = None\n    self._visuals: Sequence[VisualBase] | None = None\n    self._model_matrices: Sequence[TransBuf] | None = None\n    self._cameras: Sequence[Camera] | None = None\n\n    self.on_video_saved = Event[VideoSavedCalledback]()\n    \"\"\"Event triggered when the video has been successfully saved to disk.\"\"\"\n\n    # guess the video writer from the file extension if not provided\n    if self._video_path is not None:\n        if video_writer is not None:\n            self._video_writer = video_writer\n        else:\n            video_ext = os.path.splitext(self._video_path)[1].lower()\n            if video_ext in [\".mp4\", \".m4v\", \".mov\"]:\n                self._video_writer = \"ffmpeg\"\n            elif video_ext in [\".gif\", \".apng\", \".webp\"]:\n                self._video_writer = \"pillow\"\n            else:\n                raise ValueError(f\"Unsupported video format: {video_ext}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.animator.animator_matplotlib.AnimatorMatplotlib.add_callback","title":"<code>add_callback(func: AnimatorFunc) -&gt; None</code>","text":"<p>Add a callback to the animation loop.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>gsp.types.animator_types.AnimatorFunc</code> <p>The animator function to call on each frame.</p> required Source code in <code>src/gsp_matplotlib/animator/animator_matplotlib.py</code> <pre><code>def add_callback(self, func: AnimatorFunc) -&gt; None:\n    \"\"\"Add a callback to the animation loop.\n\n    Args:\n        func: The animator function to call on each frame.\n    \"\"\"\n    self._callbacks.append(func)\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.animator.animator_matplotlib.AnimatorMatplotlib.event_listener","title":"<code>event_listener(func: AnimatorFunc) -&gt; AnimatorFunc</code>","text":"<p>Decorator to add a callback to the animation loop.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>gsp.types.animator_types.AnimatorFunc</code> <p>The animator function to register as a callback.</p> required <p>Returns:</p> Type Description <code>gsp.types.animator_types.AnimatorFunc</code> <p>The wrapped animator function.</p> Usage <pre><code>    @animation_loop.event_listener\n    def my_callback(delta_time: float) -&gt; Sequence[VisualBase]:\n        ...\n\n    # later, if needed\n    animation_loop.remove_callback(my_callback)\n</code></pre> Source code in <code>src/gsp_matplotlib/animator/animator_matplotlib.py</code> <pre><code>def event_listener(self, func: AnimatorFunc) -&gt; AnimatorFunc:\n    \"\"\"Decorator to add a callback to the animation loop.\n\n    Args:\n        func: The animator function to register as a callback.\n\n    Returns:\n        The wrapped animator function.\n\n    Usage:\n        ```python\n            @animation_loop.event_listener\n            def my_callback(delta_time: float) -&gt; Sequence[VisualBase]:\n                ...\n\n            # later, if needed\n            animation_loop.remove_callback(my_callback)\n        ```\n    \"\"\"\n    self.add_callback(func)\n\n    def wrapper(delta_time: float) -&gt; Sequence[VisualBase]:\n        # print(\"Before the function runs\")\n        result = func(delta_time)\n        # print(\"After the function runs\")\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.animator.animator_matplotlib.AnimatorMatplotlib.remove_callback","title":"<code>remove_callback(func: AnimatorFunc) -&gt; None</code>","text":"<p>Remove a callback from the animation loop.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>gsp.types.animator_types.AnimatorFunc</code> <p>The animator function to remove.</p> required Source code in <code>src/gsp_matplotlib/animator/animator_matplotlib.py</code> <pre><code>def remove_callback(self, func: AnimatorFunc) -&gt; None:\n    \"\"\"Remove a callback from the animation loop.\n\n    Args:\n        func: The animator function to remove.\n    \"\"\"\n    self._callbacks.remove(func)\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.animator.animator_matplotlib.AnimatorMatplotlib.start","title":"<code>start(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; None</code>","text":"<p>Start the animation loop.</p> <p>Begins rendering frames using registered callbacks to update visuals. In test mode (GSP_TEST=True), saves a single preview image instead of animating.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>Sequence of viewport regions to render into.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>Sequence of visual elements to render and animate.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>Sequence of model transformation matrices.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>Sequence of cameras defining view and projection.</p> required Source code in <code>src/gsp_matplotlib/animator/animator_matplotlib.py</code> <pre><code>def start(self, viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; None:\n    \"\"\"Start the animation loop.\n\n    Begins rendering frames using registered callbacks to update visuals.\n    In test mode (GSP_TEST=True), saves a single preview image instead of animating.\n\n    Args:\n        viewports: Sequence of viewport regions to render into.\n        visuals: Sequence of visual elements to render and animate.\n        model_matrices: Sequence of model transformation matrices.\n        cameras: Sequence of cameras defining view and projection.\n    \"\"\"\n    self._canvas = self._matplotlib_renderer.get_canvas()\n    self._viewports = viewports\n    self._visuals = visuals\n    self._model_matrices = model_matrices\n    self._cameras = cameras\n    self._time_last_update = time.time()\n\n    # =============================================================================\n    # Render the image once\n    # =============================================================================\n\n    self._matplotlib_renderer.render(viewports, visuals, model_matrices, cameras)\n\n    # =============================================================================\n    # Handle GSP_TEST=True\n    # =============================================================================\n\n    # detect if we are in not interactive mode - used during testing\n    in_test = \"GSP_TEST\" in os.environ and os.environ[\"GSP_TEST\"] == \"True\"\n\n    # if we are not in interactive mode, save a preview image and return\n    if in_test == True:\n        # notify all animator callbacks\n        changed_visuals: list[VisualBase] = []\n        for animator_callback in self._callbacks:\n            _changed_visuals = animator_callback(1.0 / self._fps)\n            changed_visuals.extend(_changed_visuals)\n\n        # render the scene to get the new image\n        image_png_data = self._matplotlib_renderer.render(viewports, visuals, model_matrices, cameras, return_image=True, image_format=\"png\")\n        # get the main script name\n        main_script_name = os.path.basename(__main__.__file__) if hasattr(__main__, \"__file__\") else \"interactive\"\n        main_script_basename = os.path.splitext(main_script_name)[0]\n        # buid the output image path\n        image_path = os.path.join(__dirname__, \"../../../examples/output\", f\"{main_script_basename}_animator_matplotlib.png\")\n        image_path = os.path.abspath(image_path)\n        # save image_png_data in a image file\n        with open(image_path, \"wb\") as image_file:\n            image_file.write(image_png_data)\n        # log the event\n        print(f\"Saved animation preview image to: {image_path}\")\n        return\n\n    # NOTE: here we are in interactive mode!!\n\n    # =============================================================================\n    # Initialize the animation\n    # =============================================================================\n\n    figure = self._matplotlib_renderer.get_mpl_figure()\n    self._funcAnimation = matplotlib.animation.FuncAnimation(\n        figure, self._mpl_animate, frames=int(self._video_duration * self._fps), interval=1000.0 / self._fps\n    )\n\n    # save the animation if a path is provided\n    if self._video_path is not None:\n        self._funcAnimation.save(self._video_path, writer=self._video_writer, fps=self._fps)\n        # Dispatch the video saved event\n        self.on_video_saved.dispatch()\n\n    # =============================================================================\n    # Show the animation\n    # =============================================================================\n\n    self._matplotlib_renderer.show()\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.animator.animator_matplotlib.AnimatorMatplotlib.stop","title":"<code>stop()</code>","text":"<p>Stop the animation loop.</p> <p>Stops the Matplotlib animation timer and clears internal state.</p> Source code in <code>src/gsp_matplotlib/animator/animator_matplotlib.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the animation loop.\n\n    Stops the Matplotlib animation timer and clears internal state.\n    \"\"\"\n    self._canvas = None\n    self._viewports = None\n    self._time_last_update = None\n\n    # stop the animation function timer\n    if self._funcAnimation is not None:\n        self._funcAnimation.event_source.stop()\n        self._funcAnimation = None\n</code></pre>"},{"location":"api/gsp_network/","title":"GSP Network API Reference","text":"<p>The GSP Network module provides network-based rendering capabilities, enabling remote visualization and client-server architectures.</p>"},{"location":"api/gsp_network/#overview","title":"Overview","text":""},{"location":"api/gsp_network/#gsp_network","title":"<code>gsp_network</code>","text":"<p>gsp_network provides functionality for rendering graphics over a network using different remote renderers.</p>"},{"location":"api/gsp_network/#renderer-module","title":"Renderer Module","text":"<p>The renderer module contains the network renderer implementation for remote rendering.</p>"},{"location":"api/gsp_network/#gsp_network.renderer","title":"<code>gsp_network.renderer</code>","text":"<p>Network renderer that sends rendering requests to a remote server and displays the results using Matplotlib.</p>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer","title":"<code>NetworkRenderer</code>","text":"<p>               Bases: <code>gsp.types.renderer_base.RendererBase</code></p> <p>Note: this requires a running gsp_network server. See the README for instructions.</p> <p>IMPORTANT: it DOES NOT depend on GSP matplotlib renderer, it only uses pip matplotlib to display the remotely rendered images.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>class NetworkRenderer(RendererBase):\n    \"\"\"**Note**: this requires a running gsp_network server. See the README for instructions.\n\n    **IMPORTANT**: it DOES NOT depend on GSP matplotlib renderer, it only uses pip matplotlib to display the remotely rendered images.\n    \"\"\"\n\n    def __init__(self, canvas: Canvas, server_base_url: str, remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = \"matplotlib\") -&gt; None:\n        \"\"\"Initialize the NetworkRenderer.\n\n        Args:\n            canvas (Canvas): _description_\n            server_base_url (str): _description_\n            remote_renderer_name (Literal[\"matplotlib\", \"datoviz\"], optional): _description_. Defaults to \"matplotlib\".\n        \"\"\"\n        self._canvas = canvas\n        self._server_base_url = server_base_url\n        self._remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = remote_renderer_name\n\n        # Create a figure\n        figure_width = self._canvas.get_width() / self._canvas.get_dpi()\n        figure_height = self._canvas.get_height() / self._canvas.get_dpi()\n        self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=self._canvas.get_dpi())\n        assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n        self._figure.canvas.manager.set_window_title(f\"Network ({self._remote_renderer_name})\")\n\n        # get the only axes in the figure\n        self._mpl_axes = self._figure.add_axes((0, 0, 1, 1))\n        # hide the borders\n        self._mpl_axes.axis(\"off\")\n\n        # create an np.array to hold the image\n        image_data_np = np.zeros((self._canvas.get_height(), self._canvas.get_width(), 3), dtype=np.uint8)\n        self._axes_image = self._mpl_axes.imshow(image_data_np, aspect=\"auto\")\n\n    def get_canvas(self) -&gt; Canvas:\n        \"\"\"Get the canvas associated with the network renderer.\n\n        Returns:\n            Canvas: The canvas associated with the network renderer.\n        \"\"\"\n        return self._canvas\n\n    def close(self) -&gt; None:\n        \"\"\"Close the network renderer and release resources.\"\"\"\n        # stop the event loop if any - thus .show(block=True) will return\n        self._figure.canvas.stop_event_loop()\n        # close the figure\n        matplotlib.pyplot.close(self._figure)\n        self._figure = None  # type: ignore\n\n    def get_remote_renderer_name(self) -&gt; Literal[\"matplotlib\", \"datoviz\"]:\n        \"\"\"Get the name of the remote renderer being used.\n\n        Returns:\n            Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.\n        \"\"\"\n        return self._remote_renderer_name\n\n    def render(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n    ) -&gt; bytes:\n        \"\"\"Render the scene remotely and update the matplotlib figure with the rendered image.\n\n        Args:\n            viewports (Sequence[Viewport]): The viewports to render.\n            visuals (Sequence[VisualBase]): The visuals to render.\n            model_matrices (Sequence[TransBuf]): The model matrices for the visuals.\n            cameras (Sequence[Camera]): The cameras to use for rendering.\n\n        Returns:\n            bytes: The rendered image data in PNG format.\n\n        Raises:\n            Exception: If the network request fails.\n        \"\"\"\n        # =============================================================================\n        # Serialize the scene and create the payload\n        # =============================================================================\n        pydanticSerializer = PydanticSerializer(self._canvas)\n        pydantic_scene_dict = pydanticSerializer.serialize(\n            viewports=viewports,\n            visuals=visuals,\n            model_matrices=model_matrices,\n            cameras=cameras,\n        )\n\n        payload: NetworkPayload = {\n            \"renderer_name\": self._remote_renderer_name,\n            \"data\": pydantic_scene_dict,\n        }\n\n        # =============================================================================\n        # do network request to send the payload and get the rendered image\n        # =============================================================================\n        # Send the POST request with JSON data\n        call_url = f\"{self._server_base_url}/render\"\n        headers = {\"Content-Type\": \"application/json\"}\n        response = requests.post(call_url, data=json.dumps(payload), headers=headers)\n\n        # Check the response status\n        if response.status_code != HttpStatus.OK:\n            raise Exception(f\"Request failed with status code {response.status_code}\")\n        image_png_data = response.content\n\n        # =============================================================================\n        # Render the image in the matplotlib figure\n        # =============================================================================\n        assert self._axes_image is not None, \"PANIC self._axes_image is None\"\n        # update the image data\n        image_data_io = io.BytesIO(image_png_data)\n        image_data_np = matplotlib.image.imread(image_data_io, format=\"png\")\n        self._axes_image.set_data(image_data_np)\n\n        # return png data as bytes\n        return image_png_data\n\n    def show(self) -&gt; None:\n        \"\"\"Show the rendered canvas (blocking call).\"\"\"\n        # handle non-interactive mode for tests\n        in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n        if in_test:\n            return\n\n        matplotlib.pyplot.show()\n\n    def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n        \"\"\"Get the underlying Matplotlib figure.\n\n        Returns:\n            matplotlib.figure.Figure: The Matplotlib figure used by the renderer.\n        \"\"\"\n        return self._figure\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.__init__","title":"<code>__init__(canvas: Canvas, server_base_url: str, remote_renderer_name: Literal['matplotlib', 'datoviz'] = 'matplotlib') -&gt; None</code>","text":"<p>Initialize the NetworkRenderer.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>gsp.core.canvas.Canvas</code> <p>description</p> required <code>server_base_url</code> <code>str</code> <p>description</p> required <code>remote_renderer_name</code> <code>typing.Literal['matplotlib', 'datoviz']</code> <p>description. Defaults to \"matplotlib\".</p> <code>'matplotlib'</code> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def __init__(self, canvas: Canvas, server_base_url: str, remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = \"matplotlib\") -&gt; None:\n    \"\"\"Initialize the NetworkRenderer.\n\n    Args:\n        canvas (Canvas): _description_\n        server_base_url (str): _description_\n        remote_renderer_name (Literal[\"matplotlib\", \"datoviz\"], optional): _description_. Defaults to \"matplotlib\".\n    \"\"\"\n    self._canvas = canvas\n    self._server_base_url = server_base_url\n    self._remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = remote_renderer_name\n\n    # Create a figure\n    figure_width = self._canvas.get_width() / self._canvas.get_dpi()\n    figure_height = self._canvas.get_height() / self._canvas.get_dpi()\n    self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=self._canvas.get_dpi())\n    assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n    self._figure.canvas.manager.set_window_title(f\"Network ({self._remote_renderer_name})\")\n\n    # get the only axes in the figure\n    self._mpl_axes = self._figure.add_axes((0, 0, 1, 1))\n    # hide the borders\n    self._mpl_axes.axis(\"off\")\n\n    # create an np.array to hold the image\n    image_data_np = np.zeros((self._canvas.get_height(), self._canvas.get_width(), 3), dtype=np.uint8)\n    self._axes_image = self._mpl_axes.imshow(image_data_np, aspect=\"auto\")\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.get_canvas","title":"<code>get_canvas() -&gt; Canvas</code>","text":"<p>Get the canvas associated with the network renderer.</p> <p>Returns:</p> Name Type Description <code>Canvas</code> <code>gsp.core.canvas.Canvas</code> <p>The canvas associated with the network renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_canvas(self) -&gt; Canvas:\n    \"\"\"Get the canvas associated with the network renderer.\n\n    Returns:\n        Canvas: The canvas associated with the network renderer.\n    \"\"\"\n    return self._canvas\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the network renderer and release resources.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the network renderer and release resources.\"\"\"\n    # stop the event loop if any - thus .show(block=True) will return\n    self._figure.canvas.stop_event_loop()\n    # close the figure\n    matplotlib.pyplot.close(self._figure)\n    self._figure = None  # type: ignore\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.get_remote_renderer_name","title":"<code>get_remote_renderer_name() -&gt; Literal['matplotlib', 'datoviz']</code>","text":"<p>Get the name of the remote renderer being used.</p> <p>Returns:</p> Type Description <code>typing.Literal['matplotlib', 'datoviz']</code> <p>Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_remote_renderer_name(self) -&gt; Literal[\"matplotlib\", \"datoviz\"]:\n    \"\"\"Get the name of the remote renderer being used.\n\n    Returns:\n        Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.\n    \"\"\"\n    return self._remote_renderer_name\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.render","title":"<code>render(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; bytes</code>","text":"<p>Render the scene remotely and update the matplotlib figure with the rendered image.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>The viewports to render.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>The visuals to render.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>The model matrices for the visuals.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>The cameras to use for rendering.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The rendered image data in PNG format.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the network request fails.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def render(\n    self,\n    viewports: Sequence[Viewport],\n    visuals: Sequence[VisualBase],\n    model_matrices: Sequence[TransBuf],\n    cameras: Sequence[Camera],\n) -&gt; bytes:\n    \"\"\"Render the scene remotely and update the matplotlib figure with the rendered image.\n\n    Args:\n        viewports (Sequence[Viewport]): The viewports to render.\n        visuals (Sequence[VisualBase]): The visuals to render.\n        model_matrices (Sequence[TransBuf]): The model matrices for the visuals.\n        cameras (Sequence[Camera]): The cameras to use for rendering.\n\n    Returns:\n        bytes: The rendered image data in PNG format.\n\n    Raises:\n        Exception: If the network request fails.\n    \"\"\"\n    # =============================================================================\n    # Serialize the scene and create the payload\n    # =============================================================================\n    pydanticSerializer = PydanticSerializer(self._canvas)\n    pydantic_scene_dict = pydanticSerializer.serialize(\n        viewports=viewports,\n        visuals=visuals,\n        model_matrices=model_matrices,\n        cameras=cameras,\n    )\n\n    payload: NetworkPayload = {\n        \"renderer_name\": self._remote_renderer_name,\n        \"data\": pydantic_scene_dict,\n    }\n\n    # =============================================================================\n    # do network request to send the payload and get the rendered image\n    # =============================================================================\n    # Send the POST request with JSON data\n    call_url = f\"{self._server_base_url}/render\"\n    headers = {\"Content-Type\": \"application/json\"}\n    response = requests.post(call_url, data=json.dumps(payload), headers=headers)\n\n    # Check the response status\n    if response.status_code != HttpStatus.OK:\n        raise Exception(f\"Request failed with status code {response.status_code}\")\n    image_png_data = response.content\n\n    # =============================================================================\n    # Render the image in the matplotlib figure\n    # =============================================================================\n    assert self._axes_image is not None, \"PANIC self._axes_image is None\"\n    # update the image data\n    image_data_io = io.BytesIO(image_png_data)\n    image_data_np = matplotlib.image.imread(image_data_io, format=\"png\")\n    self._axes_image.set_data(image_data_np)\n\n    # return png data as bytes\n    return image_png_data\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.show","title":"<code>show() -&gt; None</code>","text":"<p>Show the rendered canvas (blocking call).</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the rendered canvas (blocking call).\"\"\"\n    # handle non-interactive mode for tests\n    in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n    if in_test:\n        return\n\n    matplotlib.pyplot.show()\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.get_mpl_figure","title":"<code>get_mpl_figure() -&gt; matplotlib.figure.Figure</code>","text":"<p>Get the underlying Matplotlib figure.</p> <p>Returns:</p> Type Description <code>matplotlib.figure.Figure</code> <p>matplotlib.figure.Figure: The Matplotlib figure used by the renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n    \"\"\"Get the underlying Matplotlib figure.\n\n    Returns:\n        matplotlib.figure.Figure: The Matplotlib figure used by the renderer.\n    \"\"\"\n    return self._figure\n</code></pre>"},{"location":"api/gsp_network/#network-renderer","title":"Network Renderer","text":""},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer","title":"<code>gsp_network.renderer.network_renderer</code>","text":"<p>Network renderer that sends rendering requests to a remote server and displays the results using Matplotlib.</p>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkPayload","title":"<code>NetworkPayload</code>","text":"<p>               Bases: <code>typing.TypedDict</code></p> <p>Type definition for the network payload sent to the server.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>class NetworkPayload(TypedDict):\n    \"\"\"Type definition for the network payload sent to the server.\"\"\"\n    renderer_name: Literal[\"matplotlib\", \"datoviz\"]\n    data: PydanticDict\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer","title":"<code>NetworkRenderer</code>","text":"<p>               Bases: <code>gsp.types.renderer_base.RendererBase</code></p> <p>Note: this requires a running gsp_network server. See the README for instructions.</p> <p>IMPORTANT: it DOES NOT depend on GSP matplotlib renderer, it only uses pip matplotlib to display the remotely rendered images.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>class NetworkRenderer(RendererBase):\n    \"\"\"**Note**: this requires a running gsp_network server. See the README for instructions.\n\n    **IMPORTANT**: it DOES NOT depend on GSP matplotlib renderer, it only uses pip matplotlib to display the remotely rendered images.\n    \"\"\"\n\n    def __init__(self, canvas: Canvas, server_base_url: str, remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = \"matplotlib\") -&gt; None:\n        \"\"\"Initialize the NetworkRenderer.\n\n        Args:\n            canvas (Canvas): _description_\n            server_base_url (str): _description_\n            remote_renderer_name (Literal[\"matplotlib\", \"datoviz\"], optional): _description_. Defaults to \"matplotlib\".\n        \"\"\"\n        self._canvas = canvas\n        self._server_base_url = server_base_url\n        self._remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = remote_renderer_name\n\n        # Create a figure\n        figure_width = self._canvas.get_width() / self._canvas.get_dpi()\n        figure_height = self._canvas.get_height() / self._canvas.get_dpi()\n        self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=self._canvas.get_dpi())\n        assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n        self._figure.canvas.manager.set_window_title(f\"Network ({self._remote_renderer_name})\")\n\n        # get the only axes in the figure\n        self._mpl_axes = self._figure.add_axes((0, 0, 1, 1))\n        # hide the borders\n        self._mpl_axes.axis(\"off\")\n\n        # create an np.array to hold the image\n        image_data_np = np.zeros((self._canvas.get_height(), self._canvas.get_width(), 3), dtype=np.uint8)\n        self._axes_image = self._mpl_axes.imshow(image_data_np, aspect=\"auto\")\n\n    def get_canvas(self) -&gt; Canvas:\n        \"\"\"Get the canvas associated with the network renderer.\n\n        Returns:\n            Canvas: The canvas associated with the network renderer.\n        \"\"\"\n        return self._canvas\n\n    def close(self) -&gt; None:\n        \"\"\"Close the network renderer and release resources.\"\"\"\n        # stop the event loop if any - thus .show(block=True) will return\n        self._figure.canvas.stop_event_loop()\n        # close the figure\n        matplotlib.pyplot.close(self._figure)\n        self._figure = None  # type: ignore\n\n    def get_remote_renderer_name(self) -&gt; Literal[\"matplotlib\", \"datoviz\"]:\n        \"\"\"Get the name of the remote renderer being used.\n\n        Returns:\n            Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.\n        \"\"\"\n        return self._remote_renderer_name\n\n    def render(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n    ) -&gt; bytes:\n        \"\"\"Render the scene remotely and update the matplotlib figure with the rendered image.\n\n        Args:\n            viewports (Sequence[Viewport]): The viewports to render.\n            visuals (Sequence[VisualBase]): The visuals to render.\n            model_matrices (Sequence[TransBuf]): The model matrices for the visuals.\n            cameras (Sequence[Camera]): The cameras to use for rendering.\n\n        Returns:\n            bytes: The rendered image data in PNG format.\n\n        Raises:\n            Exception: If the network request fails.\n        \"\"\"\n        # =============================================================================\n        # Serialize the scene and create the payload\n        # =============================================================================\n        pydanticSerializer = PydanticSerializer(self._canvas)\n        pydantic_scene_dict = pydanticSerializer.serialize(\n            viewports=viewports,\n            visuals=visuals,\n            model_matrices=model_matrices,\n            cameras=cameras,\n        )\n\n        payload: NetworkPayload = {\n            \"renderer_name\": self._remote_renderer_name,\n            \"data\": pydantic_scene_dict,\n        }\n\n        # =============================================================================\n        # do network request to send the payload and get the rendered image\n        # =============================================================================\n        # Send the POST request with JSON data\n        call_url = f\"{self._server_base_url}/render\"\n        headers = {\"Content-Type\": \"application/json\"}\n        response = requests.post(call_url, data=json.dumps(payload), headers=headers)\n\n        # Check the response status\n        if response.status_code != HttpStatus.OK:\n            raise Exception(f\"Request failed with status code {response.status_code}\")\n        image_png_data = response.content\n\n        # =============================================================================\n        # Render the image in the matplotlib figure\n        # =============================================================================\n        assert self._axes_image is not None, \"PANIC self._axes_image is None\"\n        # update the image data\n        image_data_io = io.BytesIO(image_png_data)\n        image_data_np = matplotlib.image.imread(image_data_io, format=\"png\")\n        self._axes_image.set_data(image_data_np)\n\n        # return png data as bytes\n        return image_png_data\n\n    def show(self) -&gt; None:\n        \"\"\"Show the rendered canvas (blocking call).\"\"\"\n        # handle non-interactive mode for tests\n        in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n        if in_test:\n            return\n\n        matplotlib.pyplot.show()\n\n    def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n        \"\"\"Get the underlying Matplotlib figure.\n\n        Returns:\n            matplotlib.figure.Figure: The Matplotlib figure used by the renderer.\n        \"\"\"\n        return self._figure\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.__init__","title":"<code>__init__(canvas: Canvas, server_base_url: str, remote_renderer_name: Literal['matplotlib', 'datoviz'] = 'matplotlib') -&gt; None</code>","text":"<p>Initialize the NetworkRenderer.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>gsp.core.canvas.Canvas</code> <p>description</p> required <code>server_base_url</code> <code>str</code> <p>description</p> required <code>remote_renderer_name</code> <code>typing.Literal['matplotlib', 'datoviz']</code> <p>description. Defaults to \"matplotlib\".</p> <code>'matplotlib'</code> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def __init__(self, canvas: Canvas, server_base_url: str, remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = \"matplotlib\") -&gt; None:\n    \"\"\"Initialize the NetworkRenderer.\n\n    Args:\n        canvas (Canvas): _description_\n        server_base_url (str): _description_\n        remote_renderer_name (Literal[\"matplotlib\", \"datoviz\"], optional): _description_. Defaults to \"matplotlib\".\n    \"\"\"\n    self._canvas = canvas\n    self._server_base_url = server_base_url\n    self._remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = remote_renderer_name\n\n    # Create a figure\n    figure_width = self._canvas.get_width() / self._canvas.get_dpi()\n    figure_height = self._canvas.get_height() / self._canvas.get_dpi()\n    self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=self._canvas.get_dpi())\n    assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n    self._figure.canvas.manager.set_window_title(f\"Network ({self._remote_renderer_name})\")\n\n    # get the only axes in the figure\n    self._mpl_axes = self._figure.add_axes((0, 0, 1, 1))\n    # hide the borders\n    self._mpl_axes.axis(\"off\")\n\n    # create an np.array to hold the image\n    image_data_np = np.zeros((self._canvas.get_height(), self._canvas.get_width(), 3), dtype=np.uint8)\n    self._axes_image = self._mpl_axes.imshow(image_data_np, aspect=\"auto\")\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the network renderer and release resources.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the network renderer and release resources.\"\"\"\n    # stop the event loop if any - thus .show(block=True) will return\n    self._figure.canvas.stop_event_loop()\n    # close the figure\n    matplotlib.pyplot.close(self._figure)\n    self._figure = None  # type: ignore\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.get_canvas","title":"<code>get_canvas() -&gt; Canvas</code>","text":"<p>Get the canvas associated with the network renderer.</p> <p>Returns:</p> Name Type Description <code>Canvas</code> <code>gsp.core.canvas.Canvas</code> <p>The canvas associated with the network renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_canvas(self) -&gt; Canvas:\n    \"\"\"Get the canvas associated with the network renderer.\n\n    Returns:\n        Canvas: The canvas associated with the network renderer.\n    \"\"\"\n    return self._canvas\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.get_mpl_figure","title":"<code>get_mpl_figure() -&gt; matplotlib.figure.Figure</code>","text":"<p>Get the underlying Matplotlib figure.</p> <p>Returns:</p> Type Description <code>matplotlib.figure.Figure</code> <p>matplotlib.figure.Figure: The Matplotlib figure used by the renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n    \"\"\"Get the underlying Matplotlib figure.\n\n    Returns:\n        matplotlib.figure.Figure: The Matplotlib figure used by the renderer.\n    \"\"\"\n    return self._figure\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.get_remote_renderer_name","title":"<code>get_remote_renderer_name() -&gt; Literal['matplotlib', 'datoviz']</code>","text":"<p>Get the name of the remote renderer being used.</p> <p>Returns:</p> Type Description <code>typing.Literal['matplotlib', 'datoviz']</code> <p>Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_remote_renderer_name(self) -&gt; Literal[\"matplotlib\", \"datoviz\"]:\n    \"\"\"Get the name of the remote renderer being used.\n\n    Returns:\n        Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.\n    \"\"\"\n    return self._remote_renderer_name\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.render","title":"<code>render(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; bytes</code>","text":"<p>Render the scene remotely and update the matplotlib figure with the rendered image.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>The viewports to render.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>The visuals to render.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>The model matrices for the visuals.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>The cameras to use for rendering.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The rendered image data in PNG format.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the network request fails.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def render(\n    self,\n    viewports: Sequence[Viewport],\n    visuals: Sequence[VisualBase],\n    model_matrices: Sequence[TransBuf],\n    cameras: Sequence[Camera],\n) -&gt; bytes:\n    \"\"\"Render the scene remotely and update the matplotlib figure with the rendered image.\n\n    Args:\n        viewports (Sequence[Viewport]): The viewports to render.\n        visuals (Sequence[VisualBase]): The visuals to render.\n        model_matrices (Sequence[TransBuf]): The model matrices for the visuals.\n        cameras (Sequence[Camera]): The cameras to use for rendering.\n\n    Returns:\n        bytes: The rendered image data in PNG format.\n\n    Raises:\n        Exception: If the network request fails.\n    \"\"\"\n    # =============================================================================\n    # Serialize the scene and create the payload\n    # =============================================================================\n    pydanticSerializer = PydanticSerializer(self._canvas)\n    pydantic_scene_dict = pydanticSerializer.serialize(\n        viewports=viewports,\n        visuals=visuals,\n        model_matrices=model_matrices,\n        cameras=cameras,\n    )\n\n    payload: NetworkPayload = {\n        \"renderer_name\": self._remote_renderer_name,\n        \"data\": pydantic_scene_dict,\n    }\n\n    # =============================================================================\n    # do network request to send the payload and get the rendered image\n    # =============================================================================\n    # Send the POST request with JSON data\n    call_url = f\"{self._server_base_url}/render\"\n    headers = {\"Content-Type\": \"application/json\"}\n    response = requests.post(call_url, data=json.dumps(payload), headers=headers)\n\n    # Check the response status\n    if response.status_code != HttpStatus.OK:\n        raise Exception(f\"Request failed with status code {response.status_code}\")\n    image_png_data = response.content\n\n    # =============================================================================\n    # Render the image in the matplotlib figure\n    # =============================================================================\n    assert self._axes_image is not None, \"PANIC self._axes_image is None\"\n    # update the image data\n    image_data_io = io.BytesIO(image_png_data)\n    image_data_np = matplotlib.image.imread(image_data_io, format=\"png\")\n    self._axes_image.set_data(image_data_np)\n\n    # return png data as bytes\n    return image_png_data\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.show","title":"<code>show() -&gt; None</code>","text":"<p>Show the rendered canvas (blocking call).</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the rendered canvas (blocking call).\"\"\"\n    # handle non-interactive mode for tests\n    in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n    if in_test:\n        return\n\n    matplotlib.pyplot.show()\n</code></pre>"},{"location":"api/gsp_network/#tools-module","title":"Tools Module","text":"<p>The tools module provides server utilities for network-based rendering.</p>"},{"location":"api/gsp_network/#gsp_network.tools","title":"<code>gsp_network.tools</code>","text":"<p>tools package initialization.</p>"},{"location":"api/gsp_network/#network-server","title":"Network Server","text":""},{"location":"api/gsp_network/#gsp_network.tools.network_server","title":"<code>gsp_network.tools.network_server</code>","text":"<p>Server example using Flask to render a scene from JSON input.</p> <ul> <li>use Flask to create a simple web server</li> <li>render with matplotlib or datoviz based on environment variable</li> </ul>"},{"location":"api/gsp_network/#gsp_network.tools.network_server.ServerSample","title":"<code>ServerSample</code>","text":"<p>Sample class to demonstrate server functionality.</p> Source code in <code>src/gsp_network/tools/network_server.py</code> <pre><code>class ServerSample:\n    \"\"\"Sample class to demonstrate server functionality.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize the server sample.\"\"\"\n        pass\n\n    def run(self):\n        \"\"\"Run the Flask server.\"\"\"\n        flask_app.run(threaded=False, debug=False)  # Enable debug mode if desired\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.tools.network_server.ServerSample.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the server sample.</p> Source code in <code>src/gsp_network/tools/network_server.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the server sample.\"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.tools.network_server.ServerSample.run","title":"<code>run()</code>","text":"<p>Run the Flask server.</p> Source code in <code>src/gsp_network/tools/network_server.py</code> <pre><code>def run(self):\n    \"\"\"Run the Flask server.\"\"\"\n    flask_app.run(threaded=False, debug=False)  # Enable debug mode if desired\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.tools.network_server.render_scene_json","title":"<code>render_scene_json() -&gt; Response</code>","text":"<p>Flask route to render a scene from JSON input.</p> <p>Returns:</p> Name Type Description <code>Response</code> <code>flask.Response</code> <p>Flask response containing the rendered PNG image.</p> Source code in <code>src/gsp_network/tools/network_server.py</code> <pre><code>@flask_app.route(\"/render\", methods=[\"POST\"])\ndef render_scene_json() -&gt; Response:\n    \"\"\"Flask route to render a scene from JSON input.\n\n    Returns:\n        Response: Flask response containing the rendered PNG image.\n    \"\"\"\n    payload: NetworkPayload = request.get_json()\n\n    # Log the received payload for debugging\n    print(\"Received payload\")\n\n    ###############################################################################\n    # Load the scene from JSON\n    #\n\n    pydanticDict: PydanticDict = payload[\"data\"]\n\n    pydanticParser = PydanticParser()\n    parsed_canvas, parsed_viewports, parsed_visuals, parsed_model_matrices, parsed_cameras = pydanticParser.parse(pydanticDict)\n\n    ###############################################################################\n    # Render the loaded scene with matplotlib or datoviz based on environment variable\n    #\n    renderer_name = payload[\"renderer_name\"]\n    if renderer_name == \"matplotlib\":\n        renderer = MatplotlibRenderer(parsed_canvas)\n    else:\n        renderer = DatovizRenderer(parsed_canvas, offscreen=True)\n    image_png_data = renderer.render(parsed_viewports, parsed_visuals, parsed_model_matrices, parsed_cameras, return_image=True)\n\n    print(f\"Rendered image size: {text_cyan(str(len(image_png_data)))} bytes\")\n\n    ###############################################################################\n    # Return the rendered image as a PNG file\n    #\n    return send_file(\n        io.BytesIO(image_png_data),\n        mimetype=\"image/png\",\n        as_attachment=True,\n        download_name=\"rendered_scene.png\",\n    )\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.tools.network_server.text_cyan","title":"<code>text_cyan(text: str) -&gt; str</code>","text":"<p>Return the given text string wrapped in ANSI escape codes for cyan color.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to color.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The colored text string.</p> Source code in <code>src/gsp_network/tools/network_server.py</code> <pre><code>def text_cyan(text: str) -&gt; str:\n    \"\"\"Return the given text string wrapped in ANSI escape codes for cyan color.\n\n    Args:\n        text (str): The text to color.\n\n    Returns:\n        str: The colored text string.\n    \"\"\"\n    return colorama.Fore.CYAN + text + colorama.Style.RESET_ALL\n</code></pre>"},{"location":"api/gsp_network/#network-server-kill","title":"Network Server Kill","text":""},{"location":"api/gsp_network/#gsp_network.tools.network_server_kill","title":"<code>gsp_network.tools.network_server_kill</code>","text":"<p>Kill any process using port 5000 (commonly used for flask server).</p> <p>in shell: <code>lsof -ti tcp:5000 | xargs kill</code></p>"},{"location":"api/gsp_network/#gsp_network.tools.network_server_kill.main","title":"<code>main() -&gt; int</code>","text":"<p>Main function to kill processes using port 5000.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Exit code (0 for success, 1 for failure).</p> Source code in <code>src/gsp_network/tools/network_server_kill.py</code> <pre><code>def main() -&gt; int:\n    \"\"\"Main function to kill processes using port 5000.\n\n    Returns:\n        int: Exit code (0 for success, 1 for failure).\n    \"\"\"\n    # parse command line arguments\n    parser = argparse.ArgumentParser(description=\"Kill any process using port 5000 (commonly used for flask server).\")\n    _ = parser.parse_args()\n\n    port = 5000\n\n    try:\n        # Get the list of process IDs using the specified port\n        result = subprocess.run([\"lsof\", \"-ti\", f\"tcp:{port}\"], capture_output=True, text=True)\n        pids = result.stdout.strip().split(\"\\n\")\n\n        if pids == [\"\"]:\n            print(f\"No processes found using port {port}.\")\n            return 0\n\n        for pid in pids:\n            os.kill(int(pid), signal.SIGTERM)\n            print(f\"Killed process with PID: {pid} using port {port}.\")\n\n        return 0\n\n    except Exception as error:\n        print(f\"An error occurred: {error}\")\n        return 1\n</code></pre>"},{"location":"api/gsp_network/#viewport-events-network","title":"Viewport Events Network","text":""},{"location":"api/gsp_network/#gsp_network.viewport_events.viewport_events_network","title":"<code>gsp_network.viewport_events.viewport_events_network</code>","text":"<p>NetworkRenderer event handler for viewport events.</p>"},{"location":"api/gsp_network/#gsp_network.viewport_events.viewport_events_network.ViewportEventsNetwork","title":"<code>ViewportEventsNetwork</code>","text":"<p>               Bases: <code>gsp.types.viewport_events_base.ViewportEventsBase</code></p> <p>NetworkRenderer event handler for viewport.</p> <p>Code heavily inspired from ViewportEventsMatplotlib</p> Source code in <code>src/gsp_network/viewport_events/viewport_events_network.py</code> <pre><code>class ViewportEventsNetwork(ViewportEventsBase):\n    \"\"\"NetworkRenderer event handler for viewport.\n\n    Code heavily inspired from ViewportEventsMatplotlib\n    \"\"\"\n\n    __slots__ = [\n        \"_renderer\",\n        \"_viewport\",\n        \"_has_key_focus\",\n        \"_mpl_key_press_cid\",\n        \"_mpl_key_release_cid\",\n        \"_mpl_button_press_cid\",\n        \"_mpl_button_release_cid\",\n        \"_mpl_mouse_move_cid\",\n        \"_mpl_mouse_scroll_cid\",\n        \"_mpl_resize_cid\",\n    ]\n\n    def __init__(self, renderer: NetworkRenderer, viewport: Viewport) -&gt; None:\n        \"\"\"Initialize the event handler with a renderer and viewport.\n\n        Args:\n            renderer: NetworkRenderer associated with this event handler.\n            viewport: Viewport associated with this event handler.\n        \"\"\"\n        self._renderer = renderer\n        \"\"\"NetworkRenderer associated with this event handler\"\"\"\n        self._viewport = viewport\n        \"\"\"viewport associated with this event handler\"\"\"\n        self._has_key_focus = False\n        \"\"\"True if this viewport has the keyboard focus\"\"\"\n\n        # Intanciate events\n        self.key_press_event = Event[KeyboardEventCallback]()\n        self.key_release_event = Event[KeyboardEventCallback]()\n        self.button_press_event = Event[MouseEventCallback]()\n        self.button_release_event = Event[MouseEventCallback]()\n        self.mouse_move_event = Event[MouseEventCallback]()\n        self.mouse_scroll_event = Event[MouseEventCallback]()\n        self.canvas_resize_event = Event[CanvasResizeEventCallback]()\n\n        # event connections\n        mpl_canvas: matplotlib.backend_bases.FigureCanvasBase = self._renderer.get_mpl_figure().canvas\n        self._mpl_key_press_cid = mpl_canvas.mpl_connect(\"key_press_event\", typing.cast(Any, self._on_key_press))\n        self._mpl_key_release_cid = mpl_canvas.mpl_connect(\"key_release_event\", typing.cast(Any, self._on_key_release))\n        self._mpl_button_press_cid = mpl_canvas.mpl_connect(\"button_press_event\", typing.cast(Any, self._on_button_press))\n        self._mpl_button_release_cid = mpl_canvas.mpl_connect(\"button_release_event\", typing.cast(Any, self._on_button_release))\n        self._mpl_mouse_move_cid = mpl_canvas.mpl_connect(\"motion_notify_event\", typing.cast(Any, self._on_mouse_move))\n        self._mpl_mouse_scroll_cid = mpl_canvas.mpl_connect(\"scroll_event\", typing.cast(Any, self._on_mouse_scroll))\n        self._mpl_resize_cid = mpl_canvas.mpl_connect(\"resize_event\", typing.cast(Any, self._on_canvas_resize))\n\n    def close(self):\n        \"\"\"Close the event handler and release resources.\"\"\"\n        mpl_canvas: matplotlib.backend_bases.FigureCanvasBase = self._renderer.get_mpl_figure().canvas\n        if self._mpl_key_press_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_key_press_cid)\n            self._mpl_key_press_cid = None\n        if self._mpl_key_release_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_key_release_cid)\n            self._mpl_key_release_cid = None\n        if self._mpl_button_press_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_button_press_cid)\n            self._mpl_button_press_cid = None\n        if self._mpl_button_release_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_button_release_cid)\n            self._mpl_button_release_cid = None\n        if self._mpl_mouse_move_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_mouse_move_cid)\n            self._mpl_mouse_move_cid = None\n        if self._mpl_mouse_scroll_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_mouse_scroll_cid)\n            self._mpl_mouse_scroll_cid = None\n        if self._mpl_resize_cid is not None:\n            mpl_canvas.mpl_disconnect(self._mpl_resize_cid)\n            self._mpl_resize_cid = None\n\n    # =============================================================================\n    # Matplotlib event handler\n    # =============================================================================\n\n    def _on_key_press(self, mpl_key_event: matplotlib.backend_bases.KeyEvent) -&gt; None:\n        # discard events outside the viewport\n        if self._has_key_focus is False:\n            return\n        # convert and dispatch event\n        keyboard_event = self._mpl_key_event_to_gsp(mpl_key_event, EventType.KEY_PRESS)\n        self.key_press_event.dispatch(keyboard_event)\n\n    def _on_key_release(self, mpl_key_event: matplotlib.backend_bases.KeyEvent) -&gt; None:\n        # discard events outside the viewport\n        if self._has_key_focus is False:\n            return\n        # convert and dispatch event\n        keyboard_event = self._mpl_key_event_to_gsp(mpl_key_event, EventType.KEY_RELEASE)\n        self.key_release_event.dispatch(keyboard_event)\n\n    def _on_button_press(self, mpl_mouse_event: matplotlib.backend_bases.MouseEvent) -&gt; None:\n        # Set key focus if the event is inside the viewport, otherwise remove key focus\n        if self._viewport_contains_mpl_mouse_event(mpl_mouse_event):\n            self._has_key_focus = True\n        else:\n            self._has_key_focus = False\n\n        # discard events outside the viewport\n        if self._viewport_contains_mpl_mouse_event(mpl_mouse_event) is False:\n            return\n\n        # convert and dispatch event\n        mouse_event = self._mpl_mouse_event_to_gsp(mpl_mouse_event, EventType.BUTTON_PRESS)\n        self.button_press_event.dispatch(mouse_event)\n\n    def _on_button_release(self, mpl_mouse_event: matplotlib.backend_bases.MouseEvent) -&gt; None:\n        # discard events outside the viewport\n        if self._viewport_contains_mpl_mouse_event(mpl_mouse_event) is False:\n            return\n        # convert and dispatch event\n        mouse_event = self._mpl_mouse_event_to_gsp(mpl_mouse_event, EventType.BUTTON_RELEASE)\n        self.button_release_event.dispatch(mouse_event)\n\n    def _on_mouse_move(self, mpl_mouse_event: matplotlib.backend_bases.MouseEvent) -&gt; None:\n        # discard events outside the viewport\n        if self._viewport_contains_mpl_mouse_event(mpl_mouse_event) is False:\n            return\n        # convert and dispatch event\n        mouse_event = self._mpl_mouse_event_to_gsp(mpl_mouse_event, EventType.MOUSE_MOVE)\n        self.mouse_move_event.dispatch(mouse_event)\n\n    def _on_mouse_scroll(self, mpl_mouse_event: matplotlib.backend_bases.MouseEvent) -&gt; None:\n        # discard events outside the viewport\n        if self._viewport_contains_mpl_mouse_event(mpl_mouse_event) is False:\n            return\n        # convert and dispatch event\n        mouse_event = self._mpl_mouse_event_to_gsp(mpl_mouse_event, EventType.MOUSE_SCROLL)\n        self.mouse_scroll_event.dispatch(mouse_event)\n\n    def _on_canvas_resize(self, mpl_resize_event: matplotlib.backend_bases.ResizeEvent) -&gt; None:\n        # dispatch canvas resize event\n        canvas_resize_event = CanvasResizeEvent(\n            viewport_uuid=self._viewport.get_uuid(),\n            event_type=EventType.CANVAS_RESIZE,\n            canvas_width_px=mpl_resize_event.width,\n            canvas_height_px=mpl_resize_event.height,\n        )\n        self.canvas_resize_event.dispatch(canvas_resize_event)\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    def _viewport_contains_mpl_mouse_event(self, mpl_mouse_event: matplotlib.backend_bases.MouseEvent) -&gt; bool:\n        \"\"\"Check if the matplotlib mouse event is inside this viewport.\n\n        Args:\n            mpl_mouse_event: Matplotlib mouse event.\n\n        Returns:\n            True if the mouse event is inside this viewport, False otherwise.\n        \"\"\"\n        mouse_x = mpl_mouse_event.x / UnitUtils.device_pixel_ratio()\n        mouse_y = mpl_mouse_event.y / UnitUtils.device_pixel_ratio()\n        if mouse_x &lt; self._viewport.get_x():\n            return False\n        if mouse_x &gt;= self._viewport.get_x() + self._viewport.get_width():\n            return False\n        if mouse_y &lt; self._viewport.get_y():\n            return False\n        if mouse_y &gt;= self._viewport.get_y() + self._viewport.get_height():\n            return False\n        return True\n\n    # =============================================================================\n    # Conversion matplotlib event to gsp events\n    # =============================================================================\n    def _mpl_key_event_to_gsp(self, mpl_key_event: matplotlib.backend_bases.KeyEvent, event_type: EventType) -&gt; KeyEvent:\n        assert mpl_key_event.key is not None\n        keyboard_event = KeyEvent(\n            viewport_uuid=self._viewport.get_uuid(),\n            event_type=event_type,\n            key_name=mpl_key_event.key,\n        )\n        return keyboard_event\n\n    def _mpl_mouse_event_to_gsp(self, mpl_mouse_event: matplotlib.backend_bases.MouseEvent, event_type: EventType) -&gt; MouseEvent:\n        # Sanity check\n        assert self._viewport_contains_mpl_mouse_event(mpl_mouse_event), \"Mouse event is outside the viewport\"\n\n        mouse_x = mpl_mouse_event.x / UnitUtils.device_pixel_ratio()\n        mouse_y = mpl_mouse_event.y / UnitUtils.device_pixel_ratio()\n        x_viewport = mouse_x - self._viewport.get_x()\n        y_viewport = mouse_y - self._viewport.get_y()\n        mouse_event = MouseEvent(\n            viewport_uuid=self._viewport.get_uuid(),\n            event_type=event_type,\n            x_ndc=(x_viewport / self._viewport.get_width() - 0.5) * 2.0,\n            y_ndc=(y_viewport / self._viewport.get_height() - 0.5) * 2.0,\n            left_button=mpl_mouse_event.button == 1,\n            middle_button=mpl_mouse_event.button == 2,\n            right_button=mpl_mouse_event.button == 3,\n            scroll_steps=mpl_mouse_event.step if hasattr(mpl_mouse_event, \"step\") else 0.0,\n        )\n        return mouse_event\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.viewport_events.viewport_events_network.ViewportEventsNetwork.__init__","title":"<code>__init__(renderer: NetworkRenderer, viewport: Viewport) -&gt; None</code>","text":"<p>Initialize the event handler with a renderer and viewport.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_network.renderer.NetworkRenderer</code> <p>NetworkRenderer associated with this event handler.</p> required <code>viewport</code> <code>gsp.core.Viewport</code> <p>Viewport associated with this event handler.</p> required Source code in <code>src/gsp_network/viewport_events/viewport_events_network.py</code> <pre><code>def __init__(self, renderer: NetworkRenderer, viewport: Viewport) -&gt; None:\n    \"\"\"Initialize the event handler with a renderer and viewport.\n\n    Args:\n        renderer: NetworkRenderer associated with this event handler.\n        viewport: Viewport associated with this event handler.\n    \"\"\"\n    self._renderer = renderer\n    \"\"\"NetworkRenderer associated with this event handler\"\"\"\n    self._viewport = viewport\n    \"\"\"viewport associated with this event handler\"\"\"\n    self._has_key_focus = False\n    \"\"\"True if this viewport has the keyboard focus\"\"\"\n\n    # Intanciate events\n    self.key_press_event = Event[KeyboardEventCallback]()\n    self.key_release_event = Event[KeyboardEventCallback]()\n    self.button_press_event = Event[MouseEventCallback]()\n    self.button_release_event = Event[MouseEventCallback]()\n    self.mouse_move_event = Event[MouseEventCallback]()\n    self.mouse_scroll_event = Event[MouseEventCallback]()\n    self.canvas_resize_event = Event[CanvasResizeEventCallback]()\n\n    # event connections\n    mpl_canvas: matplotlib.backend_bases.FigureCanvasBase = self._renderer.get_mpl_figure().canvas\n    self._mpl_key_press_cid = mpl_canvas.mpl_connect(\"key_press_event\", typing.cast(Any, self._on_key_press))\n    self._mpl_key_release_cid = mpl_canvas.mpl_connect(\"key_release_event\", typing.cast(Any, self._on_key_release))\n    self._mpl_button_press_cid = mpl_canvas.mpl_connect(\"button_press_event\", typing.cast(Any, self._on_button_press))\n    self._mpl_button_release_cid = mpl_canvas.mpl_connect(\"button_release_event\", typing.cast(Any, self._on_button_release))\n    self._mpl_mouse_move_cid = mpl_canvas.mpl_connect(\"motion_notify_event\", typing.cast(Any, self._on_mouse_move))\n    self._mpl_mouse_scroll_cid = mpl_canvas.mpl_connect(\"scroll_event\", typing.cast(Any, self._on_mouse_scroll))\n    self._mpl_resize_cid = mpl_canvas.mpl_connect(\"resize_event\", typing.cast(Any, self._on_canvas_resize))\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.viewport_events.viewport_events_network.ViewportEventsNetwork.close","title":"<code>close()</code>","text":"<p>Close the event handler and release resources.</p> Source code in <code>src/gsp_network/viewport_events/viewport_events_network.py</code> <pre><code>def close(self):\n    \"\"\"Close the event handler and release resources.\"\"\"\n    mpl_canvas: matplotlib.backend_bases.FigureCanvasBase = self._renderer.get_mpl_figure().canvas\n    if self._mpl_key_press_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_key_press_cid)\n        self._mpl_key_press_cid = None\n    if self._mpl_key_release_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_key_release_cid)\n        self._mpl_key_release_cid = None\n    if self._mpl_button_press_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_button_press_cid)\n        self._mpl_button_press_cid = None\n    if self._mpl_button_release_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_button_release_cid)\n        self._mpl_button_release_cid = None\n    if self._mpl_mouse_move_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_mouse_move_cid)\n        self._mpl_mouse_move_cid = None\n    if self._mpl_mouse_scroll_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_mouse_scroll_cid)\n        self._mpl_mouse_scroll_cid = None\n    if self._mpl_resize_cid is not None:\n        mpl_canvas.mpl_disconnect(self._mpl_resize_cid)\n        self._mpl_resize_cid = None\n</code></pre>"},{"location":"api/gsp_network/#animator-network","title":"Animator Network","text":""},{"location":"api/gsp_network/#gsp_network.animator.animator_network","title":"<code>gsp_network.animator.animator_network</code>","text":"<p>Network-based animator for GSP scenes.</p> <p>Provides animation capabilities using a NetworkRenderer backend with support for real-time animation display and video export.</p>"},{"location":"api/gsp_network/#gsp_network.animator.animator_network.AnimatorNetwork","title":"<code>AnimatorNetwork</code>","text":"<p>               Bases: <code>gsp.types.animator_base.AnimatorBase</code></p> <p>Animator for GSP scenes using a network renderer.</p> <p>Manages animation loops with callback functions that update visuals each frame. Supports real-time display and video export in various formats.</p> Source code in <code>src/gsp_network/animator/animator_network.py</code> <pre><code>class AnimatorNetwork(AnimatorBase):\n    \"\"\"Animator for GSP scenes using a network renderer.\n\n    Manages animation loops with callback functions that update visuals each frame.\n    Supports real-time display and video export in various formats.\n    \"\"\"\n\n    def __init__(\n        self,\n        network_renderer: NetworkRenderer,\n        fps: int = 50,\n        video_duration: float = 10.0,\n        video_path: str | None = None,\n        video_writer: str | None = None,\n    ):\n        \"\"\"Initialize the network animator.\n\n        Args:\n            network_renderer: The network renderer to use for rendering frames.\n            fps: Target frames per second for the animation.\n            video_duration: Total duration of the animation in seconds.\n            video_path: Path where the video should be saved. If None, no video is saved.\n            video_writer: Video writer to use (\"ffmpeg\" or \"pillow\"). If None, auto-detected from extension.\n\n        Raises:\n            ValueError: If the video format is not supported.\n        \"\"\"\n        self._callbacks: list[AnimatorFunc] = []\n        self._network_renderer = network_renderer\n        self._fps = fps\n        self._video_duration = video_duration\n        self._video_path = video_path\n        self._video_writer: str | None = video_writer\n        self._time_last_update: float | None = None\n\n        self._funcAnimation: matplotlib.animation.FuncAnimation | None = None\n\n        self._canvas: Canvas | None = None\n        self._viewports: Sequence[Viewport] | None = None\n        self._visuals: Sequence[VisualBase] | None = None\n        self._model_matrices: Sequence[TransBuf] | None = None\n        self._cameras: Sequence[Camera] | None = None\n\n        self.on_video_saved = Event[VideoSavedCalledback]()\n        \"\"\"Event triggered when the video has been successfully saved to disk.\"\"\"\n\n        # guess the video writer from the file extension if not provided\n        if self._video_path is not None:\n            if video_writer is not None:\n                self._video_writer = video_writer\n            else:\n                video_ext = os.path.splitext(self._video_path)[1].lower()\n                if video_ext in [\".mp4\", \".m4v\", \".mov\"]:\n                    self._video_writer = \"ffmpeg\"\n                elif video_ext in [\".gif\", \".apng\", \".webp\"]:\n                    self._video_writer = \"pillow\"\n                else:\n                    raise ValueError(f\"Unsupported video format: {video_ext}\")\n\n    # =============================================================================\n    # .add_callback/.remove_callback/.decorator\n    # =============================================================================\n\n    def add_callback(self, func: AnimatorFunc) -&gt; None:\n        \"\"\"Add a callback to the animation loop.\n\n        Args:\n            func: The animator function to call on each frame.\n        \"\"\"\n        self._callbacks.append(func)\n\n    def remove_callback(self, func: AnimatorFunc) -&gt; None:\n        \"\"\"Remove a callback from the animation loop.\n\n        Args:\n            func: The animator function to remove.\n        \"\"\"\n        self._callbacks.remove(func)\n\n    def event_listener(self, func: AnimatorFunc) -&gt; AnimatorFunc:\n        \"\"\"Decorator to add a callback to the animation loop.\n\n        Args:\n            func: The animator function to register as a callback.\n\n        Returns:\n            The wrapped animator function.\n\n        Usage:\n            ```python\n                @animation_loop.event_listener\n                def my_callback(delta_time: float) -&gt; Sequence[VisualBase]:\n                    ...\n\n                # later, if needed\n                animation_loop.remove_callback(my_callback)\n            ```\n        \"\"\"\n        self.add_callback(func)\n\n        def wrapper(delta_time: float) -&gt; Sequence[VisualBase]:\n            # print(\"Before the function runs\")\n            result = func(delta_time)\n            # print(\"After the function runs\")\n            return result\n\n        return wrapper\n\n    # =============================================================================\n    # .start()\n    # =============================================================================\n    def start(self, viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; None:\n        \"\"\"Start the animation loop.\n\n        Begins rendering frames using registered callbacks to update visuals.\n        In test mode (GSP_TEST=True), saves a single preview image instead of animating.\n\n        Args:\n            viewports: Sequence of viewport regions to render into.\n            visuals: Sequence of visual elements to render and animate.\n            model_matrices: Sequence of model transformation matrices.\n            cameras: Sequence of cameras defining view and projection.\n        \"\"\"\n        self._canvas = self._network_renderer.get_canvas()\n        self._viewports = viewports\n        self._visuals = visuals\n        self._model_matrices = model_matrices\n        self._cameras = cameras\n        self._time_last_update = time.time()\n\n        # =============================================================================\n        # Render the image once\n        # =============================================================================\n\n        self._network_renderer.render(viewports, visuals, model_matrices, cameras)\n\n        # =============================================================================\n        # Handle GSP_TEST=True\n        # =============================================================================\n\n        # detect if we are in not interactive mode - used during testing\n        in_test = \"GSP_TEST\" in os.environ and os.environ[\"GSP_TEST\"] == \"True\"\n\n        # if we are not in interactive mode, save a preview image and return\n        if in_test == True:\n            # notify all animator callbacks\n            changed_visuals: list[VisualBase] = []\n            for animator_callback in self._callbacks:\n                _changed_visuals = animator_callback(1.0 / self._fps)\n                changed_visuals.extend(_changed_visuals)\n\n            # render the scene to get the new image\n            image_png_data = self._network_renderer.render(viewports, visuals, model_matrices, cameras)\n            # get the main script name\n            main_script_name = os.path.basename(__main__.__file__) if hasattr(__main__, \"__file__\") else \"interactive\"\n            main_script_basename = os.path.splitext(main_script_name)[0]\n            # buid the output image path\n            image_path = os.path.join(__dirname__, \"../../../examples/output\", f\"{main_script_basename}_animator_network.png\")\n            image_path = os.path.abspath(image_path)\n            # save image_png_data in a image file\n            with open(image_path, \"wb\") as image_file:\n                image_file.write(image_png_data)\n            # log the event\n            print(f\"Saved animation preview image to: {image_path}\")\n            return\n\n        # NOTE: here we are in interactive mode!!\n\n        # =============================================================================\n        # Initialize the animation\n        # =============================================================================\n\n        figure = self._network_renderer.get_mpl_figure()\n        self._funcAnimation = matplotlib.animation.FuncAnimation(\n            figure, self._mpl_animate, frames=int(self._video_duration * self._fps), interval=1000.0 / self._fps\n        )\n\n        # save the animation if a path is provided\n        if self._video_path is not None:\n            self._funcAnimation.save(self._video_path, writer=self._video_writer, fps=self._fps)\n            # Dispatch the video saved event\n            self.on_video_saved.dispatch()\n\n        # =============================================================================\n        # Show the animation\n        # =============================================================================\n\n        self._network_renderer.show()\n\n    # =============================================================================\n    # .stop()\n    # =============================================================================\n    def stop(self):\n        \"\"\"Stop the animation loop.\n\n        Stops the Matplotlib animation timer and clears internal state.\n        \"\"\"\n        self._canvas = None\n        self._viewports = None\n        self._time_last_update = None\n\n        # stop the animation function timer\n        if self._funcAnimation is not None:\n            self._funcAnimation.event_source.stop()\n            self._funcAnimation = None\n\n    # =============================================================================\n    # ._mpl_animate()\n    # =============================================================================\n\n    def _mpl_animate(self, frame_index: int) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Internal callback for Matplotlib animation.\n\n        Called by Matplotlib's FuncAnimation on each frame to update the display.\n\n        Args:\n            frame_index: The current frame number in the animation sequence.\n\n        Returns:\n            List of Matplotlib artists that were updated.\n        \"\"\"\n        # sanity checks\n        assert self._canvas is not None, \"Canvas MUST be set during the animation\"\n        assert self._viewports is not None, \"Viewports MUST be set during the animation\"\n        assert self._visuals is not None, \"Visuals MUST be set during the animation\"\n        assert self._model_matrices is not None, \"Model matrices MUST be set during the animation\"\n        assert self._cameras is not None, \"Cameras MUST be set during the animation\"\n\n        # compute delta time\n        present = time.time()\n        delta_time = (present - self._time_last_update) if self._time_last_update is not None else (1 / self._fps)\n        self._time_last_update = present\n\n        # notify all animator callbacks\n        changed_visuals: list[VisualBase] = []\n        for callback in self._callbacks:\n            _changed_visuals = callback(delta_time)\n            changed_visuals.extend(_changed_visuals)\n\n        # Render the scene to update the visuals\n        if len(changed_visuals) &gt; 0:\n            self._network_renderer.render(self._viewports, self._visuals, self._model_matrices, self._cameras)\n\n        # return the changed mpl artists\n        return [self._network_renderer._axes_image]\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.animator.animator_network.AnimatorNetwork.on_video_saved","title":"<code>on_video_saved = Event[VideoSavedCalledback]()</code>  <code>instance-attribute</code>","text":"<p>Event triggered when the video has been successfully saved to disk.</p>"},{"location":"api/gsp_network/#gsp_network.animator.animator_network.AnimatorNetwork.__init__","title":"<code>__init__(network_renderer: NetworkRenderer, fps: int = 50, video_duration: float = 10.0, video_path: str | None = None, video_writer: str | None = None)</code>","text":"<p>Initialize the network animator.</p> <p>Parameters:</p> Name Type Description Default <code>network_renderer</code> <code>gsp_network.renderer.NetworkRenderer</code> <p>The network renderer to use for rendering frames.</p> required <code>fps</code> <code>int</code> <p>Target frames per second for the animation.</p> <code>50</code> <code>video_duration</code> <code>float</code> <p>Total duration of the animation in seconds.</p> <code>10.0</code> <code>video_path</code> <code>str | None</code> <p>Path where the video should be saved. If None, no video is saved.</p> <code>None</code> <code>video_writer</code> <code>str | None</code> <p>Video writer to use (\"ffmpeg\" or \"pillow\"). If None, auto-detected from extension.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the video format is not supported.</p> Source code in <code>src/gsp_network/animator/animator_network.py</code> <pre><code>def __init__(\n    self,\n    network_renderer: NetworkRenderer,\n    fps: int = 50,\n    video_duration: float = 10.0,\n    video_path: str | None = None,\n    video_writer: str | None = None,\n):\n    \"\"\"Initialize the network animator.\n\n    Args:\n        network_renderer: The network renderer to use for rendering frames.\n        fps: Target frames per second for the animation.\n        video_duration: Total duration of the animation in seconds.\n        video_path: Path where the video should be saved. If None, no video is saved.\n        video_writer: Video writer to use (\"ffmpeg\" or \"pillow\"). If None, auto-detected from extension.\n\n    Raises:\n        ValueError: If the video format is not supported.\n    \"\"\"\n    self._callbacks: list[AnimatorFunc] = []\n    self._network_renderer = network_renderer\n    self._fps = fps\n    self._video_duration = video_duration\n    self._video_path = video_path\n    self._video_writer: str | None = video_writer\n    self._time_last_update: float | None = None\n\n    self._funcAnimation: matplotlib.animation.FuncAnimation | None = None\n\n    self._canvas: Canvas | None = None\n    self._viewports: Sequence[Viewport] | None = None\n    self._visuals: Sequence[VisualBase] | None = None\n    self._model_matrices: Sequence[TransBuf] | None = None\n    self._cameras: Sequence[Camera] | None = None\n\n    self.on_video_saved = Event[VideoSavedCalledback]()\n    \"\"\"Event triggered when the video has been successfully saved to disk.\"\"\"\n\n    # guess the video writer from the file extension if not provided\n    if self._video_path is not None:\n        if video_writer is not None:\n            self._video_writer = video_writer\n        else:\n            video_ext = os.path.splitext(self._video_path)[1].lower()\n            if video_ext in [\".mp4\", \".m4v\", \".mov\"]:\n                self._video_writer = \"ffmpeg\"\n            elif video_ext in [\".gif\", \".apng\", \".webp\"]:\n                self._video_writer = \"pillow\"\n            else:\n                raise ValueError(f\"Unsupported video format: {video_ext}\")\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.animator.animator_network.AnimatorNetwork.add_callback","title":"<code>add_callback(func: AnimatorFunc) -&gt; None</code>","text":"<p>Add a callback to the animation loop.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>gsp.types.animator_types.AnimatorFunc</code> <p>The animator function to call on each frame.</p> required Source code in <code>src/gsp_network/animator/animator_network.py</code> <pre><code>def add_callback(self, func: AnimatorFunc) -&gt; None:\n    \"\"\"Add a callback to the animation loop.\n\n    Args:\n        func: The animator function to call on each frame.\n    \"\"\"\n    self._callbacks.append(func)\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.animator.animator_network.AnimatorNetwork.event_listener","title":"<code>event_listener(func: AnimatorFunc) -&gt; AnimatorFunc</code>","text":"<p>Decorator to add a callback to the animation loop.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>gsp.types.animator_types.AnimatorFunc</code> <p>The animator function to register as a callback.</p> required <p>Returns:</p> Type Description <code>gsp.types.animator_types.AnimatorFunc</code> <p>The wrapped animator function.</p> Usage <pre><code>    @animation_loop.event_listener\n    def my_callback(delta_time: float) -&gt; Sequence[VisualBase]:\n        ...\n\n    # later, if needed\n    animation_loop.remove_callback(my_callback)\n</code></pre> Source code in <code>src/gsp_network/animator/animator_network.py</code> <pre><code>def event_listener(self, func: AnimatorFunc) -&gt; AnimatorFunc:\n    \"\"\"Decorator to add a callback to the animation loop.\n\n    Args:\n        func: The animator function to register as a callback.\n\n    Returns:\n        The wrapped animator function.\n\n    Usage:\n        ```python\n            @animation_loop.event_listener\n            def my_callback(delta_time: float) -&gt; Sequence[VisualBase]:\n                ...\n\n            # later, if needed\n            animation_loop.remove_callback(my_callback)\n        ```\n    \"\"\"\n    self.add_callback(func)\n\n    def wrapper(delta_time: float) -&gt; Sequence[VisualBase]:\n        # print(\"Before the function runs\")\n        result = func(delta_time)\n        # print(\"After the function runs\")\n        return result\n\n    return wrapper\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.animator.animator_network.AnimatorNetwork.remove_callback","title":"<code>remove_callback(func: AnimatorFunc) -&gt; None</code>","text":"<p>Remove a callback from the animation loop.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>gsp.types.animator_types.AnimatorFunc</code> <p>The animator function to remove.</p> required Source code in <code>src/gsp_network/animator/animator_network.py</code> <pre><code>def remove_callback(self, func: AnimatorFunc) -&gt; None:\n    \"\"\"Remove a callback from the animation loop.\n\n    Args:\n        func: The animator function to remove.\n    \"\"\"\n    self._callbacks.remove(func)\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.animator.animator_network.AnimatorNetwork.start","title":"<code>start(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; None</code>","text":"<p>Start the animation loop.</p> <p>Begins rendering frames using registered callbacks to update visuals. In test mode (GSP_TEST=True), saves a single preview image instead of animating.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>Sequence of viewport regions to render into.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>Sequence of visual elements to render and animate.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>Sequence of model transformation matrices.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>Sequence of cameras defining view and projection.</p> required Source code in <code>src/gsp_network/animator/animator_network.py</code> <pre><code>def start(self, viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; None:\n    \"\"\"Start the animation loop.\n\n    Begins rendering frames using registered callbacks to update visuals.\n    In test mode (GSP_TEST=True), saves a single preview image instead of animating.\n\n    Args:\n        viewports: Sequence of viewport regions to render into.\n        visuals: Sequence of visual elements to render and animate.\n        model_matrices: Sequence of model transformation matrices.\n        cameras: Sequence of cameras defining view and projection.\n    \"\"\"\n    self._canvas = self._network_renderer.get_canvas()\n    self._viewports = viewports\n    self._visuals = visuals\n    self._model_matrices = model_matrices\n    self._cameras = cameras\n    self._time_last_update = time.time()\n\n    # =============================================================================\n    # Render the image once\n    # =============================================================================\n\n    self._network_renderer.render(viewports, visuals, model_matrices, cameras)\n\n    # =============================================================================\n    # Handle GSP_TEST=True\n    # =============================================================================\n\n    # detect if we are in not interactive mode - used during testing\n    in_test = \"GSP_TEST\" in os.environ and os.environ[\"GSP_TEST\"] == \"True\"\n\n    # if we are not in interactive mode, save a preview image and return\n    if in_test == True:\n        # notify all animator callbacks\n        changed_visuals: list[VisualBase] = []\n        for animator_callback in self._callbacks:\n            _changed_visuals = animator_callback(1.0 / self._fps)\n            changed_visuals.extend(_changed_visuals)\n\n        # render the scene to get the new image\n        image_png_data = self._network_renderer.render(viewports, visuals, model_matrices, cameras)\n        # get the main script name\n        main_script_name = os.path.basename(__main__.__file__) if hasattr(__main__, \"__file__\") else \"interactive\"\n        main_script_basename = os.path.splitext(main_script_name)[0]\n        # buid the output image path\n        image_path = os.path.join(__dirname__, \"../../../examples/output\", f\"{main_script_basename}_animator_network.png\")\n        image_path = os.path.abspath(image_path)\n        # save image_png_data in a image file\n        with open(image_path, \"wb\") as image_file:\n            image_file.write(image_png_data)\n        # log the event\n        print(f\"Saved animation preview image to: {image_path}\")\n        return\n\n    # NOTE: here we are in interactive mode!!\n\n    # =============================================================================\n    # Initialize the animation\n    # =============================================================================\n\n    figure = self._network_renderer.get_mpl_figure()\n    self._funcAnimation = matplotlib.animation.FuncAnimation(\n        figure, self._mpl_animate, frames=int(self._video_duration * self._fps), interval=1000.0 / self._fps\n    )\n\n    # save the animation if a path is provided\n    if self._video_path is not None:\n        self._funcAnimation.save(self._video_path, writer=self._video_writer, fps=self._fps)\n        # Dispatch the video saved event\n        self.on_video_saved.dispatch()\n\n    # =============================================================================\n    # Show the animation\n    # =============================================================================\n\n    self._network_renderer.show()\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.animator.animator_network.AnimatorNetwork.stop","title":"<code>stop()</code>","text":"<p>Stop the animation loop.</p> <p>Stops the Matplotlib animation timer and clears internal state.</p> Source code in <code>src/gsp_network/animator/animator_network.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the animation loop.\n\n    Stops the Matplotlib animation timer and clears internal state.\n    \"\"\"\n    self._canvas = None\n    self._viewports = None\n    self._time_last_update = None\n\n    # stop the animation function timer\n    if self._funcAnimation is not None:\n        self._funcAnimation.event_source.stop()\n        self._funcAnimation = None\n</code></pre>"},{"location":"api/gsp_pydantic/","title":"GSP Pydantic API Reference","text":"<p>The GSP Pydantic module provides serialization and deserialization capabilities using Pydantic models, enabling data validation and JSON schema generation for GSP objects.</p>"},{"location":"api/gsp_pydantic/#overview","title":"Overview","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic","title":"<code>gsp_pydantic</code>","text":"<p>GSP Pydantic package initialization.</p>"},{"location":"api/gsp_pydantic/#serializer-module","title":"Serializer Module","text":"<p>The serializer module contains the serialization and parsing utilities for converting GSP objects to and from Pydantic models.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer","title":"<code>gsp_pydantic.serializer</code>","text":"<p>Pydantic serializer and parser for GSP data structures.</p>"},{"location":"api/gsp_pydantic/#pydantic-serializer","title":"Pydantic Serializer","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_serializer","title":"<code>gsp_pydantic.serializer.pydantic_serializer</code>","text":"<p>Pydantic serializer for GSP data structures.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_serializer.PydanticSerializer","title":"<code>PydanticSerializer</code>","text":"<p>               Bases: <code>gsp.types.serializer_base.SerializerBase</code></p> <p>Serializer that converts GSP data structures into Pydantic models.</p> Source code in <code>src/gsp_pydantic/serializer/pydantic_serializer.py</code> <pre><code>class PydanticSerializer(SerializerBase):\n    \"\"\"Serializer that converts GSP data structures into Pydantic models.\"\"\"\n\n    def __init__(self, canvas: Canvas):\n        \"\"\"Initialize the PydanticSerializer with a canvas.\n\n        Args:\n            canvas (Canvas): The canvas to be used in the serialization.\n        \"\"\"\n        self._canvas = canvas\n\n    def serialize(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n    ) -&gt; PydanticDict:\n        \"\"\"Serialize the provided GSP data structures into a PydanticDict.\n\n        Args:\n            viewports (Sequence[Viewport]): The list of viewports to serialize.\n            visuals (Sequence[VisualBase]): The list of visual elements to serialize.\n            model_matrices (Sequence[TransBuf]): The list of model transformation matrices to serialize.\n            cameras (Sequence[Camera]): The list of cameras to serialize.\n\n        Returns:\n            PydanticDict: The serialized data as a PydanticDict.\n        \"\"\"\n        # =============================================================================\n        #\n        # =============================================================================\n\n        pydanticCanvas = PydanticCanvas(\n            uuid=self._canvas.get_uuid(),\n            width=self._canvas.get_width(),\n            height=self._canvas.get_height(),\n            dpi=self._canvas.get_dpi(),\n        )\n\n        pydanticViewports = [\n            PydanticViewport(\n                uuid=viewport.get_uuid(),\n                x=viewport.get_x(),\n                y=viewport.get_y(),\n                width=viewport.get_width(),\n                height=viewport.get_height(),\n            )\n            for viewport in viewports\n        ]\n\n        pydantic_visuals = PydanticSerializer._visuals_to_pydantic(visuals)\n\n        pydantic_model_matrices = [PydanticModelMatrix(model_matrix=PydanticSerializer._transbuf_to_pydantic(model_matrix)) for model_matrix in model_matrices]\n\n        pydantic_cameras = [\n            PydanticCamera(\n                uuid=camera.get_uuid(),\n                view_matrix=PydanticSerializer._transbuf_to_pydantic(camera.get_view_matrix()),\n                projection_matrix=PydanticSerializer._transbuf_to_pydantic(camera.get_projection_matrix()),\n            )\n            for camera in cameras\n        ]\n\n        # =============================================================================\n        #\n        # =============================================================================\n\n        pydantic_scene = PydanticScene(\n            canvas=pydanticCanvas,\n            viewports=pydanticViewports,\n            visuals=pydantic_visuals,\n            model_matrices=pydantic_model_matrices,\n            cameras=pydantic_cameras,\n        )\n\n        pydantic_scene_dict: PydanticDict = pydantic_scene.model_dump()\n\n        return pydantic_scene_dict  # Placeholder for JSON byte output\n\n    # =============================================================================\n    # Static methods\n    # =============================================================================\n\n    @staticmethod\n    def _visuals_to_pydantic(visuals: Sequence[VisualBase]) -&gt; list[PydanticVisual]:\n        pydantic_visuals: list[PydanticVisual] = []\n        for visual in visuals:\n            if isinstance(visual, Markers):\n                markers = typing.cast(Markers, visual)\n                pydantic_visual = PydanticVisual(\n                    type=\"markers\",\n                    visual=PydanticMarkers(\n                        uuid=markers.get_uuid(),\n                        marker_shape=markers.get_marker_shape().name,\n                        positions=PydanticSerializer._transbuf_to_pydantic(markers.get_positions()),\n                        sizes=PydanticSerializer._transbuf_to_pydantic(markers.get_sizes()),\n                        face_colors=PydanticSerializer._transbuf_to_pydantic(markers.get_face_colors()),\n                        edge_colors=PydanticSerializer._transbuf_to_pydantic(markers.get_edge_colors()),\n                        edge_widths=PydanticSerializer._transbuf_to_pydantic(markers.get_edge_widths()),\n                    ),\n                )\n                pydantic_visuals.append(pydantic_visual)\n            elif isinstance(visual, Paths):\n                paths = typing.cast(Paths, visual)\n                pydantic_visual = PydanticVisual(\n                    type=\"paths\",\n                    visual=PydanticPaths(\n                        uuid=paths.get_uuid(),\n                        positions=PydanticSerializer._transbuf_to_pydantic(paths.get_positions()),\n                        path_sizes=PydanticSerializer._transbuf_to_pydantic(paths.get_path_sizes()),\n                        colors=PydanticSerializer._transbuf_to_pydantic(paths.get_colors()),\n                        line_widths=PydanticSerializer._transbuf_to_pydantic(paths.get_line_widths()),\n                        cap_style=paths.get_cap_style().name,\n                        join_style=paths.get_join_style().name,\n                    ),\n                )\n                pydantic_visuals.append(pydantic_visual)\n            elif isinstance(visual, Pixels):\n                pixels = typing.cast(Pixels, visual)\n                pydantic_visual = PydanticVisual(\n                    type=\"pixels\",\n                    visual=PydanticPixels(\n                        uuid=pixels.get_uuid(),\n                        positions=PydanticSerializer._transbuf_to_pydantic(pixels.get_positions()),\n                        colors=PydanticSerializer._transbuf_to_pydantic(pixels.get_colors()),\n                        groups=pixels.get_groups(),\n                    ),\n                )\n                pydantic_visuals.append(pydantic_visual)\n            elif isinstance(visual, Points):\n                points = typing.cast(Points, visual)\n                pydantic_visual = PydanticVisual(\n                    type=\"points\",\n                    visual=PydanticPoints(\n                        uuid=points.get_uuid(),\n                        positions=PydanticSerializer._transbuf_to_pydantic(points.get_positions()),\n                        sizes=PydanticSerializer._transbuf_to_pydantic(points.get_sizes()),\n                        face_colors=PydanticSerializer._transbuf_to_pydantic(points.get_face_colors()),\n                        edge_colors=PydanticSerializer._transbuf_to_pydantic(points.get_edge_colors()),\n                        edge_widths=PydanticSerializer._transbuf_to_pydantic(points.get_edge_widths()),\n                    ),\n                )\n                pydantic_visuals.append(pydantic_visual)\n            elif isinstance(visual, Segments):\n                segments = typing.cast(Segments, visual)\n                pydantic_visual = PydanticVisual(\n                    type=\"segments\",\n                    visual=PydanticSegments(\n                        uuid=segments.get_uuid(),\n                        positions=PydanticSerializer._transbuf_to_pydantic(segments.get_positions()),\n                        line_widths=PydanticSerializer._transbuf_to_pydantic(segments.get_line_widths()),\n                        cap_style=segments.get_cap_style().name,\n                        colors=PydanticSerializer._transbuf_to_pydantic(segments.get_colors()),\n                    ),\n                )\n                pydantic_visuals.append(pydantic_visual)\n            elif isinstance(visual, Texts):\n                texts = typing.cast(Texts, visual)\n                pydantic_visual = PydanticVisual(\n                    type=\"texts\",\n                    visual=PydanticTexts(\n                        uuid=texts.get_uuid(),\n                        positions=PydanticSerializer._transbuf_to_pydantic(texts.get_positions()),\n                        texts=texts.get_strings(),\n                        colors=PydanticSerializer._transbuf_to_pydantic(texts.get_colors()),\n                        font_sizes=PydanticSerializer._transbuf_to_pydantic(texts.get_font_sizes()),\n                        anchors=PydanticSerializer._transbuf_to_pydantic(texts.get_anchors()),\n                        angles=PydanticSerializer._transbuf_to_pydantic(texts.get_angles()),\n                        font_name=texts.get_font_name(),\n                    ),\n                )\n                pydantic_visuals.append(pydantic_visual)\n            else:\n                raise NotImplementedError(f\"Serialization for this Visual type {type(visual)} is not implemented yet\")\n\n        # return the list of pydantic visuals\n        return pydantic_visuals\n\n    @staticmethod\n    def _transbuf_to_pydantic(transbuf: TransBuf) -&gt; PydanticTransBuf:\n        if isinstance(transbuf, Buffer):\n            buffer = typing.cast(Buffer, transbuf)\n            pydantic_transbuf = PydanticTransBuf(\n                type=\"buffer\",\n                transBuf=PydanticBuffer(\n                    count=buffer.get_count(),\n                    buffer_type=buffer.get_type().name,\n                    data_base64=base64.b64encode(buffer.to_bytearray()).decode(\"utf-8\"),\n                ),\n            )\n            return pydantic_transbuf\n        elif isinstance(transbuf, TransformChain):\n            transform_chain = typing.cast(TransformChain, transbuf)\n            pydantic_transbuf = PydanticTransBuf(\n                type=\"transform_chain\",\n                transBuf=PydanticTransformChain(\n                    transform_chain=transform_chain.serialize(),\n                ),\n            )\n            return pydantic_transbuf\n        else:\n            raise ValueError(\"Unknown TransBuf type\")\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_serializer.PydanticSerializer.__init__","title":"<code>__init__(canvas: Canvas)</code>","text":"<p>Initialize the PydanticSerializer with a canvas.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>gsp.core.canvas.Canvas</code> <p>The canvas to be used in the serialization.</p> required Source code in <code>src/gsp_pydantic/serializer/pydantic_serializer.py</code> <pre><code>def __init__(self, canvas: Canvas):\n    \"\"\"Initialize the PydanticSerializer with a canvas.\n\n    Args:\n        canvas (Canvas): The canvas to be used in the serialization.\n    \"\"\"\n    self._canvas = canvas\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_serializer.PydanticSerializer.serialize","title":"<code>serialize(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; PydanticDict</code>","text":"<p>Serialize the provided GSP data structures into a PydanticDict.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>The list of viewports to serialize.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>The list of visual elements to serialize.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>The list of model transformation matrices to serialize.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>The list of cameras to serialize.</p> required <p>Returns:</p> Name Type Description <code>PydanticDict</code> <code>gsp_pydantic.types.pydantic_dict.PydanticDict</code> <p>The serialized data as a PydanticDict.</p> Source code in <code>src/gsp_pydantic/serializer/pydantic_serializer.py</code> <pre><code>def serialize(\n    self,\n    viewports: Sequence[Viewport],\n    visuals: Sequence[VisualBase],\n    model_matrices: Sequence[TransBuf],\n    cameras: Sequence[Camera],\n) -&gt; PydanticDict:\n    \"\"\"Serialize the provided GSP data structures into a PydanticDict.\n\n    Args:\n        viewports (Sequence[Viewport]): The list of viewports to serialize.\n        visuals (Sequence[VisualBase]): The list of visual elements to serialize.\n        model_matrices (Sequence[TransBuf]): The list of model transformation matrices to serialize.\n        cameras (Sequence[Camera]): The list of cameras to serialize.\n\n    Returns:\n        PydanticDict: The serialized data as a PydanticDict.\n    \"\"\"\n    # =============================================================================\n    #\n    # =============================================================================\n\n    pydanticCanvas = PydanticCanvas(\n        uuid=self._canvas.get_uuid(),\n        width=self._canvas.get_width(),\n        height=self._canvas.get_height(),\n        dpi=self._canvas.get_dpi(),\n    )\n\n    pydanticViewports = [\n        PydanticViewport(\n            uuid=viewport.get_uuid(),\n            x=viewport.get_x(),\n            y=viewport.get_y(),\n            width=viewport.get_width(),\n            height=viewport.get_height(),\n        )\n        for viewport in viewports\n    ]\n\n    pydantic_visuals = PydanticSerializer._visuals_to_pydantic(visuals)\n\n    pydantic_model_matrices = [PydanticModelMatrix(model_matrix=PydanticSerializer._transbuf_to_pydantic(model_matrix)) for model_matrix in model_matrices]\n\n    pydantic_cameras = [\n        PydanticCamera(\n            uuid=camera.get_uuid(),\n            view_matrix=PydanticSerializer._transbuf_to_pydantic(camera.get_view_matrix()),\n            projection_matrix=PydanticSerializer._transbuf_to_pydantic(camera.get_projection_matrix()),\n        )\n        for camera in cameras\n    ]\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    pydantic_scene = PydanticScene(\n        canvas=pydanticCanvas,\n        viewports=pydanticViewports,\n        visuals=pydantic_visuals,\n        model_matrices=pydantic_model_matrices,\n        cameras=pydantic_cameras,\n    )\n\n    pydantic_scene_dict: PydanticDict = pydantic_scene.model_dump()\n\n    return pydantic_scene_dict  # Placeholder for JSON byte output\n</code></pre>"},{"location":"api/gsp_pydantic/#pydantic-parser","title":"Pydantic Parser","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_parser","title":"<code>gsp_pydantic.serializer.pydantic_parser</code>","text":"<p>Pydantic parser for GSP data structures.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_parser.PydanticParser","title":"<code>PydanticParser</code>","text":"<p>Parser that converts Pydantic models into GSP data structures.</p> Source code in <code>src/gsp_pydantic/serializer/pydantic_parser.py</code> <pre><code>class PydanticParser:\n    \"\"\"Parser that converts Pydantic models into GSP data structures.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize the PydanticParser.\"\"\"\n        pass\n\n    def parse(self, json_dict: PydanticDict) -&gt; tuple[\n        Canvas,\n        list[Viewport],\n        list[VisualBase],\n        list[TransBuf],\n        list[Camera],\n    ]:\n        \"\"\"Parse a Pydantic JSON dictionary into GSP data structures.\n\n        Args:\n            json_dict (PydanticDict): The Pydantic JSON dictionary representing the scene.\n\n        Returns:\n            tuple[\n                Canvas,\n                list[Viewport],\n                list[VisualBase],\n                list[TransBuf],\n                list[Camera],\n            ]: The parsed GSP data structures.\n        \"\"\"\n        json_str = json.dumps(json_dict, indent=4)\n        pydantic_scene = PydanticScene.model_validate(pydantic_core.from_json(json_str, allow_partial=True))\n\n        # =============================================================================\n        # Parse Pydantic Canvas\n        # =============================================================================\n        pydantic_canvas = pydantic_scene.canvas\n        canvas = Canvas(pydantic_canvas.width, pydantic_canvas.height, pydantic_canvas.dpi)\n        canvas._uuid = pydantic_canvas.uuid\n\n        # =============================================================================\n        # Parse Pydantic Viewports\n        # =============================================================================\n        viewports: list[Viewport] = []  # Placeholder implementation\n        for pydantic_viewport in pydantic_scene.viewports:\n            viewport = Viewport(\n                pydantic_viewport.x,\n                pydantic_viewport.y,\n                pydantic_viewport.width,\n                pydantic_viewport.height,\n            )\n            viewport._uuid = pydantic_viewport.uuid\n            viewports.append(viewport)\n\n        # =============================================================================\n        # Parse Pydantic Visuals\n        # =============================================================================\n        visuals: list[VisualBase] = []  # Placeholder implementation\n        for pydantic_visual in pydantic_scene.visuals:\n            visual = PydanticParser._pydantic_to_visual(pydantic_visual)\n            visuals.append(visual)\n\n        # =============================================================================\n        # Parse Pydantic Model Matrices\n        # =============================================================================\n        model_matrices: list[TransBuf] = []  # Placeholder implementation\n        for pydantic_model_matrix in pydantic_scene.model_matrices:\n            model_matrix = PydanticParser._pydantic_to_transbuf(pydantic_model_matrix.model_matrix)\n            model_matrices.append(model_matrix)\n\n        # =============================================================================\n        # Parse Pydanticy Cameras\n        # =============================================================================\n        cameras: list[Camera] = []\n        for pydantic_camera in pydantic_scene.cameras:\n            view_matrix = PydanticParser._pydantic_to_transbuf(pydantic_camera.view_matrix)\n            projection_matrix = PydanticParser._pydantic_to_transbuf(pydantic_camera.projection_matrix)\n            camera = Camera(view_matrix, projection_matrix)\n            camera._uuid = pydantic_camera.uuid\n            cameras.append(camera)\n\n        # =============================================================================\n        # Return the renderer arguments\n        # =============================================================================\n        return canvas, viewports, visuals, model_matrices, cameras\n\n    @staticmethod\n    def _pydantic_to_visual(pydantic_visual: PydanticVisual) -&gt; VisualBase:\n        if pydantic_visual.type == \"markers\":\n            pydantic_markers = typing.cast(PydanticMarkers, pydantic_visual.visual)\n            marker_shape = MarkerShape[pydantic_markers.marker_shape]\n            positions = PydanticParser._pydantic_to_transbuf(pydantic_markers.positions)\n            sizes = PydanticParser._pydantic_to_transbuf(pydantic_markers.sizes)\n            face_colors = PydanticParser._pydantic_to_transbuf(pydantic_markers.face_colors)\n            edge_colors = PydanticParser._pydantic_to_transbuf(pydantic_markers.edge_colors)\n            edge_widths = PydanticParser._pydantic_to_transbuf(pydantic_markers.edge_widths)\n            markers = Markers(marker_shape, positions, sizes, face_colors, edge_colors, edge_widths)\n            markers._uuid = pydantic_markers.uuid\n            return markers\n        elif pydantic_visual.type == \"paths\":\n            pydantic_paths = typing.cast(PydanticPaths, pydantic_visual.visual)\n            positions = PydanticParser._pydantic_to_transbuf(pydantic_paths.positions)\n            path_sizes = PydanticParser._pydantic_to_transbuf(pydantic_paths.path_sizes)\n            colors = PydanticParser._pydantic_to_transbuf(pydantic_paths.colors)\n            line_widths = PydanticParser._pydantic_to_transbuf(pydantic_paths.line_widths)\n            cap_style = CapStyle[pydantic_paths.cap_style]\n            join_style = JoinStyle[pydantic_paths.join_style]\n            paths = Paths(positions, path_sizes, colors, line_widths, cap_style, join_style)\n            paths._uuid = pydantic_paths.uuid\n            return paths\n        elif pydantic_visual.type == \"pixels\":\n            pydantic_pixels = typing.cast(PydanticPixels, pydantic_visual.visual)\n            positions = PydanticParser._pydantic_to_transbuf(pydantic_pixels.positions)\n            colors = PydanticParser._pydantic_to_transbuf(pydantic_pixels.colors)\n            groups = pydantic_pixels.groups\n            pixels = Pixels(positions, colors, groups)\n            pixels._uuid = pydantic_pixels.uuid\n            return pixels\n        elif pydantic_visual.type == \"points\":\n            pydantic_points = typing.cast(PydanticPoints, pydantic_visual.visual)\n            positions = PydanticParser._pydantic_to_transbuf(pydantic_points.positions)\n            sizes = PydanticParser._pydantic_to_transbuf(pydantic_points.sizes)\n            face_colors = PydanticParser._pydantic_to_transbuf(pydantic_points.face_colors)\n            edge_colors = PydanticParser._pydantic_to_transbuf(pydantic_points.edge_colors)\n            edge_widths = PydanticParser._pydantic_to_transbuf(pydantic_points.edge_widths)\n            points = Points(positions, sizes, face_colors, edge_colors, edge_widths)\n            points._uuid = pydantic_points.uuid\n            return points\n        elif pydantic_visual.type == \"segments\":\n            pydantic_segments = typing.cast(PydanticSegments, pydantic_visual.visual)\n            positions = PydanticParser._pydantic_to_transbuf(pydantic_segments.positions)\n            line_widths = PydanticParser._pydantic_to_transbuf(pydantic_segments.line_widths)\n            cap_style = CapStyle[pydantic_segments.cap_style]\n            colors = PydanticParser._pydantic_to_transbuf(pydantic_segments.colors)\n            segments = Segments(positions, line_widths, cap_style, colors)\n            segments._uuid = pydantic_segments.uuid\n            return segments\n        elif pydantic_visual.type == \"texts\":\n            pydantic_texts = typing.cast(PydanticTexts, pydantic_visual.visual)\n            positions = PydanticParser._pydantic_to_transbuf(pydantic_texts.positions)\n            texts_list = pydantic_texts.texts\n            colors = PydanticParser._pydantic_to_transbuf(pydantic_texts.colors)\n            font_sizes = PydanticParser._pydantic_to_transbuf(pydantic_texts.font_sizes)\n            anchors = PydanticParser._pydantic_to_transbuf(pydantic_texts.anchors)\n            angles = PydanticParser._pydantic_to_transbuf(pydantic_texts.angles)\n            font_name = pydantic_texts.font_name\n            texts = Texts(positions, texts_list, colors, font_sizes, anchors, angles, font_name)\n            texts._uuid = pydantic_texts.uuid\n            return texts\n        else:\n            raise ValueError(f\"Unknown PydanticVisual type: {pydantic_visual.type}\")\n\n    @staticmethod\n    def _pydantic_to_transbuf(pydantic_transbuf: PydanticTransBuf) -&gt; TransBuf:\n        if pydantic_transbuf.type == \"buffer\":\n            pydantic_buffer = typing.cast(PydanticBuffer, pydantic_transbuf.transBuf)\n            count = pydantic_buffer.count\n            buffer_type = BufferType[pydantic_buffer.buffer_type]\n            buffer_data = bytearray(base64.b64decode(pydantic_buffer.data_base64))\n            buffer = Buffer.from_bytearray(buffer_data, buffer_type)\n            assert buffer.get_count() == count, f\"Buffer count mismatch: expected {count}, got {buffer.get_count()}\"\n            return buffer\n        elif pydantic_transbuf.type == \"transform_chain\":\n            pydantic_transform_chain = typing.cast(PydanticTransformChain, pydantic_transbuf.transBuf)\n            deserialized_transform = TransformChain.deserialize(pydantic_transform_chain.transform_chain)\n            buffer = deserialized_transform.run()\n            return buffer\n        else:\n            raise ValueError(f\"Unknown PydanticTransBuf type: {pydantic_transbuf.type}\")\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_parser.PydanticParser.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the PydanticParser.</p> Source code in <code>src/gsp_pydantic/serializer/pydantic_parser.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the PydanticParser.\"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_parser.PydanticParser.parse","title":"<code>parse(json_dict: PydanticDict) -&gt; tuple[Canvas, list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]</code>","text":"<p>Parse a Pydantic JSON dictionary into GSP data structures.</p> <p>Parameters:</p> Name Type Description Default <code>json_dict</code> <code>gsp_pydantic.types.pydantic_dict.PydanticDict</code> <p>The Pydantic JSON dictionary representing the scene.</p> required <p>Returns:</p> Type Description <code>gsp.core.canvas.Canvas</code> <p>tuple[ Canvas, list[Viewport], list[VisualBase], list[TransBuf], list[Camera],</p> <code>list[gsp.core.viewport.Viewport]</code> <p>]: The parsed GSP data structures.</p> Source code in <code>src/gsp_pydantic/serializer/pydantic_parser.py</code> <pre><code>def parse(self, json_dict: PydanticDict) -&gt; tuple[\n    Canvas,\n    list[Viewport],\n    list[VisualBase],\n    list[TransBuf],\n    list[Camera],\n]:\n    \"\"\"Parse a Pydantic JSON dictionary into GSP data structures.\n\n    Args:\n        json_dict (PydanticDict): The Pydantic JSON dictionary representing the scene.\n\n    Returns:\n        tuple[\n            Canvas,\n            list[Viewport],\n            list[VisualBase],\n            list[TransBuf],\n            list[Camera],\n        ]: The parsed GSP data structures.\n    \"\"\"\n    json_str = json.dumps(json_dict, indent=4)\n    pydantic_scene = PydanticScene.model_validate(pydantic_core.from_json(json_str, allow_partial=True))\n\n    # =============================================================================\n    # Parse Pydantic Canvas\n    # =============================================================================\n    pydantic_canvas = pydantic_scene.canvas\n    canvas = Canvas(pydantic_canvas.width, pydantic_canvas.height, pydantic_canvas.dpi)\n    canvas._uuid = pydantic_canvas.uuid\n\n    # =============================================================================\n    # Parse Pydantic Viewports\n    # =============================================================================\n    viewports: list[Viewport] = []  # Placeholder implementation\n    for pydantic_viewport in pydantic_scene.viewports:\n        viewport = Viewport(\n            pydantic_viewport.x,\n            pydantic_viewport.y,\n            pydantic_viewport.width,\n            pydantic_viewport.height,\n        )\n        viewport._uuid = pydantic_viewport.uuid\n        viewports.append(viewport)\n\n    # =============================================================================\n    # Parse Pydantic Visuals\n    # =============================================================================\n    visuals: list[VisualBase] = []  # Placeholder implementation\n    for pydantic_visual in pydantic_scene.visuals:\n        visual = PydanticParser._pydantic_to_visual(pydantic_visual)\n        visuals.append(visual)\n\n    # =============================================================================\n    # Parse Pydantic Model Matrices\n    # =============================================================================\n    model_matrices: list[TransBuf] = []  # Placeholder implementation\n    for pydantic_model_matrix in pydantic_scene.model_matrices:\n        model_matrix = PydanticParser._pydantic_to_transbuf(pydantic_model_matrix.model_matrix)\n        model_matrices.append(model_matrix)\n\n    # =============================================================================\n    # Parse Pydanticy Cameras\n    # =============================================================================\n    cameras: list[Camera] = []\n    for pydantic_camera in pydantic_scene.cameras:\n        view_matrix = PydanticParser._pydantic_to_transbuf(pydantic_camera.view_matrix)\n        projection_matrix = PydanticParser._pydantic_to_transbuf(pydantic_camera.projection_matrix)\n        camera = Camera(view_matrix, projection_matrix)\n        camera._uuid = pydantic_camera.uuid\n        cameras.append(camera)\n\n    # =============================================================================\n    # Return the renderer arguments\n    # =============================================================================\n    return canvas, viewports, visuals, model_matrices, cameras\n</code></pre>"},{"location":"api/gsp_pydantic/#types-module","title":"Types Module","text":"<p>The types module defines Pydantic models for GSP data structures, providing validation and schema generation.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types","title":"<code>gsp_pydantic.types</code>","text":"<p>Pydantic types for GSP data structures.</p>"},{"location":"api/gsp_pydantic/#pydantic-dict","title":"Pydantic Dict","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_dict","title":"<code>gsp_pydantic.types.pydantic_dict</code>","text":"<p>Pydantic type for a dictionary with string keys and any values.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_dict.PydanticDict","title":"<code>PydanticDict = Dict[str, Any]</code>  <code>module-attribute</code>","text":"<p>Type alias for a dictionary with string keys and any values.</p>"},{"location":"api/gsp_pydantic/#pydantic-types","title":"Pydantic Types","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types","title":"<code>gsp_pydantic.types.pydantic_types</code>","text":"<p>\"Pydantic models for GSP data types.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticGroups","title":"<code>PydanticGroups = Union[int, list[int], list[list[int]]]</code>  <code>module-attribute</code>","text":"<p>Type alias for groups which can be an int, a list of ints, or a list of list of ints.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticBuffer","title":"<code>PydanticBuffer</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a buffer with encoded data.</p> <p>This class stores buffer data in a serializable format using base64 encoding.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticBuffer(BaseModel):\n    \"\"\"Pydantic model representing a buffer with encoded data.\n\n    This class stores buffer data in a serializable format using base64 encoding.\n    \"\"\"\n\n    count: int\n    \"\"\"number of elements in the buffer\"\"\"\n    buffer_type: str\n    \"\"\"type of the buffer elements, corresponds to BufferType enum value\"\"\"\n    data_base64: str\n    \"\"\"data encoded in base64 format\"\"\"\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticBuffer.buffer_type","title":"<code>buffer_type: str</code>  <code>instance-attribute</code>","text":"<p>type of the buffer elements, corresponds to BufferType enum value</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticBuffer.count","title":"<code>count: int</code>  <code>instance-attribute</code>","text":"<p>number of elements in the buffer</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticBuffer.data_base64","title":"<code>data_base64: str</code>  <code>instance-attribute</code>","text":"<p>data encoded in base64 format</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticCamera","title":"<code>PydanticCamera</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a camera.</p> <p>Defines the camera's view and projection transformations for rendering the scene.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticCamera(BaseModel):\n    \"\"\"Pydantic model representing a camera.\n\n    Defines the camera's view and projection transformations for rendering the scene.\n    \"\"\"\n\n    uuid: str\n    view_matrix: PydanticTransBuf\n    projection_matrix: PydanticTransBuf\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticCanvas","title":"<code>PydanticCanvas</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a canvas for rendering.</p> <p>Defines the rendering surface with dimensions and resolution.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticCanvas(BaseModel):\n    \"\"\"Pydantic model representing a canvas for rendering.\n\n    Defines the rendering surface with dimensions and resolution.\n    \"\"\"\n\n    uuid: str\n    width: int\n    height: int\n    dpi: float\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticMarkers","title":"<code>PydanticMarkers</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing marker visual elements.</p> <p>Markers are geometric shapes (circles, squares, etc.) positioned in space with configurable appearance properties.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticMarkers(BaseModel):\n    \"\"\"Pydantic model representing marker visual elements.\n\n    Markers are geometric shapes (circles, squares, etc.) positioned in space\n    with configurable appearance properties.\n    \"\"\"\n\n    uuid: str\n    marker_shape: str\n    positions: PydanticTransBuf\n    sizes: PydanticTransBuf\n    face_colors: PydanticTransBuf\n    edge_colors: PydanticTransBuf\n    edge_widths: PydanticTransBuf\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticModelMatrix","title":"<code>PydanticModelMatrix</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a model transformation matrix.</p> <p>Contains the transformation matrix for positioning objects in the scene.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticModelMatrix(BaseModel):\n    \"\"\"Pydantic model representing a model transformation matrix.\n\n    Contains the transformation matrix for positioning objects in the scene.\n    \"\"\"\n\n    model_matrix: PydanticTransBuf\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticPaths","title":"<code>PydanticPaths</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing path visual elements.</p> <p>Paths are continuous lines or curves with configurable line styles and colors.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticPaths(BaseModel):\n    \"\"\"Pydantic model representing path visual elements.\n\n    Paths are continuous lines or curves with configurable line styles and colors.\n    \"\"\"\n\n    uuid: str\n    positions: PydanticTransBuf\n    path_sizes: PydanticTransBuf\n    colors: PydanticTransBuf\n    line_widths: PydanticTransBuf\n    cap_style: str\n    join_style: str\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticPixels","title":"<code>PydanticPixels</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing pixel visual elements.</p> <p>Pixels are individual colored points organized into groups.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticPixels(BaseModel):\n    \"\"\"Pydantic model representing pixel visual elements.\n\n    Pixels are individual colored points organized into groups.\n    \"\"\"\n\n    uuid: str\n    positions: PydanticTransBuf\n    colors: PydanticTransBuf\n    groups: PydanticGroups\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticPoints","title":"<code>PydanticPoints</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing point visual elements.</p> <p>Points are circular elements with configurable size and appearance, including face color, edge color, and edge width.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticPoints(BaseModel):\n    \"\"\"Pydantic model representing point visual elements.\n\n    Points are circular elements with configurable size and appearance,\n    including face color, edge color, and edge width.\n    \"\"\"\n\n    uuid: str\n    positions: PydanticTransBuf\n    sizes: PydanticTransBuf\n    face_colors: PydanticTransBuf\n    edge_colors: PydanticTransBuf\n    edge_widths: PydanticTransBuf\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticScene","title":"<code>PydanticScene</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a complete scene.</p> <p>Aggregates all scene elements including canvas, viewports, visual elements, transformation matrices, and cameras.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticScene(BaseModel):\n    \"\"\"Pydantic model representing a complete scene.\n\n    Aggregates all scene elements including canvas, viewports, visual elements,\n    transformation matrices, and cameras.\n    \"\"\"\n\n    canvas: PydanticCanvas\n    viewports: list[PydanticViewport]\n    visuals: list[PydanticVisual]\n    model_matrices: list[PydanticModelMatrix]\n    cameras: list[PydanticCamera]\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticSegments","title":"<code>PydanticSegments</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing line segment visual elements.</p> <p>Segments are individual line segments with configurable width, color, and cap style.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticSegments(BaseModel):\n    \"\"\"Pydantic model representing line segment visual elements.\n\n    Segments are individual line segments with configurable width, color, and cap style.\n    \"\"\"\n\n    uuid: str\n    positions: PydanticTransBuf\n    line_widths: PydanticTransBuf\n    cap_style: str\n    colors: PydanticTransBuf\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticTexts","title":"<code>PydanticTexts</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing text visual elements.</p> <p>Text elements with configurable position, font properties, colors, and orientation.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticTexts(BaseModel):\n    \"\"\"Pydantic model representing text visual elements.\n\n    Text elements with configurable position, font properties, colors, and orientation.\n    \"\"\"\n\n    uuid: str\n    positions: PydanticTransBuf\n    texts: list[str]\n    colors: PydanticTransBuf\n    font_sizes: PydanticTransBuf\n    anchors: PydanticTransBuf\n    angles: PydanticTransBuf\n    font_name: str\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticTransBuf","title":"<code>PydanticTransBuf</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model for a transform buffer union type.</p> <p>Can represent either a buffer or a transform chain, discriminated by the type field.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticTransBuf(BaseModel):\n    \"\"\"Pydantic model for a transform buffer union type.\n\n    Can represent either a buffer or a transform chain, discriminated by the type field.\n    \"\"\"\n\n    type: Literal[\"buffer\", \"transform_chain\"]\n    transBuf: PydanticBuffer | PydanticTransformChain\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticTransformChain","title":"<code>PydanticTransformChain</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a chain of transformations.</p> <p>Contains a dictionary representing the transformation chain configuration.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticTransformChain(BaseModel):\n    \"\"\"Pydantic model representing a chain of transformations.\n\n    Contains a dictionary representing the transformation chain configuration.\n    \"\"\"\n\n    transform_chain: dict[str, Any]\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticViewport","title":"<code>PydanticViewport</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a viewport region.</p> <p>Defines a rectangular viewing area within the canvas.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticViewport(BaseModel):\n    \"\"\"Pydantic model representing a viewport region.\n\n    Defines a rectangular viewing area within the canvas.\n    \"\"\"\n\n    uuid: str\n    x: int\n    y: int\n    width: int\n    height: int\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticVisual","title":"<code>PydanticVisual</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model for a visual element union type.</p> <p>Discriminated union that can represent any of the visual element types, distinguished by the type field.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticVisual(BaseModel):\n    \"\"\"Pydantic model for a visual element union type.\n\n    Discriminated union that can represent any of the visual element types,\n    distinguished by the type field.\n    \"\"\"\n\n    type: Literal[\"markers\", \"paths\", \"pixels\", \"points\", \"segments\", \"texts\"]\n    visual: PydanticMarkers | PydanticPaths | PydanticPixels | PydanticPoints | PydanticSegments | PydanticTexts\n</code></pre>"},{"location":"api/vispy_2/","title":"VisPy 2 API Reference","text":"<p>The VisPy 2 package provides high-level components for interactive axes display and pan/zoom functionality, building on top of the GSP API.</p>"},{"location":"api/vispy_2/#overview","title":"Overview","text":""},{"location":"api/vispy_2/#vispy_2","title":"<code>vispy_2</code>","text":"<p>VisPy 2 package.</p>"},{"location":"api/vispy_2/#axes-module","title":"Axes Module","text":"<p>The axes module provides components for displaying and interacting with 2D axes in a viewport.</p>"},{"location":"api/vispy_2/#vispy_2.axes","title":"<code>vispy_2.axes</code>","text":"<p>Initialization code for the axes module.</p>"},{"location":"api/vispy_2/#axes-display","title":"Axes Display","text":""},{"location":"api/vispy_2/#vispy_2.axes.axes_display","title":"<code>vispy_2.axes.axes_display</code>","text":"<p>Module providing an AxesDisplay class to display axes in a viewport using NDC conversions.</p>"},{"location":"api/vispy_2/#vispy_2.axes.axes_display.AxesDisplay","title":"<code>AxesDisplay</code>","text":"<p>Class to display axes in a viewport using NDC conversions.</p> Source code in <code>src/vispy_2/axes/axes_display.py</code> <pre><code>class AxesDisplay:\n    \"\"\"Class to display axes in a viewport using NDC conversions.\"\"\"\n\n    def __init__(self, canvas: Canvas, inner_viewport: Viewport) -&gt; None:\n        \"\"\"Initialize the AxesDisplay example.\"\"\"\n        self._canvas = canvas\n        \"\"\"Canvas to render on.\"\"\"\n        self._inner_viewport = inner_viewport\n        \"\"\"Innert viewport to render visual in.\"\"\"\n        self._outter_viewport = Viewport(0, 0, self._canvas.get_width(), self._canvas.get_height())\n        \"\"\"Outter viewport to render axes in (arround inner viewport).\"\"\"\n\n        self._inner_viewport_unit = ViewportUnitUtils(self._canvas, self._inner_viewport)\n        \"\"\"Unit converter for inner viewport.\"\"\"\n        self._outter_viewport_unit = ViewportUnitUtils(self._canvas, self._outter_viewport)\n        \"\"\"Unit converter for outter viewport.\"\"\"\n        self._x_min_dunit = -1.0\n        \"\"\"x minimum in data units.\"\"\"\n        self._x_max_dunit = +1.0\n        \"\"\"x maximum in data units.\"\"\"\n        self._y_min_dunit = -1.0\n        \"\"\"y minimum in data units.\"\"\"\n        self._y_max_dunit = +1.0\n        \"\"\"y maximum in data units.\"\"\"\n\n        self.new_limits_event = Event[AxesDisplayNewLimitsEventCallback]()\n        \"\"\"Event triggered when the axes limits are changed.\n\n        Allow to render visuals and axes synchronously when axes limits change.\n        \"\"\"\n\n        # Initialize render items\n        self._axes_segments_render_item: RenderItem | None = None\n        self._ticks_horizontal_render_item: RenderItem | None = None\n        self._ticks_vertical_render_item: RenderItem | None = None\n        self._texts_horizontal_render_item: RenderItem | None = None\n        self._texts_vertical_render_item: RenderItem | None = None\n\n        # Build render items\n        self._build_render_items()\n\n    def set_limits_dunit(self, x_min_dunit: float, x_max_dunit: float, y_min_dunit: float, y_max_dunit: float) -&gt; None:\n        \"\"\"Set the axes limits in data units.\"\"\"\n        # sanity checks\n        assert x_min_dunit &lt; x_max_dunit, f\"x_min MUST be less than x_max, got x_min_dunit={x_min_dunit}, x_max_dunit={x_max_dunit}\"\n        assert y_min_dunit &lt; y_max_dunit, f\"y_min MUST be less than y_max, got y_min_dunit={y_min_dunit}, y_max_dunit={y_max_dunit}\"\n\n        # set limits\n        self._x_min_dunit = x_min_dunit\n        self._x_max_dunit = x_max_dunit\n        self._y_min_dunit = y_min_dunit\n        self._y_max_dunit = y_max_dunit\n\n        # rebuild render items\n        self._build_render_items()\n\n        # Notify event listeners\n        self.new_limits_event.dispatch()\n\n    def get_limits_dunit(self) -&gt; tuple[float, float, float, float]:\n        \"\"\"Get the axes limits in data units.\"\"\"\n        return (self._x_min_dunit, self._x_max_dunit, self._y_min_dunit, self._y_max_dunit)\n\n    def get_transform_matrix_numpy(self) -&gt; np.ndarray:\n        \"\"\"Get the transform matrix from data units to NDC units for the inner viewport.\"\"\"\n        # Compute translation matrix\n        translation_matrix = glm.translate(np.array([-(self._x_max_dunit + self._x_min_dunit) / 2.0, -(self._y_max_dunit + self._y_min_dunit) / 2.0, 0.0]))\n        # Compute scale matrix\n        scale_matrix = glm.scale(np.array([2.0 / (self._x_max_dunit - self._x_min_dunit), 2.0 / (self._y_max_dunit - self._y_min_dunit), 1.0]))\n        # Combine translation and scale to get the final transform matrix\n        axes_transform_numpy = scale_matrix @ translation_matrix\n        # Return the transform matrix\n        return axes_transform_numpy\n\n    def get_inner_viewport(self) -&gt; Viewport:\n        \"\"\"Get the inner viewport.\"\"\"\n        return self._inner_viewport\n\n    def get_outter_viewport(self) -&gt; Viewport:\n        \"\"\"Get the outter viewport.\"\"\"\n        return self._outter_viewport\n\n    def get_render_items(self) -&gt; list[RenderItem]:\n        \"\"\"Get the render items for the axes display.\"\"\"\n        # Collect all render items into a list\n        render_items: list[RenderItem] = []\n        if self._axes_segments_render_item is not None:\n            render_items.append(self._axes_segments_render_item)\n        if self._ticks_horizontal_render_item is not None:\n            render_items.append(self._ticks_horizontal_render_item)\n        if self._ticks_vertical_render_item is not None:\n            render_items.append(self._ticks_vertical_render_item)\n        if self._texts_horizontal_render_item is not None:\n            render_items.append(self._texts_horizontal_render_item)\n        if self._texts_vertical_render_item is not None:\n            render_items.append(self._texts_vertical_render_item)\n        # Retrun the render items\n        return render_items\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    def _build_render_items(self) -&gt; None:\n        \"\"\"Build the render items for the axes display.\"\"\"\n        has_tick_horizontal = AxesDisplay._has_tick_horizontal(self._inner_viewport_unit, self._outter_viewport_unit, self._x_min_dunit, self._x_max_dunit)\n        has_tick_vertical = AxesDisplay._has_tick_vertical(self._inner_viewport_unit, self._outter_viewport_unit, self._y_min_dunit, self._y_max_dunit)\n\n        # =============================================================================\n        # Create new axes segments, preserving UUIDs to avoid recreating visuals\n        # =============================================================================\n        axes_segments_uuid: str | None = self._axes_segments_render_item.visual_base.get_uuid() if self._axes_segments_render_item is not None else None\n        self._axes_segments_render_item = RenderItem(\n            self._outter_viewport_unit.get_viewport(),\n            AxesDisplay._generate_visual_axes_segments(self._inner_viewport_unit, self._outter_viewport_unit),\n            Bufferx.mat4_identity(),\n            Camera(Bufferx.mat4_identity(), Bufferx.mat4_identity()),\n        )\n        if axes_segments_uuid is not None:\n            self._axes_segments_render_item.visual_base.set_uuid(axes_segments_uuid)\n\n        # =============================================================================\n        # Create new horizontal ticks, preserving UUIDs to avoid recreating visuals\n        # =============================================================================\n        if has_tick_horizontal is True:\n            ticks_horizontal_uuid: str | None = (\n                self._ticks_horizontal_render_item.visual_base.get_uuid() if self._ticks_horizontal_render_item is not None else None\n            )\n            self._ticks_horizontal_render_item = RenderItem(\n                self._outter_viewport_unit.get_viewport(),\n                AxesDisplay._generate_visual_ticks_horizontal(self._inner_viewport_unit, self._outter_viewport_unit, self._x_min_dunit, self._x_max_dunit),\n                Bufferx.mat4_identity(),\n                Camera(Bufferx.mat4_identity(), Bufferx.mat4_identity()),\n            )\n            if ticks_horizontal_uuid is not None:\n                self._ticks_horizontal_render_item.visual_base.set_uuid(ticks_horizontal_uuid)\n        else:\n            self._ticks_horizontal_render_item = None\n\n        # =============================================================================\n        # Create new vertical ticks, preserving UUIDs to avoid recreating visuals\n        # =============================================================================\n        if has_tick_vertical is True:\n            ticks_vertical_uuid: str | None = self._ticks_vertical_render_item.visual_base.get_uuid() if self._ticks_vertical_render_item is not None else None\n            self._ticks_vertical_render_item = RenderItem(\n                self._outter_viewport_unit.get_viewport(),\n                AxesDisplay._generate_visual_ticks_vertical(self._inner_viewport_unit, self._outter_viewport_unit, self._y_min_dunit, self._y_max_dunit),\n                Bufferx.mat4_identity(),\n                Camera(Bufferx.mat4_identity(), Bufferx.mat4_identity()),\n            )\n            if ticks_vertical_uuid is not None:\n                self._ticks_vertical_render_item.visual_base.set_uuid(ticks_vertical_uuid)\n        else:\n            self._ticks_vertical_render_item = None\n\n        # =============================================================================\n        # Create new horizontal texts, preserving UUIDs to avoid recreating visuals\n        # =============================================================================\n        if has_tick_horizontal is True:\n            texts_horizontal_uuid: str | None = (\n                self._texts_horizontal_render_item.visual_base.get_uuid() if self._texts_horizontal_render_item is not None else None\n            )\n            self._texts_horizontal_render_item = RenderItem(\n                self._outter_viewport_unit.get_viewport(),\n                AxesDisplay._generate_visual_texts_horizontal(self._inner_viewport_unit, self._outter_viewport_unit, self._x_min_dunit, self._x_max_dunit),\n                Bufferx.mat4_identity(),\n                Camera(Bufferx.mat4_identity(), Bufferx.mat4_identity()),\n            )\n            if texts_horizontal_uuid is not None:\n                self._texts_horizontal_render_item.visual_base.set_uuid(texts_horizontal_uuid)\n        else:\n            self._texts_horizontal_render_item = None\n\n        # =============================================================================\n        # Create new vertical texts, preserving UUIDs to avoid recreating visuals\n        # =============================================================================\n        if has_tick_vertical is True:\n            texts_vertical_uuid: str | None = self._texts_vertical_render_item.visual_base.get_uuid() if self._texts_vertical_render_item is not None else None\n            self._texts_vertical_render_item = RenderItem(\n                self._outter_viewport_unit.get_viewport(),\n                AxesDisplay._generate_visual_texts_vertical(self._inner_viewport_unit, self._outter_viewport_unit, self._y_min_dunit, self._y_max_dunit),\n                Bufferx.mat4_identity(),\n                Camera(Bufferx.mat4_identity(), Bufferx.mat4_identity()),\n            )\n            if texts_vertical_uuid is not None:\n                self._texts_vertical_render_item.visual_base.set_uuid(texts_vertical_uuid)\n        else:\n            self._texts_vertical_render_item = None\n\n    @staticmethod\n    def _has_tick_horizontal(\n        inner_viewport_unit: ViewportUnitUtils,\n        outter_viewport_unit: ViewportUnitUtils,\n        x_min_dunit: float,\n        x_max_dunit: float,\n    ) -&gt; bool:\n        \"\"\"Check if there is at least one tick to display for the horizontal axis.\"\"\"\n        coords_array, _ = AxesDisplay._compute_tick_coords_horizontal(inner_viewport_unit, outter_viewport_unit, x_min_dunit, x_max_dunit)\n\n        has_tick_horizontal = len(coords_array) &gt; 0\n        return has_tick_horizontal\n\n    @staticmethod\n    def _has_tick_vertical(\n        inner_viewport_unit: ViewportUnitUtils,\n        outter_viewport_unit: ViewportUnitUtils,\n        y_min_dunit: float,\n        y_max_dunit: float,\n    ) -&gt; bool:\n        \"\"\"Check if there is at least one tick to display for the vertical axis.\"\"\"\n        coords_array, _ = AxesDisplay._compute_tick_coords_vertical(inner_viewport_unit, outter_viewport_unit, y_min_dunit, y_max_dunit)\n\n        has_tick_vertical = len(coords_array) &gt; 0\n        return has_tick_vertical\n\n    @staticmethod\n    def _compute_tick_coords_horizontal(\n        inner_viewport_unit: ViewportUnitUtils,\n        outter_viewport_unit: ViewportUnitUtils,\n        x_min_dunit: float,\n        x_max_dunit: float,\n    ) -&gt; tuple[list[Tuple[float, float, float]], list[str]]:\n        \"\"\"Compute the tick coordinates in outer viewport NDC for the horizontal axis.\"\"\"\n        inner_viewport = inner_viewport_unit.get_viewport()\n\n        # compute tick_y_outter_ndc\n        tick_y_inner_ndc = -1.0  # at bottom of inner viewport\n        tick_y_outter_pixel = inner_viewport.get_y() + ((tick_y_inner_ndc + 1.0) / 2.0) * inner_viewport.get_height()\n        _, tick_y_outter_delta_ndc = outter_viewport_unit.delta_pixel_to_ndc(0.0, tick_y_outter_pixel)\n        tick_y_outter_ndc = tick_y_outter_delta_ndc - 1.0\n\n        # Compute nice tick positions and labels using AxisTickLocator and AxisTickFormatter\n        tick_locator = AxisTickLocator(target_ticks=7)\n        tick_positions_dunit, tick_step = tick_locator.compute_location_dunit(x_min_dunit, x_max_dunit)\n        tick_formatter = AxisTickFormatter()\n        tick_labels = [tick_formatter.format(tick_position, tick_step) for tick_position in tick_positions_dunit]\n\n        # Create positions for ticks from -num_ticks/2 to +num_ticks/2\n        tick_positions = []\n        for tick_x_inner_dunit in tick_positions_dunit:\n            # compute tick_x_outter_ndc\n            tick_x_inner_ndc = (tick_x_inner_dunit - x_min_dunit) / (x_max_dunit - x_min_dunit) * 2.0 - 1.0\n            tick_x_outter_delta_pixel = inner_viewport.get_x() + ((tick_x_inner_ndc + 1.0) / 2.0) * inner_viewport.get_width()\n            tick_x_outter_delta_ndc, _ = outter_viewport_unit.delta_pixel_to_ndc(tick_x_outter_delta_pixel, 0.0)\n            tick_x_outter_ndc = tick_x_outter_delta_ndc - 1.0\n\n            tick_positions.append([tick_x_outter_ndc, tick_y_outter_ndc, 0.0])\n\n        # =============================================================================\n        # Return coord_array and tick_labels\n        # =============================================================================\n        return tick_positions, tick_labels\n\n    @staticmethod\n    def _compute_tick_coords_vertical(\n        inner_viewport_unit: ViewportUnitUtils,\n        outter_viewport_unit: ViewportUnitUtils,\n        y_min_dunit: float,\n        y_max_dunit: float,\n    ) -&gt; tuple[list[Tuple[float, float, float]], list[str]]:\n        \"\"\"Compute the tick coordinates in outer viewport NDC for the vertical axis.\"\"\"\n        inner_viewport = inner_viewport_unit.get_viewport()\n\n        # compute tick_x_outter_ndc\n        tick_x_inner_ndc = -1.0  # at left of inner viewport\n        tick_x_outter_pixel = inner_viewport.get_x() + ((tick_x_inner_ndc + 1.0) / 2.0) * inner_viewport.get_width()\n        tick_x_outter_delta_ndc, _ = outter_viewport_unit.delta_pixel_to_ndc(tick_x_outter_pixel, 0.0)\n        tick_x_outter_ndc = tick_x_outter_delta_ndc - 1.0\n\n        # Compute nice tick positions and labels using AxisTickLocator and AxisTickFormatter\n        tick_locator = AxisTickLocator(target_ticks=7)\n        tick_positions_dunit, tick_step = tick_locator.compute_location_dunit(y_min_dunit, y_max_dunit)\n        tick_formatter = AxisTickFormatter()\n        tick_labels = [tick_formatter.format(tick_position, tick_step) for tick_position in tick_positions_dunit]\n\n        # Create positions for ticks from -num_ticks/2 to +num_ticks/2\n        tick_positions = []\n        # for tick_y_inner_dunit in range(math.ceil(y_min_dunit), math.ceil(y_max_dunit) + 1):\n        for tick_y_inner_dunit in tick_positions_dunit:\n            # compute tick_y_outter_ndc\n            tick_y_inner_ndc = (tick_y_inner_dunit - y_min_dunit) / (y_max_dunit - y_min_dunit) * 2.0 - 1.0\n            tick_y_outter_delta_pixel = inner_viewport.get_y() + ((tick_y_inner_ndc + 1.0) / 2.0) * inner_viewport.get_height()\n            _, tick_y_outter_delta_ndc = outter_viewport_unit.delta_pixel_to_ndc(0.0, tick_y_outter_delta_pixel)\n            tick_y_outter_ndc = tick_y_outter_delta_ndc - 1.0\n\n            tick_positions.append([tick_x_outter_ndc, tick_y_outter_ndc, 0.0])\n\n        return tick_positions, tick_labels\n\n    @staticmethod\n    def _generate_visual_axes_segments(inner_viewport_unit: ViewportUnitUtils, outter_viewport_unit: ViewportUnitUtils) -&gt; Segments:\n        \"\"\"Generate axes segments in NDC units for the given viewport.\"\"\"\n        inner_viewport = inner_viewport_unit.get_viewport()\n        canvas = inner_viewport_unit.get_canvas()\n\n        # Compute NDC coordinates of the inner viewport corners in outter viewport\n        delta_min_ndc = outter_viewport_unit.delta_pixel_to_ndc(inner_viewport.get_x(), inner_viewport.get_y())\n        delta_max_ndc = outter_viewport_unit.delta_pixel_to_ndc(\n            inner_viewport.get_x() + inner_viewport.get_width(),\n            inner_viewport.get_y() + inner_viewport.get_height(),\n        )\n        coord_min_ndc = (-1.0 + delta_min_ndc[0], -1.0 + delta_min_ndc[1])\n        coord_max_ndc = (-1.0 + delta_max_ndc[0], -1.0 + delta_max_ndc[1])\n\n        # Create segments for the axes\n        segments_count = 2\n        positions_numpy = np.array(\n            [\n                [coord_min_ndc[0], coord_min_ndc[1], 0.0],\n                [coord_max_ndc[0], coord_min_ndc[1], 0.0],\n                [coord_min_ndc[0], coord_min_ndc[1], 0.0],\n                [coord_min_ndc[0], coord_max_ndc[1], 0.0],\n            ],\n            dtype=np.float32,\n        )\n        positions_buffer = Bufferx.from_numpy(positions_numpy, BufferType.vec3)\n\n        line_widths_numpy = np.array([UnitUtils.pixel_to_point(2, canvas.get_dpi())] * segments_count, dtype=np.float32)\n        line_widths_buffer = Bufferx.from_numpy(line_widths_numpy, BufferType.float32)\n\n        colors_buffer = Buffer(segments_count, BufferType.rgba8)\n        colors_buffer.set_data(Constants.Color.black * segments_count, 0, segments_count)\n\n        segments = Segments(positions_buffer, line_widths_buffer, CapStyle.ROUND, colors_buffer)\n        return segments\n\n    @staticmethod\n    def _generate_visual_ticks_horizontal(\n        inner_viewport_unit: ViewportUnitUtils,\n        outter_viewport_unit: ViewportUnitUtils,\n        x_min_dunit: float,\n        x_max_dunit: float,\n    ) -&gt; Segments:\n        canvas = outter_viewport_unit.get_canvas()\n\n        # get tick coordinates\n        coords_array, _ = AxesDisplay._compute_tick_coords_horizontal(inner_viewport_unit, outter_viewport_unit, x_min_dunit, x_max_dunit)\n\n        # compute tick_height_ndc\n        _, tick_height_ndc = outter_viewport_unit.delta_cm_to_ndc(0.0, 0.2)\n\n        # build positions array from coords\n        positions_array = []\n        for tick_x_outter_ndc, tick_y_outter_ndc, tick_z_outter_ndc in coords_array:\n            positions_array.append([tick_x_outter_ndc, tick_y_outter_ndc + 0.0, 0.0])\n            positions_array.append([tick_x_outter_ndc, tick_y_outter_ndc - tick_height_ndc, 0.0])\n\n        positions_numpy = np.array(positions_array, dtype=np.float32)\n        positions_buffer = Bufferx.from_numpy(positions_numpy, BufferType.vec3)\n\n        # sanitity checks\n        assert positions_buffer.get_count() % 2 == 0\n        segments_count = positions_buffer.get_count() // 2\n        assert segments_count == positions_buffer.get_count() / 2\n\n        line_widths_numpy = np.array([UnitUtils.pixel_to_point(1, canvas.get_dpi())] * segments_count, dtype=np.float32)\n        line_widths_buffer = Bufferx.from_numpy(line_widths_numpy, BufferType.float32)\n\n        colors_buffer = Buffer(segments_count, BufferType.rgba8)\n        colors_buffer.set_data(Constants.Color.black * segments_count, 0, segments_count)\n\n        segments = Segments(positions_buffer, line_widths_buffer, CapStyle.ROUND, colors_buffer)\n        return segments\n\n    @staticmethod\n    def _generate_visual_ticks_vertical(\n        inner_viewport_unit: ViewportUnitUtils,\n        outter_viewport_unit: ViewportUnitUtils,\n        y_min_dunit: float,\n        y_max_dunit: float,\n    ) -&gt; Segments:\n        canvas = outter_viewport_unit.get_canvas()\n\n        # get tick coordinates\n        coords_array, tick_labels = AxesDisplay._compute_tick_coords_vertical(inner_viewport_unit, outter_viewport_unit, y_min_dunit, y_max_dunit)\n\n        # compute tick_width_ndc\n        tick_width_ndc, _ = outter_viewport_unit.delta_cm_to_ndc(0.2, 0.0)\n\n        # build positions array from coords\n        positions_array = []\n        for tick_x_outter_ndc, tick_y_outter_ndc, tick_z_outter_ndc in coords_array:\n            positions_array.append([tick_x_outter_ndc + 0.0, tick_y_outter_ndc, 0.0])\n            positions_array.append([tick_x_outter_ndc - tick_width_ndc, tick_y_outter_ndc, 0.0])\n\n        positions_numpy = np.array(positions_array, dtype=np.float32)\n        positions_buffer = Bufferx.from_numpy(positions_numpy, BufferType.vec3)\n\n        # sanitity checks\n        assert positions_buffer.get_count() % 2 == 0\n        segments_count = positions_buffer.get_count() // 2\n        assert segments_count == positions_buffer.get_count() / 2\n\n        line_widths_numpy = np.array([UnitUtils.pixel_to_point(1, canvas.get_dpi())] * segments_count, dtype=np.float32)\n        line_widths_buffer = Bufferx.from_numpy(line_widths_numpy, BufferType.float32)\n\n        colors_buffer = Buffer(segments_count, BufferType.rgba8)\n        colors_buffer.set_data(Constants.Color.black * segments_count, 0, segments_count)\n\n        segments = Segments(positions_buffer, line_widths_buffer, CapStyle.BUTT, colors_buffer)\n        return segments\n\n    @staticmethod\n    def _generate_visual_texts_horizontal(\n        inner_viewport_unit: ViewportUnitUtils,\n        outter_viewport_unit: ViewportUnitUtils,\n        x_min_dunit: float,\n        x_max_dunit: float,\n    ) -&gt; Texts:\n        canvas = outter_viewport_unit.get_canvas()\n\n        # get tick coordinates\n        coords_array, tick_labels = AxesDisplay._compute_tick_coords_horizontal(inner_viewport_unit, outter_viewport_unit, x_min_dunit, x_max_dunit)\n\n        # compute tick_height_ndc\n        _, tick_height_ndc = outter_viewport_unit.delta_cm_to_ndc(0.0, 0.3)\n\n        # build positions array from coords\n        positions_array = []\n        for tick_x_outter_ndc, tick_y_outter_ndc, tick_z_outter_ndc in coords_array:\n            positions_array.append([tick_x_outter_ndc, tick_y_outter_ndc - tick_height_ndc, 0.0])\n\n        positions_numpy = np.array(positions_array, dtype=np.float32)\n        positions_buffer = Bufferx.from_numpy(positions_numpy, BufferType.vec3)\n\n        labels_count = len(tick_labels)\n\n        colors_buffer = Buffer(labels_count, BufferType.rgba8)\n        colors_buffer.set_data(Constants.Color.black * labels_count, 0, labels_count)\n\n        font_size_numpy = np.array([UnitUtils.pixel_to_point(12, canvas.get_dpi())] * labels_count, dtype=np.float32)\n        font_size_buffer = Bufferx.from_numpy(font_size_numpy, BufferType.float32)\n\n        # Create a anchor_numpy for each string with a bottom-left anchor\n        anchors_numpy = np.array([[0, 1] for _ in range(labels_count)], dtype=np.float32)\n        anchors_buffer = Bufferx.from_numpy(anchors_numpy, BufferType.vec2)\n\n        angles_numpy = np.array([[0] for _ in range(labels_count)], dtype=np.float32)\n        angles_buffer = Bufferx.from_numpy(angles_numpy, BufferType.float32)\n\n        font_name = \"Arial\"\n\n        # Create the Texts visual\n        texts = Texts(positions_buffer, tick_labels, colors_buffer, font_size_buffer, anchors_buffer, angles_buffer, font_name)\n\n        return texts\n\n    @staticmethod\n    def _generate_visual_texts_vertical(\n        inner_viewport_unit: ViewportUnitUtils,\n        outter_viewport_unit: ViewportUnitUtils,\n        y_min_dunit: float,\n        y_max_dunit: float,\n    ) -&gt; Texts:\n        canvas = outter_viewport_unit.get_canvas()\n\n        # get tick coordinates\n        coords_array, tick_labels = AxesDisplay._compute_tick_coords_vertical(inner_viewport_unit, outter_viewport_unit, y_min_dunit, y_max_dunit)\n\n        # compute tick_width_ndc\n        tick_width_ndc, _ = outter_viewport_unit.delta_cm_to_ndc(0.3, 0.0)\n\n        # build positions array from coords\n        positions_array = []\n        for tick_x_outter_ndc, tick_y_outter_ndc, tick_z_outter_ndc in coords_array:\n            positions_array.append([tick_x_outter_ndc - tick_width_ndc, tick_y_outter_ndc, 0.0])\n\n        positions_numpy = np.array(positions_array, dtype=np.float32)\n        positions_buffer = Bufferx.from_numpy(positions_numpy, BufferType.vec3)\n\n        label_count = len(tick_labels)\n\n        colors_buffer = Buffer(label_count, BufferType.rgba8)\n        colors_buffer.set_data(Constants.Color.black * label_count, 0, label_count)\n\n        font_size_numpy = np.array([UnitUtils.pixel_to_point(12, canvas.get_dpi())] * label_count, dtype=np.float32)\n        font_size_buffer = Bufferx.from_numpy(font_size_numpy, BufferType.float32)\n\n        # Create a anchor_numpy for each string with a bottom-left anchor\n        anchors_numpy = np.array([[1, 0] for _ in range(label_count)], dtype=np.float32)\n        anchors_buffer = Bufferx.from_numpy(anchors_numpy, BufferType.vec2)\n\n        angles_numpy = np.array([[0] for _ in range(label_count)], dtype=np.float32)\n        angles_buffer = Bufferx.from_numpy(angles_numpy, BufferType.float32)\n\n        font_name = \"Arial\"\n\n        # Create the Texts visual\n        texts = Texts(positions_buffer, tick_labels, colors_buffer, font_size_buffer, anchors_buffer, angles_buffer, font_name)\n\n        return texts\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_display.AxesDisplay.new_limits_event","title":"<code>new_limits_event = Event[AxesDisplayNewLimitsEventCallback]()</code>  <code>instance-attribute</code>","text":"<p>Event triggered when the axes limits are changed.</p> <p>Allow to render visuals and axes synchronously when axes limits change.</p>"},{"location":"api/vispy_2/#vispy_2.axes.axes_display.AxesDisplay.__init__","title":"<code>__init__(canvas: Canvas, inner_viewport: Viewport) -&gt; None</code>","text":"<p>Initialize the AxesDisplay example.</p> Source code in <code>src/vispy_2/axes/axes_display.py</code> <pre><code>def __init__(self, canvas: Canvas, inner_viewport: Viewport) -&gt; None:\n    \"\"\"Initialize the AxesDisplay example.\"\"\"\n    self._canvas = canvas\n    \"\"\"Canvas to render on.\"\"\"\n    self._inner_viewport = inner_viewport\n    \"\"\"Innert viewport to render visual in.\"\"\"\n    self._outter_viewport = Viewport(0, 0, self._canvas.get_width(), self._canvas.get_height())\n    \"\"\"Outter viewport to render axes in (arround inner viewport).\"\"\"\n\n    self._inner_viewport_unit = ViewportUnitUtils(self._canvas, self._inner_viewport)\n    \"\"\"Unit converter for inner viewport.\"\"\"\n    self._outter_viewport_unit = ViewportUnitUtils(self._canvas, self._outter_viewport)\n    \"\"\"Unit converter for outter viewport.\"\"\"\n    self._x_min_dunit = -1.0\n    \"\"\"x minimum in data units.\"\"\"\n    self._x_max_dunit = +1.0\n    \"\"\"x maximum in data units.\"\"\"\n    self._y_min_dunit = -1.0\n    \"\"\"y minimum in data units.\"\"\"\n    self._y_max_dunit = +1.0\n    \"\"\"y maximum in data units.\"\"\"\n\n    self.new_limits_event = Event[AxesDisplayNewLimitsEventCallback]()\n    \"\"\"Event triggered when the axes limits are changed.\n\n    Allow to render visuals and axes synchronously when axes limits change.\n    \"\"\"\n\n    # Initialize render items\n    self._axes_segments_render_item: RenderItem | None = None\n    self._ticks_horizontal_render_item: RenderItem | None = None\n    self._ticks_vertical_render_item: RenderItem | None = None\n    self._texts_horizontal_render_item: RenderItem | None = None\n    self._texts_vertical_render_item: RenderItem | None = None\n\n    # Build render items\n    self._build_render_items()\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_display.AxesDisplay.get_inner_viewport","title":"<code>get_inner_viewport() -&gt; Viewport</code>","text":"<p>Get the inner viewport.</p> Source code in <code>src/vispy_2/axes/axes_display.py</code> <pre><code>def get_inner_viewport(self) -&gt; Viewport:\n    \"\"\"Get the inner viewport.\"\"\"\n    return self._inner_viewport\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_display.AxesDisplay.get_limits_dunit","title":"<code>get_limits_dunit() -&gt; tuple[float, float, float, float]</code>","text":"<p>Get the axes limits in data units.</p> Source code in <code>src/vispy_2/axes/axes_display.py</code> <pre><code>def get_limits_dunit(self) -&gt; tuple[float, float, float, float]:\n    \"\"\"Get the axes limits in data units.\"\"\"\n    return (self._x_min_dunit, self._x_max_dunit, self._y_min_dunit, self._y_max_dunit)\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_display.AxesDisplay.get_outter_viewport","title":"<code>get_outter_viewport() -&gt; Viewport</code>","text":"<p>Get the outter viewport.</p> Source code in <code>src/vispy_2/axes/axes_display.py</code> <pre><code>def get_outter_viewport(self) -&gt; Viewport:\n    \"\"\"Get the outter viewport.\"\"\"\n    return self._outter_viewport\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_display.AxesDisplay.get_render_items","title":"<code>get_render_items() -&gt; list[RenderItem]</code>","text":"<p>Get the render items for the axes display.</p> Source code in <code>src/vispy_2/axes/axes_display.py</code> <pre><code>def get_render_items(self) -&gt; list[RenderItem]:\n    \"\"\"Get the render items for the axes display.\"\"\"\n    # Collect all render items into a list\n    render_items: list[RenderItem] = []\n    if self._axes_segments_render_item is not None:\n        render_items.append(self._axes_segments_render_item)\n    if self._ticks_horizontal_render_item is not None:\n        render_items.append(self._ticks_horizontal_render_item)\n    if self._ticks_vertical_render_item is not None:\n        render_items.append(self._ticks_vertical_render_item)\n    if self._texts_horizontal_render_item is not None:\n        render_items.append(self._texts_horizontal_render_item)\n    if self._texts_vertical_render_item is not None:\n        render_items.append(self._texts_vertical_render_item)\n    # Retrun the render items\n    return render_items\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_display.AxesDisplay.get_transform_matrix_numpy","title":"<code>get_transform_matrix_numpy() -&gt; np.ndarray</code>","text":"<p>Get the transform matrix from data units to NDC units for the inner viewport.</p> Source code in <code>src/vispy_2/axes/axes_display.py</code> <pre><code>def get_transform_matrix_numpy(self) -&gt; np.ndarray:\n    \"\"\"Get the transform matrix from data units to NDC units for the inner viewport.\"\"\"\n    # Compute translation matrix\n    translation_matrix = glm.translate(np.array([-(self._x_max_dunit + self._x_min_dunit) / 2.0, -(self._y_max_dunit + self._y_min_dunit) / 2.0, 0.0]))\n    # Compute scale matrix\n    scale_matrix = glm.scale(np.array([2.0 / (self._x_max_dunit - self._x_min_dunit), 2.0 / (self._y_max_dunit - self._y_min_dunit), 1.0]))\n    # Combine translation and scale to get the final transform matrix\n    axes_transform_numpy = scale_matrix @ translation_matrix\n    # Return the transform matrix\n    return axes_transform_numpy\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_display.AxesDisplay.set_limits_dunit","title":"<code>set_limits_dunit(x_min_dunit: float, x_max_dunit: float, y_min_dunit: float, y_max_dunit: float) -&gt; None</code>","text":"<p>Set the axes limits in data units.</p> Source code in <code>src/vispy_2/axes/axes_display.py</code> <pre><code>def set_limits_dunit(self, x_min_dunit: float, x_max_dunit: float, y_min_dunit: float, y_max_dunit: float) -&gt; None:\n    \"\"\"Set the axes limits in data units.\"\"\"\n    # sanity checks\n    assert x_min_dunit &lt; x_max_dunit, f\"x_min MUST be less than x_max, got x_min_dunit={x_min_dunit}, x_max_dunit={x_max_dunit}\"\n    assert y_min_dunit &lt; y_max_dunit, f\"y_min MUST be less than y_max, got y_min_dunit={y_min_dunit}, y_max_dunit={y_max_dunit}\"\n\n    # set limits\n    self._x_min_dunit = x_min_dunit\n    self._x_max_dunit = x_max_dunit\n    self._y_min_dunit = y_min_dunit\n    self._y_max_dunit = y_max_dunit\n\n    # rebuild render items\n    self._build_render_items()\n\n    # Notify event listeners\n    self.new_limits_event.dispatch()\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_display.AxesDisplayNewLimitsEventCallback","title":"<code>AxesDisplayNewLimitsEventCallback</code>","text":"<p>               Bases: <code>typing.Protocol</code></p> <p>Protocol for axes display new limits event callback functions.</p> Source code in <code>src/vispy_2/axes/axes_display.py</code> <pre><code>class AxesDisplayNewLimitsEventCallback(Protocol):\n    \"\"\"Protocol for axes display new limits event callback functions.\"\"\"\n\n    def __call__(self) -&gt; None:\n        \"\"\"Handle a new limits event.\"\"\"\n        ...\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_display.AxesDisplayNewLimitsEventCallback.__call__","title":"<code>__call__() -&gt; None</code>","text":"<p>Handle a new limits event.</p> Source code in <code>src/vispy_2/axes/axes_display.py</code> <pre><code>def __call__(self) -&gt; None:\n    \"\"\"Handle a new limits event.\"\"\"\n    ...\n</code></pre>"},{"location":"api/vispy_2/#axes-pan-zoom","title":"Axes Pan Zoom","text":""},{"location":"api/vispy_2/#vispy_2.axes.axes_panzoom","title":"<code>vispy_2.axes.axes_panzoom</code>","text":"<p>Class AxesPanZoom to handle panning and zooming in a viewport.</p>"},{"location":"api/vispy_2/#vispy_2.axes.axes_panzoom.AxesPanZoom","title":"<code>AxesPanZoom</code>","text":"<p>Class to handle panning and zooming in a viewport.</p> Source code in <code>src/vispy_2/axes/axes_panzoom.py</code> <pre><code>class AxesPanZoom:\n    \"\"\"Class to handle panning and zooming in a viewport.\"\"\"\n\n    def __init__(self, viewport_events: ViewportEventsBase, base_scale: float, axes_display: AxesDisplay) -&gt; None:\n        \"\"\"Initialize the PanAndZoom example.\"\"\"\n        self._viewport_events = viewport_events\n        \"\"\"Viewport events to listen to.\"\"\"\n        self._base_scale = base_scale\n        \"\"\"Base scale for zooming.\"\"\"\n        self._axes_display = axes_display\n        \"\"\"Axes display to update.\"\"\"\n\n        # Store state for panning\n        self._button_press_x_ndc: float | None = None\n        \"\"\"X coordinate of the button press in NDC units.\"\"\"\n        self._button_press_y_ndc: float | None = None\n        \"\"\"Y coordinate of the button press in NDC units.\"\"\"\n\n        # Store initial limits for this axes\n        self._x_min_dunit: float | None = None\n        \"\"\"Current x minimum viewport in data units.\"\"\"\n        self._x_max_dunit: float | None = None\n        \"\"\"Current x maximum viewport in data units.\"\"\"\n        self._y_min_dunit: float | None = None\n        \"\"\"Current y minimum viewport in data units.\"\"\"\n        self._y_max_dunit: float | None = None\n        \"\"\"Current y maximum viewport in data units.\"\"\"\n\n        # Subscribe to viewport events\n        self._viewport_events.button_press_event.subscribe(self._on_button_press)\n        self._viewport_events.button_release_event.subscribe(self._on_button_release)\n        self._viewport_events.mouse_move_event.subscribe(self._on_button_move)\n        self._viewport_events.mouse_scroll_event.subscribe(self._on_mouse_scroll)\n\n        # Zoom range limit in data units\n        self._zoom_x_min_range_dunit: float | None = None\n        \"\"\"Minimum zoom range in data units for x axis.\"\"\"\n        self._zoom_y_min_range_dunit: float | None = None\n        \"\"\"Minimum zoom range in data units for y axis.\"\"\"\n        self._zoom_x_max_range_dunit: float | None = None\n        \"\"\"Maximum zoom range in data units for x axis.\"\"\"\n        self._zoom_y_max_range_dunit: float | None = None\n        \"\"\"Maximum zoom range in data units for y axis.\"\"\"\n\n        # Pan limits in data units\n        self._pan_x_min_dunit: float | None = None\n        \"\"\"Minimum pan limit in data units for x axis.\"\"\"\n        self._pan_x_max_dunit: float | None = None\n        \"\"\"Maximum pan limit in data units for x axis.\"\"\"\n        self._pan_y_min_dunit: float | None = None\n        \"\"\"Minimum pan limit in data units for y axis.\"\"\"\n        self._pan_y_max_dunit: float | None = None\n        \"\"\"Maximum pan limit in data units for y axis.\"\"\"\n\n    def close(self) -&gt; None:\n        \"\"\"Close the PanAndZoom example.\"\"\"\n        # Unsubscribe from viewport events\n        self._viewport_events.button_press_event.unsubscribe(self._on_button_press)\n        self._viewport_events.button_release_event.unsubscribe(self._on_button_release)\n        self._viewport_events.mouse_move_event.unsubscribe(self._on_button_move)\n        self._viewport_events.mouse_scroll_event.unsubscribe(self._on_mouse_scroll)\n\n    # =============================================================================\n    # Getters / setters for pan limit\n    # =============================================================================\n\n    def get_pan_limits_dunit(self) -&gt; tuple[float | None, float | None, float | None, float | None]:\n        \"\"\"Get the pan limits in data units.\n\n        Returns:\n            tuple[float | None, float | None, float | None, float | None]: Pan limits for x min, x max, y min, y max in data units.\n        \"\"\"\n        return self._pan_x_min_dunit, self._pan_x_max_dunit, self._pan_y_min_dunit, self._pan_y_max_dunit\n\n    def set_pan_limits_dunit(self, x_min_dunit: float | None, x_max_dunit: float | None, y_min_dunit: float | None, y_max_dunit: float | None) -&gt; None:\n        \"\"\"Set the pan limits in data units.\n\n        Args:\n            x_min_dunit (float | None): Minimum pan limit for x axis in data units. If None, no limit is applied.\n            x_max_dunit (float | None): Maximum pan limit for x axis in data units. If None, no limit is applied.\n            y_min_dunit (float | None): Minimum pan limit for y axis in data units. If None, no limit is applied.\n            y_max_dunit (float | None): Maximum pan limit for y axis in data units. If None, no limit is applied.\n        \"\"\"\n        self._pan_x_min_dunit = x_min_dunit\n        self._pan_x_max_dunit = x_max_dunit\n        self._pan_y_min_dunit = y_min_dunit\n        self._pan_y_max_dunit = y_max_dunit\n\n    # =============================================================================\n    # getters / setters zoom range limit\n    # =============================================================================\n\n    def get_zoom_range_limits_dunit(self) -&gt; tuple[float | None, float | None, float | None, float | None]:\n        \"\"\"Get the zoom range limits in data units.\n\n        Returns:\n            tuple[float | None, float | None, float | None, float | None]: Min and max zoom range for x and y axes in data units.\n        \"\"\"\n        return (self._zoom_x_min_range_dunit, self._zoom_x_max_range_dunit, self._zoom_y_min_range_dunit, self._zoom_y_max_range_dunit)\n\n    def set_zoom_range_limits_dunit(\n        self, x_min_range_dunit: float | None, x_max_range_dunit: float | None, y_min_range_dunit: float | None, y_max_range_dunit: float | None\n    ) -&gt; None:\n        \"\"\"Set the zoom range limits in data units.\n\n        Args:\n            x_min_range_dunit (float | None): Minimum zoom range for x axis in data units. If None, no limit is applied.\n            x_max_range_dunit (float | None): Maximum zoom range for x axis in data units. If None, no limit is applied.\n            y_min_range_dunit (float | None): Minimum zoom range for y axis in data units. If None, no limit is applied.\n            y_max_range_dunit (float | None): Maximum zoom range for y axis in data units. If None, no limit is applied.\n        \"\"\"\n        self._zoom_x_min_range_dunit = x_min_range_dunit\n        self._zoom_x_max_range_dunit = x_max_range_dunit\n        self._zoom_y_min_range_dunit = y_min_range_dunit\n        self._zoom_y_max_range_dunit = y_max_range_dunit\n\n    # =============================================================================\n    #\n    # =============================================================================\n    def _on_button_press(self, mouse_event: MouseEvent):\n        # Store pixel coordinates instead of data coordinates\n        self._button_press_x_ndc = mouse_event.x_ndc\n        self._button_press_y_ndc = mouse_event.y_ndc\n\n        self._x_min_dunit, self._x_max_dunit, self._y_min_dunit, self._y_max_dunit = self._axes_display.get_limits_dunit()\n\n    def _on_button_release(self, mouse_event: MouseEvent):\n        self._button_press_x_ndc = None\n        self._button_press_y_ndc = None\n        self._x_min_dunit = None\n        self._x_max_dunit = None\n        self._y_min_dunit = None\n        self._y_max_dunit = None\n\n    def _on_button_move(self, mouse_event: MouseEvent):\n        # sanity check\n        if self._button_press_x_ndc is None or self._button_press_y_ndc is None:\n            return\n        if self._x_min_dunit is None or self._x_max_dunit is None or self._y_min_dunit is None or self._y_max_dunit is None:\n            return\n\n        # Calculate the delta in NDC units\n        delta_x_ndc: float = mouse_event.x_ndc - self._button_press_x_ndc\n        delta_y_ndc: float = mouse_event.y_ndc - self._button_press_y_ndc\n\n        # Compute new limits in data space for the viewports\n        new_x_min_dunit: float = self._x_min_dunit - (delta_x_ndc / 2.0) * (self._x_max_dunit - self._x_min_dunit)\n        new_x_max_dunit: float = self._x_max_dunit - (delta_x_ndc / 2.0) * (self._x_max_dunit - self._x_min_dunit)\n        new_y_min_dunit: float = self._y_min_dunit - (delta_y_ndc / 2.0) * (self._y_max_dunit - self._y_min_dunit)\n        new_y_max_dunit: float = self._y_max_dunit - (delta_y_ndc / 2.0) * (self._y_max_dunit - self._y_min_dunit)\n\n        # =============================================================================\n        # Update the axes limits in data unit\n        # =============================================================================\n        self._set_axes_limits_dunit(new_x_min_dunit, new_x_max_dunit, new_y_min_dunit, new_y_max_dunit)\n\n    def _on_mouse_scroll(self, mouse_event: MouseEvent):\n        scale_factor: float = 1 / self._base_scale if mouse_event.scroll_steps &gt;= 0 else self._base_scale\n\n        # Get current limits in data unit\n        x_min_dunit, x_max_dunit, y_min_dunit, y_max_dunit = self._axes_display.get_limits_dunit()\n\n        # print(f\"scale_factor: {scale_factor}\")\n\n        # Calculate mouse position in data units\n        mouse_x_dunit: float = x_min_dunit + (mouse_event.x_ndc + 1.0) / 2.0 * (x_max_dunit - x_min_dunit)\n        mouse_y_dunit: float = y_min_dunit + (mouse_event.y_ndc + 1.0) / 2.0 * (y_max_dunit - y_min_dunit)\n\n        # Calculate new limits in data units, keeping the mouse position fixed\n        new_width_dunit: float = (x_max_dunit - x_min_dunit) * scale_factor\n        new_height_dunit: float = (y_max_dunit - y_min_dunit) * scale_factor\n        relative_x: float = (x_max_dunit - mouse_x_dunit) / (x_max_dunit - x_min_dunit)\n        relative_y: float = (y_max_dunit - mouse_y_dunit) / (y_max_dunit - y_min_dunit)\n\n        # Compute new limits in data units\n        new_x_min_dunit: float = mouse_x_dunit - new_width_dunit * (1 - relative_x)\n        new_x_max_dunit: float = mouse_x_dunit + new_width_dunit * (relative_x)\n        new_y_min_dunit: float = mouse_y_dunit - new_height_dunit * (1 - relative_y)\n        new_y_max_dunit: float = mouse_y_dunit + new_height_dunit * (relative_y)\n\n        # =============================================================================\n        # Update the axes limits in data unit\n        # =============================================================================\n\n        self._set_axes_limits_dunit(new_x_min_dunit, new_x_max_dunit, new_y_min_dunit, new_y_max_dunit)\n\n    # =============================================================================\n    #\n    # =============================================================================\n    def _set_axes_limits_dunit(self, x_min_dunit: float, x_max_dunit: float, y_min_dunit: float, y_max_dunit: float) -&gt; None:\n        \"\"\"Set the axes limits in data units. Applies pan and zoom limits if set.\n\n        Args:\n            x_min_dunit (float): Minimum x limit in data units.\n            x_max_dunit (float): Maximum x limit in data units.\n            y_min_dunit (float): Minimum y limit in data units.\n            y_max_dunit (float): Maximum y limit in data units.\n        \"\"\"\n        # =============================================================================\n        # Enforce pan limit\n        # =============================================================================\n        if self._pan_x_min_dunit is not None:\n            if x_min_dunit &lt; self._pan_x_min_dunit:\n                shift_dunit: float = self._pan_x_min_dunit - x_min_dunit\n                x_min_dunit += shift_dunit\n                x_max_dunit += shift_dunit\n        if self._pan_x_max_dunit is not None:\n            if x_max_dunit &gt; self._pan_x_max_dunit:\n                shift_dunit: float = x_max_dunit - self._pan_x_max_dunit\n                x_min_dunit -= shift_dunit\n                x_max_dunit -= shift_dunit\n        if self._pan_y_min_dunit is not None:\n            if y_min_dunit &lt; self._pan_y_min_dunit:\n                shift_dunit: float = self._pan_y_min_dunit - y_min_dunit\n                y_min_dunit += shift_dunit\n                y_max_dunit += shift_dunit\n        if self._pan_y_max_dunit is not None:\n            if y_max_dunit &gt; self._pan_y_max_dunit:\n                shift_dunit: float = y_max_dunit - self._pan_y_max_dunit\n                y_min_dunit -= shift_dunit\n                y_max_dunit -= shift_dunit\n\n        # =============================================================================\n        # Enforce min/max zoom range for x/y\n        # =============================================================================\n\n        # Enforce minimum zoom range if set for x\n        if self._zoom_x_min_range_dunit is not None:\n            zoom_x_range_dunit: float = x_max_dunit - x_min_dunit\n            if zoom_x_range_dunit &lt; self._zoom_x_min_range_dunit:\n                # Clamp the zoom range\n                center_x_dunit: float = (x_min_dunit + x_max_dunit) / 2.0\n                x_min_dunit = center_x_dunit - self._zoom_x_min_range_dunit / 2.0\n                x_max_dunit = center_x_dunit + self._zoom_x_min_range_dunit / 2.0\n        # Enforce minimum zoom range if set for y\n        if self._zoom_y_min_range_dunit is not None:\n            zoom_y_range_dunit: float = y_max_dunit - y_min_dunit\n            if zoom_y_range_dunit &lt; self._zoom_y_min_range_dunit:\n                # Clamp the zoom range\n                center_y_dunit: float = (y_min_dunit + y_max_dunit) / 2.0\n                y_min_dunit = center_y_dunit - self._zoom_y_min_range_dunit / 2.0\n                y_max_dunit = center_y_dunit + self._zoom_y_min_range_dunit / 2.0\n        # Enforce maximum zoom range if set for x\n        if self._zoom_x_max_range_dunit is not None:\n            zoom_x_range_dunit: float = x_max_dunit - x_min_dunit\n            if zoom_x_range_dunit &gt; self._zoom_x_max_range_dunit:\n                # Clamp the zoom range\n                center_x_dunit: float = (x_min_dunit + x_max_dunit) / 2.0\n                x_min_dunit = center_x_dunit - self._zoom_x_max_range_dunit / 2.0\n                x_max_dunit = center_x_dunit + self._zoom_x_max_range_dunit / 2.0\n        # Enforce maximum zoom range if set for y\n        if self._zoom_y_max_range_dunit is not None:\n            zoom_y_range_dunit: float = y_max_dunit - y_min_dunit\n            if zoom_y_range_dunit &gt; self._zoom_y_max_range_dunit:\n                # Clamp the zoom range\n                center_y_dunit: float = (y_min_dunit + y_max_dunit) / 2.0\n                y_min_dunit = center_y_dunit - self._zoom_y_max_range_dunit / 2.0\n                y_max_dunit = center_y_dunit + self._zoom_y_max_range_dunit / 2.0\n\n        # Finally set the new limits\n        self._axes_display.set_limits_dunit(x_min_dunit, x_max_dunit, y_min_dunit, y_max_dunit)\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_panzoom.AxesPanZoom.__init__","title":"<code>__init__(viewport_events: ViewportEventsBase, base_scale: float, axes_display: AxesDisplay) -&gt; None</code>","text":"<p>Initialize the PanAndZoom example.</p> Source code in <code>src/vispy_2/axes/axes_panzoom.py</code> <pre><code>def __init__(self, viewport_events: ViewportEventsBase, base_scale: float, axes_display: AxesDisplay) -&gt; None:\n    \"\"\"Initialize the PanAndZoom example.\"\"\"\n    self._viewport_events = viewport_events\n    \"\"\"Viewport events to listen to.\"\"\"\n    self._base_scale = base_scale\n    \"\"\"Base scale for zooming.\"\"\"\n    self._axes_display = axes_display\n    \"\"\"Axes display to update.\"\"\"\n\n    # Store state for panning\n    self._button_press_x_ndc: float | None = None\n    \"\"\"X coordinate of the button press in NDC units.\"\"\"\n    self._button_press_y_ndc: float | None = None\n    \"\"\"Y coordinate of the button press in NDC units.\"\"\"\n\n    # Store initial limits for this axes\n    self._x_min_dunit: float | None = None\n    \"\"\"Current x minimum viewport in data units.\"\"\"\n    self._x_max_dunit: float | None = None\n    \"\"\"Current x maximum viewport in data units.\"\"\"\n    self._y_min_dunit: float | None = None\n    \"\"\"Current y minimum viewport in data units.\"\"\"\n    self._y_max_dunit: float | None = None\n    \"\"\"Current y maximum viewport in data units.\"\"\"\n\n    # Subscribe to viewport events\n    self._viewport_events.button_press_event.subscribe(self._on_button_press)\n    self._viewport_events.button_release_event.subscribe(self._on_button_release)\n    self._viewport_events.mouse_move_event.subscribe(self._on_button_move)\n    self._viewport_events.mouse_scroll_event.subscribe(self._on_mouse_scroll)\n\n    # Zoom range limit in data units\n    self._zoom_x_min_range_dunit: float | None = None\n    \"\"\"Minimum zoom range in data units for x axis.\"\"\"\n    self._zoom_y_min_range_dunit: float | None = None\n    \"\"\"Minimum zoom range in data units for y axis.\"\"\"\n    self._zoom_x_max_range_dunit: float | None = None\n    \"\"\"Maximum zoom range in data units for x axis.\"\"\"\n    self._zoom_y_max_range_dunit: float | None = None\n    \"\"\"Maximum zoom range in data units for y axis.\"\"\"\n\n    # Pan limits in data units\n    self._pan_x_min_dunit: float | None = None\n    \"\"\"Minimum pan limit in data units for x axis.\"\"\"\n    self._pan_x_max_dunit: float | None = None\n    \"\"\"Maximum pan limit in data units for x axis.\"\"\"\n    self._pan_y_min_dunit: float | None = None\n    \"\"\"Minimum pan limit in data units for y axis.\"\"\"\n    self._pan_y_max_dunit: float | None = None\n    \"\"\"Maximum pan limit in data units for y axis.\"\"\"\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_panzoom.AxesPanZoom.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the PanAndZoom example.</p> Source code in <code>src/vispy_2/axes/axes_panzoom.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the PanAndZoom example.\"\"\"\n    # Unsubscribe from viewport events\n    self._viewport_events.button_press_event.unsubscribe(self._on_button_press)\n    self._viewport_events.button_release_event.unsubscribe(self._on_button_release)\n    self._viewport_events.mouse_move_event.unsubscribe(self._on_button_move)\n    self._viewport_events.mouse_scroll_event.unsubscribe(self._on_mouse_scroll)\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_panzoom.AxesPanZoom.get_pan_limits_dunit","title":"<code>get_pan_limits_dunit() -&gt; tuple[float | None, float | None, float | None, float | None]</code>","text":"<p>Get the pan limits in data units.</p> <p>Returns:</p> Type Description <code>tuple[float | None, float | None, float | None, float | None]</code> <p>tuple[float | None, float | None, float | None, float | None]: Pan limits for x min, x max, y min, y max in data units.</p> Source code in <code>src/vispy_2/axes/axes_panzoom.py</code> <pre><code>def get_pan_limits_dunit(self) -&gt; tuple[float | None, float | None, float | None, float | None]:\n    \"\"\"Get the pan limits in data units.\n\n    Returns:\n        tuple[float | None, float | None, float | None, float | None]: Pan limits for x min, x max, y min, y max in data units.\n    \"\"\"\n    return self._pan_x_min_dunit, self._pan_x_max_dunit, self._pan_y_min_dunit, self._pan_y_max_dunit\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_panzoom.AxesPanZoom.get_zoom_range_limits_dunit","title":"<code>get_zoom_range_limits_dunit() -&gt; tuple[float | None, float | None, float | None, float | None]</code>","text":"<p>Get the zoom range limits in data units.</p> <p>Returns:</p> Type Description <code>tuple[float | None, float | None, float | None, float | None]</code> <p>tuple[float | None, float | None, float | None, float | None]: Min and max zoom range for x and y axes in data units.</p> Source code in <code>src/vispy_2/axes/axes_panzoom.py</code> <pre><code>def get_zoom_range_limits_dunit(self) -&gt; tuple[float | None, float | None, float | None, float | None]:\n    \"\"\"Get the zoom range limits in data units.\n\n    Returns:\n        tuple[float | None, float | None, float | None, float | None]: Min and max zoom range for x and y axes in data units.\n    \"\"\"\n    return (self._zoom_x_min_range_dunit, self._zoom_x_max_range_dunit, self._zoom_y_min_range_dunit, self._zoom_y_max_range_dunit)\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_panzoom.AxesPanZoom.set_pan_limits_dunit","title":"<code>set_pan_limits_dunit(x_min_dunit: float | None, x_max_dunit: float | None, y_min_dunit: float | None, y_max_dunit: float | None) -&gt; None</code>","text":"<p>Set the pan limits in data units.</p> <p>Parameters:</p> Name Type Description Default <code>x_min_dunit</code> <code>float | None</code> <p>Minimum pan limit for x axis in data units. If None, no limit is applied.</p> required <code>x_max_dunit</code> <code>float | None</code> <p>Maximum pan limit for x axis in data units. If None, no limit is applied.</p> required <code>y_min_dunit</code> <code>float | None</code> <p>Minimum pan limit for y axis in data units. If None, no limit is applied.</p> required <code>y_max_dunit</code> <code>float | None</code> <p>Maximum pan limit for y axis in data units. If None, no limit is applied.</p> required Source code in <code>src/vispy_2/axes/axes_panzoom.py</code> <pre><code>def set_pan_limits_dunit(self, x_min_dunit: float | None, x_max_dunit: float | None, y_min_dunit: float | None, y_max_dunit: float | None) -&gt; None:\n    \"\"\"Set the pan limits in data units.\n\n    Args:\n        x_min_dunit (float | None): Minimum pan limit for x axis in data units. If None, no limit is applied.\n        x_max_dunit (float | None): Maximum pan limit for x axis in data units. If None, no limit is applied.\n        y_min_dunit (float | None): Minimum pan limit for y axis in data units. If None, no limit is applied.\n        y_max_dunit (float | None): Maximum pan limit for y axis in data units. If None, no limit is applied.\n    \"\"\"\n    self._pan_x_min_dunit = x_min_dunit\n    self._pan_x_max_dunit = x_max_dunit\n    self._pan_y_min_dunit = y_min_dunit\n    self._pan_y_max_dunit = y_max_dunit\n</code></pre>"},{"location":"api/vispy_2/#vispy_2.axes.axes_panzoom.AxesPanZoom.set_zoom_range_limits_dunit","title":"<code>set_zoom_range_limits_dunit(x_min_range_dunit: float | None, x_max_range_dunit: float | None, y_min_range_dunit: float | None, y_max_range_dunit: float | None) -&gt; None</code>","text":"<p>Set the zoom range limits in data units.</p> <p>Parameters:</p> Name Type Description Default <code>x_min_range_dunit</code> <code>float | None</code> <p>Minimum zoom range for x axis in data units. If None, no limit is applied.</p> required <code>x_max_range_dunit</code> <code>float | None</code> <p>Maximum zoom range for x axis in data units. If None, no limit is applied.</p> required <code>y_min_range_dunit</code> <code>float | None</code> <p>Minimum zoom range for y axis in data units. If None, no limit is applied.</p> required <code>y_max_range_dunit</code> <code>float | None</code> <p>Maximum zoom range for y axis in data units. If None, no limit is applied.</p> required Source code in <code>src/vispy_2/axes/axes_panzoom.py</code> <pre><code>def set_zoom_range_limits_dunit(\n    self, x_min_range_dunit: float | None, x_max_range_dunit: float | None, y_min_range_dunit: float | None, y_max_range_dunit: float | None\n) -&gt; None:\n    \"\"\"Set the zoom range limits in data units.\n\n    Args:\n        x_min_range_dunit (float | None): Minimum zoom range for x axis in data units. If None, no limit is applied.\n        x_max_range_dunit (float | None): Maximum zoom range for x axis in data units. If None, no limit is applied.\n        y_min_range_dunit (float | None): Minimum zoom range for y axis in data units. If None, no limit is applied.\n        y_max_range_dunit (float | None): Maximum zoom range for y axis in data units. If None, no limit is applied.\n    \"\"\"\n    self._zoom_x_min_range_dunit = x_min_range_dunit\n    self._zoom_x_max_range_dunit = x_max_range_dunit\n    self._zoom_y_min_range_dunit = y_min_range_dunit\n    self._zoom_y_max_range_dunit = y_max_range_dunit\n</code></pre>"}]}
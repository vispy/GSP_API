{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"GSP Documentation","text":"<p>This is your documentation homepage.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#overview","title":"Overview","text":"<p>This page provides information about the project.</p>"},{"location":"about/#description","title":"Description","text":"<p>Add your description here.</p>"},{"location":"about/#contact","title":"Contact","text":"<p>For questions or support, please contact us.</p>"},{"location":"api/gsp/","title":"GSP API Reference","text":"<p>The Graphic Server Protocol (GSP) API provides a unified interface for creating and rendering graphics across different backends.</p>"},{"location":"api/gsp/#core-module","title":"Core Module","text":""},{"location":"api/gsp/#gsp.core.canvas","title":"<code>gsp.core.canvas</code>","text":"<p>Canvas module for the GSP library.</p>"},{"location":"api/gsp/#gsp.core.canvas.Canvas","title":"<code>Canvas</code>","text":"<p>Canvas class representing a drawing surface with specific dimensions and DPI.</p> Source code in <code>src/gsp/core/canvas.py</code> <pre><code>class Canvas:\n    \"\"\"Canvas class representing a drawing surface with specific dimensions and DPI.\"\"\"\n\n    __slots__ = [\"_uuid\", \"_width\", \"_height\", \"_dpi\", \"userData\"]\n\n    def __init__(self, width: int, height: int, dpi: float):\n        \"\"\"Create a new Canvas object with the given width, height, and dpi.\n\n        Args:\n            width (int): Width of the canvas in pixels.\n            height (int): Height of the canvas in pixels.\n            dpi (float): Dots per inch (DPI) of the canvas. If set to the screen PPI, the 'inch' unit in will correspond to one physical inch on the screen.\n        \"\"\"\n        self._uuid: str = UuidUtils.generate_uuid()\n        self._width: int = width\n        self._height: int = height\n        self._dpi: float = dpi\n        self.userData: dict[str, Any] = {}\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return string representation of the Canvas instance.\"\"\"\n        return f\"Canvas(width={self._width}, height={self._height}, dpi={self._dpi})\"\n\n    def get_uuid(self) -&gt; str:\n        \"\"\"Get the UUID of the Canvas instance.\n\n        Returns:\n            str: The UUID of the Canvas.\n        \"\"\"\n        return self._uuid\n\n    def get_width(self) -&gt; int:\n        \"\"\"Get the width of the canvas in pixels.\"\"\"\n        return self._width\n\n    def set_width(self, width: int) -&gt; None:\n        \"\"\"Set the width of the canvas in pixels.\n\n        Args:\n            width (int): The new width in pixels.\n        \"\"\"\n        self._width = width\n\n    def get_height(self) -&gt; int:\n        \"\"\"Get the height of the canvas in pixels.\"\"\"\n        return self._height\n\n    def set_height(self, height: int) -&gt; None:\n        \"\"\"Set the height of the canvas in pixels.\n\n        Args:\n            height (int): The new height in pixels.\n        \"\"\"\n        self._height = height\n\n    def get_dpi(self) -&gt; float:\n        \"\"\"Get the DPI of the canvas.\"\"\"\n        return self._dpi\n\n    def set_dpi(self, dpi: float) -&gt; None:\n        \"\"\"Set the DPI of the canvas.\n\n        Args:\n            dpi (float): The new DPI value.\n        \"\"\"\n        self._dpi = dpi\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.__init__","title":"<code>__init__(width: int, height: int, dpi: float)</code>","text":"<p>Create a new Canvas object with the given width, height, and dpi.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the canvas in pixels.</p> required <code>height</code> <code>int</code> <p>Height of the canvas in pixels.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch (DPI) of the canvas. If set to the screen PPI, the 'inch' unit in will correspond to one physical inch on the screen.</p> required Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def __init__(self, width: int, height: int, dpi: float):\n    \"\"\"Create a new Canvas object with the given width, height, and dpi.\n\n    Args:\n        width (int): Width of the canvas in pixels.\n        height (int): Height of the canvas in pixels.\n        dpi (float): Dots per inch (DPI) of the canvas. If set to the screen PPI, the 'inch' unit in will correspond to one physical inch on the screen.\n    \"\"\"\n    self._uuid: str = UuidUtils.generate_uuid()\n    self._width: int = width\n    self._height: int = height\n    self._dpi: float = dpi\n    self.userData: dict[str, Any] = {}\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return string representation of the Canvas instance.</p> Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return string representation of the Canvas instance.\"\"\"\n    return f\"Canvas(width={self._width}, height={self._height}, dpi={self._dpi})\"\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.get_dpi","title":"<code>get_dpi() -&gt; float</code>","text":"<p>Get the DPI of the canvas.</p> Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def get_dpi(self) -&gt; float:\n    \"\"\"Get the DPI of the canvas.\"\"\"\n    return self._dpi\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.get_height","title":"<code>get_height() -&gt; int</code>","text":"<p>Get the height of the canvas in pixels.</p> Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def get_height(self) -&gt; int:\n    \"\"\"Get the height of the canvas in pixels.\"\"\"\n    return self._height\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.get_uuid","title":"<code>get_uuid() -&gt; str</code>","text":"<p>Get the UUID of the Canvas instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The UUID of the Canvas.</p> Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def get_uuid(self) -&gt; str:\n    \"\"\"Get the UUID of the Canvas instance.\n\n    Returns:\n        str: The UUID of the Canvas.\n    \"\"\"\n    return self._uuid\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.get_width","title":"<code>get_width() -&gt; int</code>","text":"<p>Get the width of the canvas in pixels.</p> Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def get_width(self) -&gt; int:\n    \"\"\"Get the width of the canvas in pixels.\"\"\"\n    return self._width\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.set_dpi","title":"<code>set_dpi(dpi: float) -&gt; None</code>","text":"<p>Set the DPI of the canvas.</p> <p>Parameters:</p> Name Type Description Default <code>dpi</code> <code>float</code> <p>The new DPI value.</p> required Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def set_dpi(self, dpi: float) -&gt; None:\n    \"\"\"Set the DPI of the canvas.\n\n    Args:\n        dpi (float): The new DPI value.\n    \"\"\"\n    self._dpi = dpi\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.set_height","title":"<code>set_height(height: int) -&gt; None</code>","text":"<p>Set the height of the canvas in pixels.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>The new height in pixels.</p> required Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def set_height(self, height: int) -&gt; None:\n    \"\"\"Set the height of the canvas in pixels.\n\n    Args:\n        height (int): The new height in pixels.\n    \"\"\"\n    self._height = height\n</code></pre>"},{"location":"api/gsp/#gsp.core.canvas.Canvas.set_width","title":"<code>set_width(width: int) -&gt; None</code>","text":"<p>Set the width of the canvas in pixels.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The new width in pixels.</p> required Source code in <code>src/gsp/core/canvas.py</code> <pre><code>def set_width(self, width: int) -&gt; None:\n    \"\"\"Set the width of the canvas in pixels.\n\n    Args:\n        width (int): The new width in pixels.\n    \"\"\"\n    self._width = width\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport","title":"<code>gsp.core.viewport</code>","text":"<p>Viewport class representing a rectangular area on the canvas.</p>"},{"location":"api/gsp/#gsp.core.viewport.Viewport","title":"<code>Viewport</code>","text":"<p>Viewport class representing a rectangular area on the canvas.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>class Viewport:\n    \"\"\"Viewport class representing a rectangular area on the canvas.\"\"\"\n\n    __slots__ = [\"_uuid\", \"_x\", \"_y\", \"_width\", \"_height\", \"userData\"]\n\n    def __init__(self, x: int, y: int, width: int, height: int):\n        \"\"\"Create a viewport.\n\n        Args:\n            x (int): The x offset (in pixels from left) of the viewport.\n            y (int): The y offset (in pixels from bottom) of the viewport.\n            width (int): The width (in pixels) of the viewport.\n            height (int): The height (in pixels) of the viewport.\n        \"\"\"\n        self._uuid: str = UuidUtils.generate_uuid()\n        self._x: int = x\n        self._y: int = y\n        self._width: int = width\n        self._height: int = height\n        self.userData: dict[str, Any] = {}\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return string representation of the Viewport instance.\"\"\"\n        return f\"Viewport(x={self._x}, y={self._y}, width={self._width}, height={self._height})\"\n\n    def get_uuid(self) -&gt; str:\n        \"\"\"Get the unique identifier of the viewport.\n\n        Returns:\n            str: The unique identifier.\n        \"\"\"\n        return self._uuid\n\n    def get_x(self) -&gt; int:\n        \"\"\"Get the x offset (in pixels from left) of the viewport.\n\n        Returns:\n            int: The x offset.\n        \"\"\"\n        return self._x\n\n    def set_x(self, x: int) -&gt; None:\n        \"\"\"Set the x offset (in pixels from left) of the viewport.\n\n        Args:\n            x (int): The new x offset.\n        \"\"\"\n        self._x = x\n\n    def get_y(self) -&gt; int:\n        \"\"\"Get the y offset (in pixels from bottom) of the viewport.\n\n        Returns:\n            int: The y offset.\n        \"\"\"\n        return self._y\n\n    def set_y(self, y: int) -&gt; None:\n        \"\"\"Set the y offset (in pixels from bottom) of the viewport.\n\n        Args:\n            y (int): The new y offset.\n        \"\"\"\n        self._y = y\n\n    def get_width(self) -&gt; int:\n        \"\"\"Get the width (in pixels) of the viewport.\n\n        Returns:\n            int: The width.\n        \"\"\"\n        return self._width\n\n    def set_width(self, width: int) -&gt; None:\n        \"\"\"Set the width (in pixels) of the viewport.\n\n        Args:\n            width (int): The new width.\n        \"\"\"\n        self._width = width\n\n    def get_height(self) -&gt; int:\n        \"\"\"Get the height (in pixels) of the viewport.\n\n        Returns:\n            int: The height.\n        \"\"\"\n        return self._height\n\n    def set_height(self, height: int) -&gt; None:\n        \"\"\"Set the height (in pixels) of the viewport.\n\n        Args:\n            height (int): The new height.\n        \"\"\"\n        self._height = height\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.__init__","title":"<code>__init__(x: int, y: int, width: int, height: int)</code>","text":"<p>Create a viewport.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The x offset (in pixels from left) of the viewport.</p> required <code>y</code> <code>int</code> <p>The y offset (in pixels from bottom) of the viewport.</p> required <code>width</code> <code>int</code> <p>The width (in pixels) of the viewport.</p> required <code>height</code> <code>int</code> <p>The height (in pixels) of the viewport.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def __init__(self, x: int, y: int, width: int, height: int):\n    \"\"\"Create a viewport.\n\n    Args:\n        x (int): The x offset (in pixels from left) of the viewport.\n        y (int): The y offset (in pixels from bottom) of the viewport.\n        width (int): The width (in pixels) of the viewport.\n        height (int): The height (in pixels) of the viewport.\n    \"\"\"\n    self._uuid: str = UuidUtils.generate_uuid()\n    self._x: int = x\n    self._y: int = y\n    self._width: int = width\n    self._height: int = height\n    self.userData: dict[str, Any] = {}\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return string representation of the Viewport instance.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return string representation of the Viewport instance.\"\"\"\n    return f\"Viewport(x={self._x}, y={self._y}, width={self._width}, height={self._height})\"\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_height","title":"<code>get_height() -&gt; int</code>","text":"<p>Get the height (in pixels) of the viewport.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The height.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_height(self) -&gt; int:\n    \"\"\"Get the height (in pixels) of the viewport.\n\n    Returns:\n        int: The height.\n    \"\"\"\n    return self._height\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_uuid","title":"<code>get_uuid() -&gt; str</code>","text":"<p>Get the unique identifier of the viewport.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_uuid(self) -&gt; str:\n    \"\"\"Get the unique identifier of the viewport.\n\n    Returns:\n        str: The unique identifier.\n    \"\"\"\n    return self._uuid\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_width","title":"<code>get_width() -&gt; int</code>","text":"<p>Get the width (in pixels) of the viewport.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The width.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_width(self) -&gt; int:\n    \"\"\"Get the width (in pixels) of the viewport.\n\n    Returns:\n        int: The width.\n    \"\"\"\n    return self._width\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_x","title":"<code>get_x() -&gt; int</code>","text":"<p>Get the x offset (in pixels from left) of the viewport.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The x offset.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_x(self) -&gt; int:\n    \"\"\"Get the x offset (in pixels from left) of the viewport.\n\n    Returns:\n        int: The x offset.\n    \"\"\"\n    return self._x\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.get_y","title":"<code>get_y() -&gt; int</code>","text":"<p>Get the y offset (in pixels from bottom) of the viewport.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The y offset.</p> Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def get_y(self) -&gt; int:\n    \"\"\"Get the y offset (in pixels from bottom) of the viewport.\n\n    Returns:\n        int: The y offset.\n    \"\"\"\n    return self._y\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.set_height","title":"<code>set_height(height: int) -&gt; None</code>","text":"<p>Set the height (in pixels) of the viewport.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>The new height.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def set_height(self, height: int) -&gt; None:\n    \"\"\"Set the height (in pixels) of the viewport.\n\n    Args:\n        height (int): The new height.\n    \"\"\"\n    self._height = height\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.set_width","title":"<code>set_width(width: int) -&gt; None</code>","text":"<p>Set the width (in pixels) of the viewport.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The new width.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def set_width(self, width: int) -&gt; None:\n    \"\"\"Set the width (in pixels) of the viewport.\n\n    Args:\n        width (int): The new width.\n    \"\"\"\n    self._width = width\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.set_x","title":"<code>set_x(x: int) -&gt; None</code>","text":"<p>Set the x offset (in pixels from left) of the viewport.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The new x offset.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def set_x(self, x: int) -&gt; None:\n    \"\"\"Set the x offset (in pixels from left) of the viewport.\n\n    Args:\n        x (int): The new x offset.\n    \"\"\"\n    self._x = x\n</code></pre>"},{"location":"api/gsp/#gsp.core.viewport.Viewport.set_y","title":"<code>set_y(y: int) -&gt; None</code>","text":"<p>Set the y offset (in pixels from bottom) of the viewport.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>int</code> <p>The new y offset.</p> required Source code in <code>src/gsp/core/viewport.py</code> <pre><code>def set_y(self, y: int) -&gt; None:\n    \"\"\"Set the y offset (in pixels from bottom) of the viewport.\n\n    Args:\n        y (int): The new y offset.\n    \"\"\"\n    self._y = y\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera","title":"<code>gsp.core.camera</code>","text":"<p>Camera module for the GSP library.</p>"},{"location":"api/gsp/#gsp.core.camera.Camera","title":"<code>Camera</code>","text":"<p>Camera class representing a view and projection matrix for 3D rendering.</p> Source code in <code>src/gsp/core/camera.py</code> <pre><code>class Camera:\n    \"\"\"Camera class representing a view and projection matrix for 3D rendering.\"\"\"\n    __slots__ = [\"_uuid\", \"_view_matrix\", \"_projection_matrix\", \"userData\"]\n\n    def __init__(self, view_matrix: TransBuf, projection_matrix: TransBuf):\n        \"\"\"Initialize a Camera instance. Just a container for view and projection matrices.\n\n        Args:\n            view_matrix (TransBuf): View matrix - [view-matrix](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-view-matrix)\n            projection_matrix (TransBuf): Projection matrix - [projection-matrix](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-projection-matrix)\n        \"\"\"\n        self._uuid: str = UuidUtils.generate_uuid()\n        self._view_matrix: TransBuf = view_matrix\n        self._projection_matrix: TransBuf = projection_matrix\n        self.userData: dict[str, Any] = {}\n        \"\"\"A dictionary for storing custom user data associated with the Camera instance.\"\"\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return string representation of the Camera instance.\"\"\"\n        return f\"Camera(uuid={self._uuid})\"\n\n    def get_uuid(self) -&gt; str:\n        \"\"\"Get the UUID of the Camera instance.\n\n        Returns:\n            str: The UUID of the Camera.\n        \"\"\"\n        return self._uuid\n\n    def set_view_matrix(self, view_matrix: TransBuf):\n        \"\"\"Set the view matrix of the Camera.\n\n        Args:\n            view_matrix (TransBuf): The new view matrix.\n        \"\"\"\n        self._view_matrix = view_matrix\n\n    def get_view_matrix(self) -&gt; TransBuf:\n        \"\"\"Get the view matrix of the Camera.\n\n        Returns:\n            TransBuf: The view matrix.\n        \"\"\"\n        return self._view_matrix\n\n    def set_projection_matrix(self, projection_matrix: TransBuf):\n        \"\"\"Set the projection matrix of the Camera.\n\n        Args:\n            projection_matrix (TransBuf): The new projection matrix.\n        \"\"\"\n        self._projection_matrix = projection_matrix\n\n    def get_projection_matrix(self) -&gt; TransBuf:\n        \"\"\"Get the projection matrix of the Camera.\n\n        Returns:\n            TransBuf: The projection matrix.\n        \"\"\"\n        return self._projection_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.userData","title":"<code>userData: dict[str, Any] = {}</code>  <code>instance-attribute</code>","text":"<p>A dictionary for storing custom user data associated with the Camera instance.</p>"},{"location":"api/gsp/#gsp.core.camera.Camera.__init__","title":"<code>__init__(view_matrix: TransBuf, projection_matrix: TransBuf)</code>","text":"<p>Initialize a Camera instance. Just a container for view and projection matrices.</p> <p>Parameters:</p> Name Type Description Default <code>view_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>View matrix - view-matrix</p> required <code>projection_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>Projection matrix - projection-matrix</p> required Source code in <code>src/gsp/core/camera.py</code> <pre><code>def __init__(self, view_matrix: TransBuf, projection_matrix: TransBuf):\n    \"\"\"Initialize a Camera instance. Just a container for view and projection matrices.\n\n    Args:\n        view_matrix (TransBuf): View matrix - [view-matrix](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-view-matrix)\n        projection_matrix (TransBuf): Projection matrix - [projection-matrix](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/#the-projection-matrix)\n    \"\"\"\n    self._uuid: str = UuidUtils.generate_uuid()\n    self._view_matrix: TransBuf = view_matrix\n    self._projection_matrix: TransBuf = projection_matrix\n    self.userData: dict[str, Any] = {}\n    \"\"\"A dictionary for storing custom user data associated with the Camera instance.\"\"\"\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return string representation of the Camera instance.</p> Source code in <code>src/gsp/core/camera.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return string representation of the Camera instance.\"\"\"\n    return f\"Camera(uuid={self._uuid})\"\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.get_projection_matrix","title":"<code>get_projection_matrix() -&gt; TransBuf</code>","text":"<p>Get the projection matrix of the Camera.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The projection matrix.</p> Source code in <code>src/gsp/core/camera.py</code> <pre><code>def get_projection_matrix(self) -&gt; TransBuf:\n    \"\"\"Get the projection matrix of the Camera.\n\n    Returns:\n        TransBuf: The projection matrix.\n    \"\"\"\n    return self._projection_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.get_uuid","title":"<code>get_uuid() -&gt; str</code>","text":"<p>Get the UUID of the Camera instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The UUID of the Camera.</p> Source code in <code>src/gsp/core/camera.py</code> <pre><code>def get_uuid(self) -&gt; str:\n    \"\"\"Get the UUID of the Camera instance.\n\n    Returns:\n        str: The UUID of the Camera.\n    \"\"\"\n    return self._uuid\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.get_view_matrix","title":"<code>get_view_matrix() -&gt; TransBuf</code>","text":"<p>Get the view matrix of the Camera.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The view matrix.</p> Source code in <code>src/gsp/core/camera.py</code> <pre><code>def get_view_matrix(self) -&gt; TransBuf:\n    \"\"\"Get the view matrix of the Camera.\n\n    Returns:\n        TransBuf: The view matrix.\n    \"\"\"\n    return self._view_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.set_projection_matrix","title":"<code>set_projection_matrix(projection_matrix: TransBuf)</code>","text":"<p>Set the projection matrix of the Camera.</p> <p>Parameters:</p> Name Type Description Default <code>projection_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new projection matrix.</p> required Source code in <code>src/gsp/core/camera.py</code> <pre><code>def set_projection_matrix(self, projection_matrix: TransBuf):\n    \"\"\"Set the projection matrix of the Camera.\n\n    Args:\n        projection_matrix (TransBuf): The new projection matrix.\n    \"\"\"\n    self._projection_matrix = projection_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.camera.Camera.set_view_matrix","title":"<code>set_view_matrix(view_matrix: TransBuf)</code>","text":"<p>Set the view matrix of the Camera.</p> <p>Parameters:</p> Name Type Description Default <code>view_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new view matrix.</p> required Source code in <code>src/gsp/core/camera.py</code> <pre><code>def set_view_matrix(self, view_matrix: TransBuf):\n    \"\"\"Set the view matrix of the Camera.\n\n    Args:\n        view_matrix (TransBuf): The new view matrix.\n    \"\"\"\n    self._view_matrix = view_matrix\n</code></pre>"},{"location":"api/gsp/#gsp.core.event","title":"<code>gsp.core.event</code>","text":"<p>A simple, standalone event implementation with subscribe and dispatch methods.</p>"},{"location":"api/gsp/#gsp.core.event.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>typing.Generic[gsp.core.event.Callback]</code></p> <p>A simple, standalone event implementation with subscribe and dispatch methods.</p> <p>This class allows for a \"one-to-many\" communication pattern where a single event can notify multiple listeners (subscribers) that an action has occurred.</p> <p>The generic type <code>Callback</code> allows the event to be type-hinted with the specific signature of the functions it will dispatch to, ensuring type safety.</p> Source code in <code>src/gsp/core/event.py</code> <pre><code>class Event(Generic[Callback]):\n    \"\"\"A simple, standalone event implementation with subscribe and dispatch methods.\n\n    This class allows for a \"one-to-many\" communication pattern where a single event\n    can notify multiple listeners (subscribers) that an action has occurred.\n\n    The generic type `Callback` allows the event to be type-hinted with the\n    specific signature of the functions it will dispatch to, ensuring type safety.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initialize the Event with an empty list of callbacks.\"\"\"\n        # A list to store the subscribed callback functions.\n        self._callbacks: list[Callback] = []\n\n    def subscribe(self, callback: Callback) -&gt; None:\n        \"\"\"Subscribes a callback to the event.\n\n        Args:\n            callback (Callback): The function to be called when the event is dispatched.\n                      Its signature should match the event's generic type.\n        \"\"\"\n        self._callbacks.append(callback)\n\n    def unsubscribe(self, callback: Callback) -&gt; None:\n        \"\"\"Unsubscribes a previously subscribed callback from the event.\n\n        Args:\n            callback (Callback): The function to be removed from the event's subscribers.\n        \"\"\"\n        self._callbacks.remove(callback)\n\n    def dispatch(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Dispatches the event, calling all subscribed callbacks with the given arguments.\n\n        Args:\n            *args (Any): Positional arguments to pass to the callbacks.\n            **kwargs (Any): Keyword arguments to pass to the callbacks.\n        \"\"\"\n        for callback in self._callbacks:\n            callback(*args, **kwargs)\n\n    def event_listener(self, callback: Callback) -&gt; Callback:\n        \"\"\"Decorator to subscribe a function to the event. This is a convenience method.\n\n        It still ensure static type checking on the decorated function.\n        **NOTE**: it is possible to unsubscribe the function later using `event.unsubscribe(handler)`.\n\n        Usage:\n            @event.subscriber\n            def handler(...): ...\n\n        Args:\n            callback (Callback): The function to be subscribed.\n\n        Returns:\n            Callback: The same function that was passed in.\n        \"\"\"\n        self.subscribe(callback)\n        return callback\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the Event with an empty list of callbacks.</p> Source code in <code>src/gsp/core/event.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the Event with an empty list of callbacks.\"\"\"\n    # A list to store the subscribed callback functions.\n    self._callbacks: list[Callback] = []\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.dispatch","title":"<code>dispatch(*args: Any, **kwargs: Any) -&gt; None</code>","text":"<p>Dispatches the event, calling all subscribed callbacks with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>typing.Any</code> <p>Positional arguments to pass to the callbacks.</p> <code>()</code> <code>**kwargs</code> <code>typing.Any</code> <p>Keyword arguments to pass to the callbacks.</p> <code>{}</code> Source code in <code>src/gsp/core/event.py</code> <pre><code>def dispatch(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Dispatches the event, calling all subscribed callbacks with the given arguments.\n\n    Args:\n        *args (Any): Positional arguments to pass to the callbacks.\n        **kwargs (Any): Keyword arguments to pass to the callbacks.\n    \"\"\"\n    for callback in self._callbacks:\n        callback(*args, **kwargs)\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.event_listener","title":"<code>event_listener(callback: Callback) -&gt; Callback</code>","text":"<p>Decorator to subscribe a function to the event. This is a convenience method.</p> <p>It still ensure static type checking on the decorated function. NOTE: it is possible to unsubscribe the function later using <code>event.unsubscribe(handler)</code>.</p> Usage <p>@event.subscriber def handler(...): ...</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>gsp.core.event.Callback</code> <p>The function to be subscribed.</p> required <p>Returns:</p> Name Type Description <code>Callback</code> <code>gsp.core.event.Callback</code> <p>The same function that was passed in.</p> Source code in <code>src/gsp/core/event.py</code> <pre><code>def event_listener(self, callback: Callback) -&gt; Callback:\n    \"\"\"Decorator to subscribe a function to the event. This is a convenience method.\n\n    It still ensure static type checking on the decorated function.\n    **NOTE**: it is possible to unsubscribe the function later using `event.unsubscribe(handler)`.\n\n    Usage:\n        @event.subscriber\n        def handler(...): ...\n\n    Args:\n        callback (Callback): The function to be subscribed.\n\n    Returns:\n        Callback: The same function that was passed in.\n    \"\"\"\n    self.subscribe(callback)\n    return callback\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.subscribe","title":"<code>subscribe(callback: Callback) -&gt; None</code>","text":"<p>Subscribes a callback to the event.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>gsp.core.event.Callback</code> <p>The function to be called when the event is dispatched.       Its signature should match the event's generic type.</p> required Source code in <code>src/gsp/core/event.py</code> <pre><code>def subscribe(self, callback: Callback) -&gt; None:\n    \"\"\"Subscribes a callback to the event.\n\n    Args:\n        callback (Callback): The function to be called when the event is dispatched.\n                  Its signature should match the event's generic type.\n    \"\"\"\n    self._callbacks.append(callback)\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.Event.unsubscribe","title":"<code>unsubscribe(callback: Callback) -&gt; None</code>","text":"<p>Unsubscribes a previously subscribed callback from the event.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>gsp.core.event.Callback</code> <p>The function to be removed from the event's subscribers.</p> required Source code in <code>src/gsp/core/event.py</code> <pre><code>def unsubscribe(self, callback: Callback) -&gt; None:\n    \"\"\"Unsubscribes a previously subscribed callback from the event.\n\n    Args:\n        callback (Callback): The function to be removed from the event's subscribers.\n    \"\"\"\n    self._callbacks.remove(callback)\n</code></pre>"},{"location":"api/gsp/#gsp.core.event.main","title":"<code>main() -&gt; None</code>","text":"<p>Example usage of the Event class.</p> Source code in <code>src/gsp/core/event.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Example usage of the Event class.\"\"\"\n    from typing import Protocol\n\n    # We can define the expected function signature using a Protocol for clarity.\n    class UserLoginCallback(Protocol):\n        def __call__(self, username: str, user_id: int) -&gt; None: ...\n\n    # Create an instance of our Event, typed with the protocol.\n    on_user_login = Event[UserLoginCallback]()\n\n    def welcome_user(username: str, user_id: int) -&gt; None:\n        print(f\"Welcome, {username}! Your user ID is {user_id}.\")\n\n    def log_login_event(username: str, user_id: float) -&gt; None:\n        print(f\"[{username}] logged in with ID [{user_id}] at the database level.\")\n\n    # Subscribe the functions\n    on_user_login.subscribe(welcome_user)\n    on_user_login.subscribe(log_login_event)\n\n    # Dispatch the event\n    print(\"Dispatching event for user 'Alice'...\")\n    on_user_login.dispatch(\"Alice\", \"ddd\")\n</code></pre>"},{"location":"api/gsp/#types-module","title":"Types Module","text":""},{"location":"api/gsp/#gsp.types.buffer","title":"<code>gsp.types.buffer</code>","text":"<p>Buffer module for typed array with single dimension.</p>"},{"location":"api/gsp/#gsp.types.buffer.Buffer","title":"<code>Buffer</code>","text":"<p>Typed array with single dimension.</p> <p>It is immutable in count and type, but mutable in content.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>class Buffer:\n    \"\"\"Typed array with single dimension.\n\n    It is immutable in count and type, but mutable in content.\n    \"\"\"\n\n    def __init__(self, count: int, buffer_type: BufferType) -&gt; None:\n        \"\"\"Initialize a Buffer instance.\n\n        Args:\n            count (int): The number of elements in the buffer.\n            buffer_type (BufferType): The type of elements in the buffer.\n        \"\"\"\n        item_size = BufferType.get_item_size(buffer_type)\n        self._count: int = count\n        self._type: BufferType = buffer_type\n        self._bytearray: bytearray = bytearray(count * item_size)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the Buffer.\n\n        Returns:\n            str: A string representation showing count and type.\n        \"\"\"\n        return f\"Buffer(count={self._count}, type={self._type})\"\n\n    def get_count(self) -&gt; int:\n        \"\"\"Return the number of elements in the buffer.\n\n        Returns:\n            int: The number of elements.\n        \"\"\"\n        return self._count\n\n    def get_type(self) -&gt; BufferType:\n        \"\"\"Return the type of each element in the buffer.\n\n        Returns:\n            BufferType: The buffer type.\n        \"\"\"\n        return self._type\n\n    # =============================================================================\n    # .get_data/.set_data\n    # =============================================================================\n\n    def get_data(self, offset: int, count: int) -&gt; \"Buffer\":\n        \"\"\"Return a buffer of count elements starting from offset.\n\n        Args:\n            offset (int): The starting index.\n            count (int): The number of elements to retrieve.\n\n        Returns:\n            Buffer: A new Buffer containing the requested data.\n        \"\"\"\n        item_size = BufferType.get_item_size(self._type)\n        start = offset * item_size\n        end = start + count * item_size\n\n        new_buffer = Buffer(count, self._type)\n        new_buffer.set_data(self._bytearray[start:end], 0, count)\n        return new_buffer\n\n    def set_data(self, _bytearray: bytearray, offset: int, count: int) -&gt; None:\n        \"\"\"Copy count elements starting from offset in the source bytearray.\n\n        Args:\n            _bytearray (bytearray): The source bytearray containing data to copy.\n            offset (int): The starting index in the buffer where data will be copied.\n            count (int): The number of elements to copy.\n        \"\"\"\n        item_size = BufferType.get_item_size(self._type)\n\n        # sanity check\n        assert offset + count &lt;= self._count, f\"Invalid offset {offset} and count {count} for buffer of size {self._count}\"\n\n        start = offset * item_size\n        end = start + count * item_size\n        self._bytearray = self._bytearray[:start] + _bytearray[0 : count * item_size] + self._bytearray[end:]\n\n    # =============================================================================\n    # .to_bytearray/from_bytearray\n    # =============================================================================\n\n    def to_bytearray(self) -&gt; bytearray:\n        \"\"\"Return the content of the Buffer as a bytearray.\n\n        Returns:\n            bytearray: The bytearray representation of the Buffer.\n        \"\"\"\n        return bytearray(self._bytearray)\n\n    @staticmethod\n    def from_bytearray(_bytearray: bytearray, buffer_type: BufferType) -&gt; \"Buffer\":\n        \"\"\"Create a Buffer from a bytearray and a specified BufferType.\n\n        Args:\n            _bytearray (bytearray): The source bytearray.\n            buffer_type (BufferType): The type of elements in the buffer.\n\n        Returns:\n            Buffer: The created Buffer instance.\n        \"\"\"\n        item_size = BufferType.get_item_size(buffer_type)\n        # sanity check\n        assert len(_bytearray) % item_size == 0, f\"data size {len(_bytearray)} is not aligned with buffer type item size {item_size}\"\n\n        # create buffer\n        buffer = Buffer(len(_bytearray) // item_size, buffer_type)\n        buffer.set_data(_bytearray, 0, buffer.get_count())\n        return buffer\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.__init__","title":"<code>__init__(count: int, buffer_type: BufferType) -&gt; None</code>","text":"<p>Initialize a Buffer instance.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements in the buffer.</p> required <code>buffer_type</code> <code>gsp.types.buffer_type.BufferType</code> <p>The type of elements in the buffer.</p> required Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def __init__(self, count: int, buffer_type: BufferType) -&gt; None:\n    \"\"\"Initialize a Buffer instance.\n\n    Args:\n        count (int): The number of elements in the buffer.\n        buffer_type (BufferType): The type of elements in the buffer.\n    \"\"\"\n    item_size = BufferType.get_item_size(buffer_type)\n    self._count: int = count\n    self._type: BufferType = buffer_type\n    self._bytearray: bytearray = bytearray(count * item_size)\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return a string representation of the Buffer.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation showing count and type.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the Buffer.\n\n    Returns:\n        str: A string representation showing count and type.\n    \"\"\"\n    return f\"Buffer(count={self._count}, type={self._type})\"\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.from_bytearray","title":"<code>from_bytearray(_bytearray: bytearray, buffer_type: BufferType) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Create a Buffer from a bytearray and a specified BufferType.</p> <p>Parameters:</p> Name Type Description Default <code>_bytearray</code> <code>bytearray</code> <p>The source bytearray.</p> required <code>buffer_type</code> <code>gsp.types.buffer_type.BufferType</code> <p>The type of elements in the buffer.</p> required <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.buffer.Buffer</code> <p>The created Buffer instance.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>@staticmethod\ndef from_bytearray(_bytearray: bytearray, buffer_type: BufferType) -&gt; \"Buffer\":\n    \"\"\"Create a Buffer from a bytearray and a specified BufferType.\n\n    Args:\n        _bytearray (bytearray): The source bytearray.\n        buffer_type (BufferType): The type of elements in the buffer.\n\n    Returns:\n        Buffer: The created Buffer instance.\n    \"\"\"\n    item_size = BufferType.get_item_size(buffer_type)\n    # sanity check\n    assert len(_bytearray) % item_size == 0, f\"data size {len(_bytearray)} is not aligned with buffer type item size {item_size}\"\n\n    # create buffer\n    buffer = Buffer(len(_bytearray) // item_size, buffer_type)\n    buffer.set_data(_bytearray, 0, buffer.get_count())\n    return buffer\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.get_count","title":"<code>get_count() -&gt; int</code>","text":"<p>Return the number of elements in the buffer.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def get_count(self) -&gt; int:\n    \"\"\"Return the number of elements in the buffer.\n\n    Returns:\n        int: The number of elements.\n    \"\"\"\n    return self._count\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.get_data","title":"<code>get_data(offset: int, count: int) -&gt; Buffer</code>","text":"<p>Return a buffer of count elements starting from offset.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>The starting index.</p> required <code>count</code> <code>int</code> <p>The number of elements to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.buffer.Buffer</code> <p>A new Buffer containing the requested data.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def get_data(self, offset: int, count: int) -&gt; \"Buffer\":\n    \"\"\"Return a buffer of count elements starting from offset.\n\n    Args:\n        offset (int): The starting index.\n        count (int): The number of elements to retrieve.\n\n    Returns:\n        Buffer: A new Buffer containing the requested data.\n    \"\"\"\n    item_size = BufferType.get_item_size(self._type)\n    start = offset * item_size\n    end = start + count * item_size\n\n    new_buffer = Buffer(count, self._type)\n    new_buffer.set_data(self._bytearray[start:end], 0, count)\n    return new_buffer\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.get_type","title":"<code>get_type() -&gt; BufferType</code>","text":"<p>Return the type of each element in the buffer.</p> <p>Returns:</p> Name Type Description <code>BufferType</code> <code>gsp.types.buffer_type.BufferType</code> <p>The buffer type.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def get_type(self) -&gt; BufferType:\n    \"\"\"Return the type of each element in the buffer.\n\n    Returns:\n        BufferType: The buffer type.\n    \"\"\"\n    return self._type\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.set_data","title":"<code>set_data(_bytearray: bytearray, offset: int, count: int) -&gt; None</code>","text":"<p>Copy count elements starting from offset in the source bytearray.</p> <p>Parameters:</p> Name Type Description Default <code>_bytearray</code> <code>bytearray</code> <p>The source bytearray containing data to copy.</p> required <code>offset</code> <code>int</code> <p>The starting index in the buffer where data will be copied.</p> required <code>count</code> <code>int</code> <p>The number of elements to copy.</p> required Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def set_data(self, _bytearray: bytearray, offset: int, count: int) -&gt; None:\n    \"\"\"Copy count elements starting from offset in the source bytearray.\n\n    Args:\n        _bytearray (bytearray): The source bytearray containing data to copy.\n        offset (int): The starting index in the buffer where data will be copied.\n        count (int): The number of elements to copy.\n    \"\"\"\n    item_size = BufferType.get_item_size(self._type)\n\n    # sanity check\n    assert offset + count &lt;= self._count, f\"Invalid offset {offset} and count {count} for buffer of size {self._count}\"\n\n    start = offset * item_size\n    end = start + count * item_size\n    self._bytearray = self._bytearray[:start] + _bytearray[0 : count * item_size] + self._bytearray[end:]\n</code></pre>"},{"location":"api/gsp/#gsp.types.buffer.Buffer.to_bytearray","title":"<code>to_bytearray() -&gt; bytearray</code>","text":"<p>Return the content of the Buffer as a bytearray.</p> <p>Returns:</p> Name Type Description <code>bytearray</code> <code>bytearray</code> <p>The bytearray representation of the Buffer.</p> Source code in <code>src/gsp/types/buffer.py</code> <pre><code>def to_bytearray(self) -&gt; bytearray:\n    \"\"\"Return the content of the Buffer as a bytearray.\n\n    Returns:\n        bytearray: The bytearray representation of the Buffer.\n    \"\"\"\n    return bytearray(self._bytearray)\n</code></pre>"},{"location":"api/gsp/#gsp.types.group","title":"<code>gsp.types.group</code>","text":"<p>Group type definitions for GSP.</p> <p>This module defines types used to represent groups of elements in various forms.</p>"},{"location":"api/gsp/#gsp.types.group.Groups","title":"<code>Groups = Union[int, list[int], list[list[int]]]</code>  <code>module-attribute</code>","text":"<p>A type that can represent group IDs in various forms.</p> The Groups type supports three different formats <ul> <li>int: Represents the size of a single group.</li> <li>list[int]: Each int represents the size of each subgroup.</li> <li>list[list[int]]: Each sublist represents element indices in a group.<ul> <li>len(groups) represents the number of groups.</li> <li>groups[0] contains element indices of the first group.</li> <li>groups[1] contains element indices of the second group.</li> </ul> </li> </ul>"},{"location":"api/gsp/#gsp.types.visual_base","title":"<code>gsp.types.visual_base</code>","text":"<p>Base class for visual objects in GSP.</p> <p>This module provides the foundational VisualBase class that all visual objects inherit from, providing common functionality like UUID generation and user data storage.</p>"},{"location":"api/gsp/#gsp.types.visual_base.VisualBase","title":"<code>VisualBase</code>","text":"<p>Base class for all visual objects in the GSP library.</p> <p>This class provides fundamental functionality for visual objects including automatic UUID generation and a userData dictionary for storing custom metadata.</p> Source code in <code>src/gsp/types/visual_base.py</code> <pre><code>class VisualBase:\n    \"\"\"Base class for all visual objects in the GSP library.\n\n    This class provides fundamental functionality for visual objects including\n    automatic UUID generation and a userData dictionary for storing custom\n    metadata.\n    \"\"\"\n    __slots__ = [\"_uuid\", \"userData\"]\n\n    def __init__(self):\n        \"\"\"Initialize a new VisualBase instance.\n\n        Creates a new visual object with a unique identifier and an empty\n        userData dictionary.\n        \"\"\"\n        self._uuid: str = UuidUtils.generate_uuid()\n        self.userData: dict[str, Any] = {}\n\n    def get_uuid(self) -&gt; str:\n        \"\"\"Get the unique identifier of the visual object.\n\n        Returns:\n            str: The unique identifier.\n        \"\"\"\n        return self._uuid\n</code></pre>"},{"location":"api/gsp/#gsp.types.visual_base.VisualBase.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a new VisualBase instance.</p> <p>Creates a new visual object with a unique identifier and an empty userData dictionary.</p> Source code in <code>src/gsp/types/visual_base.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a new VisualBase instance.\n\n    Creates a new visual object with a unique identifier and an empty\n    userData dictionary.\n    \"\"\"\n    self._uuid: str = UuidUtils.generate_uuid()\n    self.userData: dict[str, Any] = {}\n</code></pre>"},{"location":"api/gsp/#gsp.types.visual_base.VisualBase.get_uuid","title":"<code>get_uuid() -&gt; str</code>","text":"<p>Get the unique identifier of the visual object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier.</p> Source code in <code>src/gsp/types/visual_base.py</code> <pre><code>def get_uuid(self) -&gt; str:\n    \"\"\"Get the unique identifier of the visual object.\n\n    Returns:\n        str: The unique identifier.\n    \"\"\"\n    return self._uuid\n</code></pre>"},{"location":"api/gsp/#visuals-module","title":"Visuals Module","text":""},{"location":"api/gsp/#gsp.visuals.points","title":"<code>gsp.visuals.points</code>","text":"<p>Points visual module.</p>"},{"location":"api/gsp/#gsp.visuals.points.Points","title":"<code>Points</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> <p>Points visual for rendering point markers.</p> <p>This visual represents a collection of points with configurable positions, sizes, face colors, edge colors, and edge widths.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>class Points(VisualBase):\n    \"\"\"Points visual for rendering point markers.\n\n    This visual represents a collection of points with configurable positions,\n    sizes, face colors, edge colors, and edge widths.\n    \"\"\"\n    __slots__ = [\"_positions\", \"_sizes\", \"_face_colors\", \"_edge_colors\", \"_edge_widths\"]\n\n    def __init__(self, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf):\n        \"\"\"Initialize Points visual.\n\n        Args:\n            positions: Positions of the points.\n            sizes: Sizes of the points.\n            face_colors: Face colors of the points.\n            edge_colors: Edge colors of the points.\n            edge_widths: Edge widths of the points.\n        \"\"\"\n        super().__init__()\n\n        self._positions: TransBuf = positions\n        self._sizes: TransBuf = sizes\n        self._face_colors: TransBuf = face_colors\n        self._edge_colors: TransBuf = edge_colors\n        self._edge_widths: TransBuf = edge_widths\n\n        self.check_attributes()\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        \"\"\"Get positions of the points.\"\"\"\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        \"\"\"Set positions of the points.\n\n        Args:\n            positions: New positions for the points.\n        \"\"\"\n        self._positions = positions\n        self.check_attributes()\n\n    def get_sizes(self) -&gt; TransBuf:\n        \"\"\"Get sizes of the points.\"\"\"\n        return self._sizes\n\n    def set_sizes(self, sizes: TransBuf) -&gt; None:\n        \"\"\"Set sizes of the points.\n\n        Args:\n            sizes: New sizes for the points.\n        \"\"\"\n        self._sizes = sizes\n        self.check_attributes()\n\n    def get_face_colors(self) -&gt; TransBuf:\n        \"\"\"Get face colors of the points.\"\"\"\n        return self._face_colors\n\n    def set_face_colors(self, face_colors: TransBuf) -&gt; None:\n        \"\"\"Set face colors of the points.\n\n        Args:\n            face_colors: New face colors for the points.\n        \"\"\"\n        self._face_colors = face_colors\n        self.check_attributes()\n\n    def get_edge_colors(self) -&gt; TransBuf:\n        \"\"\"Get edge colors of the points.\"\"\"\n        return self._edge_colors\n\n    def set_edge_colors(self, edge_colors: TransBuf) -&gt; None:\n        \"\"\"Set edge colors of the points.\n\n        Args:\n            edge_colors: New edge colors for the points.\n        \"\"\"\n        self._edge_colors = edge_colors\n        self.check_attributes()\n\n    def get_edge_widths(self) -&gt; TransBuf:\n        \"\"\"Get edge widths of the points.\"\"\"\n        return self._edge_widths\n\n    def set_edge_widths(self, edge_widths: TransBuf) -&gt; None:\n        \"\"\"Set edge widths of the points.\n\n        Args:\n            edge_widths: New edge widths for the points.\n        \"\"\"\n        self._edge_widths = edge_widths\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        positions: TransBuf | None = None,\n        sizes: TransBuf | None = None,\n        face_colors: TransBuf | None = None,\n        edge_colors: TransBuf | None = None,\n        edge_widths: TransBuf | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if positions is not None:\n            self._positions = positions\n        if sizes is not None:\n            self._sizes = sizes\n        if face_colors is not None:\n            self._face_colors = face_colors\n        if edge_colors is not None:\n            self._edge_colors = edge_colors\n        if edge_widths is not None:\n            self._edge_widths = edge_widths\n\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._positions, self._sizes, self._face_colors, self._edge_colors, self._edge_widths)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer):\n        \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(sizes, Buffer), \"Sizes must be a Buffer\"\n        assert isinstance(face_colors, Buffer), \"Face colors must be a Buffer\"\n        assert isinstance(edge_colors, Buffer), \"Edge colors must be a Buffer\"\n        assert isinstance(edge_widths, Buffer), \"Edge widths must be a Buffer\"\n\n        Points.sanity_check_attributes(positions, sizes, face_colors, edge_colors, edge_widths)\n\n    @staticmethod\n    def sanity_check_attributes(\n        positions: TransBuf,\n        sizes: TransBuf,\n        face_colors: TransBuf,\n        edge_colors: TransBuf,\n        edge_widths: TransBuf,\n    ) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\n\n        Args:\n            positions: Positions of the points.\n            sizes: Sizes of the points.\n            face_colors: Face colors of the points.\n            edge_colors: Edge colors of the points.\n            edge_widths: Edge widths of the points.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.__init__","title":"<code>__init__(positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf)</code>","text":"<p>Initialize Points visual.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the points.</p> required <code>sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Sizes of the points.</p> required <code>face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Face colors of the points.</p> required <code>edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Edge colors of the points.</p> required <code>edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Edge widths of the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def __init__(self, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf):\n    \"\"\"Initialize Points visual.\n\n    Args:\n        positions: Positions of the points.\n        sizes: Sizes of the points.\n        face_colors: Face colors of the points.\n        edge_colors: Edge colors of the points.\n        edge_widths: Edge widths of the points.\n    \"\"\"\n    super().__init__()\n\n    self._positions: TransBuf = positions\n    self._sizes: TransBuf = sizes\n    self._face_colors: TransBuf = face_colors\n    self._edge_colors: TransBuf = edge_colors\n    self._edge_widths: TransBuf = edge_widths\n\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._positions, self._sizes, self._face_colors, self._edge_colors, self._edge_widths)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.get_edge_colors","title":"<code>get_edge_colors() -&gt; TransBuf</code>","text":"<p>Get edge colors of the points.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def get_edge_colors(self) -&gt; TransBuf:\n    \"\"\"Get edge colors of the points.\"\"\"\n    return self._edge_colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.get_edge_widths","title":"<code>get_edge_widths() -&gt; TransBuf</code>","text":"<p>Get edge widths of the points.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def get_edge_widths(self) -&gt; TransBuf:\n    \"\"\"Get edge widths of the points.\"\"\"\n    return self._edge_widths\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.get_face_colors","title":"<code>get_face_colors() -&gt; TransBuf</code>","text":"<p>Get face colors of the points.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def get_face_colors(self) -&gt; TransBuf:\n    \"\"\"Get face colors of the points.\"\"\"\n    return self._face_colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.get_positions","title":"<code>get_positions() -&gt; TransBuf</code>","text":"<p>Get positions of the points.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def get_positions(self) -&gt; TransBuf:\n    \"\"\"Get positions of the points.\"\"\"\n    return self._positions\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.get_sizes","title":"<code>get_sizes() -&gt; TransBuf</code>","text":"<p>Get sizes of the points.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def get_sizes(self) -&gt; TransBuf:\n    \"\"\"Get sizes of the points.\"\"\"\n    return self._sizes\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.sanity_check_attributes","title":"<code>sanity_check_attributes(positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Check that the attributes are valid and consistent.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the points.</p> required <code>sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Sizes of the points.</p> required <code>face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Face colors of the points.</p> required <code>edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Edge colors of the points.</p> required <code>edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Edge widths of the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes(\n    positions: TransBuf,\n    sizes: TransBuf,\n    face_colors: TransBuf,\n    edge_colors: TransBuf,\n    edge_widths: TransBuf,\n) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\n\n    Args:\n        positions: Positions of the points.\n        sizes: Sizes of the points.\n        face_colors: Face colors of the points.\n        edge_colors: Edge colors of the points.\n        edge_widths: Edge widths of the points.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer)</code>  <code>staticmethod</code>","text":"<p>Same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer):\n    \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(sizes, Buffer), \"Sizes must be a Buffer\"\n    assert isinstance(face_colors, Buffer), \"Face colors must be a Buffer\"\n    assert isinstance(edge_colors, Buffer), \"Edge colors must be a Buffer\"\n    assert isinstance(edge_widths, Buffer), \"Edge widths must be a Buffer\"\n\n    Points.sanity_check_attributes(positions, sizes, face_colors, edge_colors, edge_widths)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, sizes: TransBuf | None = None, face_colors: TransBuf | None = None, edge_colors: TransBuf | None = None, edge_widths: TransBuf | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def set_attributes(\n    self,\n    positions: TransBuf | None = None,\n    sizes: TransBuf | None = None,\n    face_colors: TransBuf | None = None,\n    edge_colors: TransBuf | None = None,\n    edge_widths: TransBuf | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if positions is not None:\n        self._positions = positions\n    if sizes is not None:\n        self._sizes = sizes\n    if face_colors is not None:\n        self._face_colors = face_colors\n    if edge_colors is not None:\n        self._edge_colors = edge_colors\n    if edge_widths is not None:\n        self._edge_widths = edge_widths\n\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.set_edge_colors","title":"<code>set_edge_colors(edge_colors: TransBuf) -&gt; None</code>","text":"<p>Set edge colors of the points.</p> <p>Parameters:</p> Name Type Description Default <code>edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>New edge colors for the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def set_edge_colors(self, edge_colors: TransBuf) -&gt; None:\n    \"\"\"Set edge colors of the points.\n\n    Args:\n        edge_colors: New edge colors for the points.\n    \"\"\"\n    self._edge_colors = edge_colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.set_edge_widths","title":"<code>set_edge_widths(edge_widths: TransBuf) -&gt; None</code>","text":"<p>Set edge widths of the points.</p> <p>Parameters:</p> Name Type Description Default <code>edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>New edge widths for the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def set_edge_widths(self, edge_widths: TransBuf) -&gt; None:\n    \"\"\"Set edge widths of the points.\n\n    Args:\n        edge_widths: New edge widths for the points.\n    \"\"\"\n    self._edge_widths = edge_widths\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.set_face_colors","title":"<code>set_face_colors(face_colors: TransBuf) -&gt; None</code>","text":"<p>Set face colors of the points.</p> <p>Parameters:</p> Name Type Description Default <code>face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>New face colors for the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def set_face_colors(self, face_colors: TransBuf) -&gt; None:\n    \"\"\"Set face colors of the points.\n\n    Args:\n        face_colors: New face colors for the points.\n    \"\"\"\n    self._face_colors = face_colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.set_positions","title":"<code>set_positions(positions: TransBuf) -&gt; None</code>","text":"<p>Set positions of the points.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>New positions for the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def set_positions(self, positions: TransBuf) -&gt; None:\n    \"\"\"Set positions of the points.\n\n    Args:\n        positions: New positions for the points.\n    \"\"\"\n    self._positions = positions\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.points.Points.set_sizes","title":"<code>set_sizes(sizes: TransBuf) -&gt; None</code>","text":"<p>Set sizes of the points.</p> <p>Parameters:</p> Name Type Description Default <code>sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>New sizes for the points.</p> required Source code in <code>src/gsp/visuals/points.py</code> <pre><code>def set_sizes(self, sizes: TransBuf) -&gt; None:\n    \"\"\"Set sizes of the points.\n\n    Args:\n        sizes: New sizes for the points.\n    \"\"\"\n    self._sizes = sizes\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers","title":"<code>gsp.visuals.markers</code>","text":"<p>Marker visual for rendering 2D/3D markers with customizable shapes, sizes, and colors.</p>"},{"location":"api/gsp/#gsp.visuals.markers.Markers","title":"<code>Markers</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> <p>Visual representation of markers with configurable properties.</p> <p>This class manages marker visualization with properties including shape, positions, sizes, face colors, edge colors, and edge widths.</p> <p>Attributes:</p> Name Type Description <code>_marker_shape</code> <code>gsp.types.marker_shape.MarkerShape</code> <p>The shape of the markers.</p> <code>_positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>The positions of the markers.</p> <code>_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>The sizes of the markers.</p> <code>_face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The face colors of the markers.</p> <code>_edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The edge colors of the markers.</p> <code>_edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>The edge widths of the markers.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>class Markers(VisualBase):\n    \"\"\"Visual representation of markers with configurable properties.\n\n    This class manages marker visualization with properties including shape,\n    positions, sizes, face colors, edge colors, and edge widths.\n\n    Attributes:\n        _marker_shape (MarkerShape): The shape of the markers.\n        _positions (TransBuf): The positions of the markers.\n        _sizes (TransBuf): The sizes of the markers.\n        _face_colors (TransBuf): The face colors of the markers.\n        _edge_colors (TransBuf): The edge colors of the markers.\n        _edge_widths (TransBuf): The edge widths of the markers.\n    \"\"\"\n    __slots__ = [\"_marker_shape\", \"_positions\", \"_sizes\", \"_face_colors\", \"_edge_colors\", \"_edge_widths\"]\n\n    def __init__(self, marker_shape: MarkerShape, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf):\n        \"\"\"Initialize a Markers visual.\n\n        Args:\n            marker_shape (MarkerShape): The shape of the markers.\n            positions (TransBuf): The positions of the markers.\n            sizes (TransBuf): The sizes of the markers.\n            face_colors (TransBuf): The face colors of the markers.\n            edge_colors (TransBuf): The edge colors of the markers.\n            edge_widths (TransBuf): The edge widths of the markers.\n        \"\"\"\n        super().__init__()\n\n        self._marker_shape: MarkerShape = marker_shape\n        self._positions: TransBuf = positions\n        self._sizes: TransBuf = sizes\n        self._face_colors: TransBuf = face_colors\n        self._edge_colors: TransBuf = edge_colors\n        self._edge_widths: TransBuf = edge_widths\n\n        self.check_attributes()\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_marker_shape(self) -&gt; MarkerShape:\n        \"\"\"Get the marker shape.\n\n        Returns:\n            MarkerShape: The marker shape.\n        \"\"\"\n        return self._marker_shape\n\n    def set_marker_shape(self, marker_shape: MarkerShape) -&gt; None:\n        \"\"\"Set the marker shape.\n\n        Args:\n            marker_shape (MarkerShape): The new marker shape.\n        \"\"\"\n        self._marker_shape = marker_shape\n        self.check_attributes()\n\n    def get_positions(self) -&gt; TransBuf:\n        \"\"\"Get the marker positions.\n\n        Returns:\n            TransBuf: The marker positions.\n        \"\"\"\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        \"\"\"Set the marker positions.\n\n        Args:\n            positions (TransBuf): The new marker positions.\n        \"\"\"\n        self._positions = positions\n        self.check_attributes()\n\n    def get_sizes(self) -&gt; TransBuf:\n        \"\"\"Get the marker sizes.\n\n        Returns:\n            TransBuf: The marker sizes.\n        \"\"\"\n        return self._sizes\n\n    def set_sizes(self, sizes: TransBuf) -&gt; None:\n        \"\"\"Set the marker sizes.\n\n        Args:\n            sizes (TransBuf): The new marker sizes.\n        \"\"\"\n        self._sizes = sizes\n        self.check_attributes()\n\n    def get_face_colors(self) -&gt; TransBuf:\n        \"\"\"Get the marker face colors.\n\n        Returns:\n            TransBuf: The marker face colors.\n        \"\"\"\n        return self._face_colors\n\n    def set_face_colors(self, face_colors: TransBuf) -&gt; None:\n        \"\"\"Set the marker face colors.\n\n        Args:\n            face_colors (TransBuf): The new marker face colors.\n        \"\"\"\n        self._face_colors = face_colors\n        self.check_attributes()\n\n    def get_edge_colors(self) -&gt; TransBuf:\n        \"\"\"Get the marker edge colors.\n\n        Returns:\n            TransBuf: The marker edge colors.\n        \"\"\"\n        return self._edge_colors\n\n    def set_edge_colors(self, edge_colors: TransBuf) -&gt; None:\n        \"\"\"Set the marker edge colors.\n\n        Args:\n            edge_colors (TransBuf): The new marker edge colors.\n        \"\"\"\n        self._edge_colors = edge_colors\n        self.check_attributes()\n\n    def get_edge_widths(self) -&gt; TransBuf:\n        \"\"\"Get the marker edge widths.\n\n        Returns:\n            TransBuf: The marker edge widths.\n        \"\"\"\n        return self._edge_widths\n\n    def set_edge_widths(self, edge_widths: TransBuf) -&gt; None:\n        \"\"\"Set the marker edge widths.\n\n        Args:\n            edge_widths (TransBuf): The new marker edge widths.\n        \"\"\"\n        self._edge_widths = edge_widths\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        marker_shape: MarkerShape | None = None,\n        positions: TransBuf | None = None,\n        sizes: TransBuf | None = None,\n        face_colors: TransBuf | None = None,\n        edge_colors: TransBuf | None = None,\n        edge_widths: TransBuf | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if marker_shape is not None:\n            self._marker_shape = marker_shape\n        if positions is not None:\n            self._positions = positions\n        if sizes is not None:\n            self._sizes = sizes\n        if face_colors is not None:\n            self._face_colors = face_colors\n        if edge_colors is not None:\n            self._edge_colors = edge_colors\n        if edge_widths is not None:\n            self._edge_widths = edge_widths\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._marker_shape, self._positions, self._sizes, self._face_colors, self._edge_colors, self._edge_widths)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(\n        marker_shape: MarkerShape, positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer\n    ):\n        \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n        This method is meant to be used after converting TransBuf to Buffer.\n\n        Args:\n            marker_shape (MarkerShape): The marker shape.\n            positions (Buffer): The marker positions as a Buffer.\n            sizes (Buffer): The marker sizes as a Buffer.\n            face_colors (Buffer): The marker face colors as a Buffer.\n            edge_colors (Buffer): The marker edge colors as a Buffer.\n            edge_widths (Buffer): The marker edge widths as a Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(sizes, Buffer), \"Sizes must be a Buffer\"\n        assert isinstance(face_colors, Buffer), \"Face colors must be a Buffer\"\n        assert isinstance(edge_colors, Buffer), \"Edge colors must be a Buffer\"\n        assert isinstance(edge_widths, Buffer), \"Edge widths must be a Buffer\"\n\n        Markers.sanity_check_attributes(marker_shape, positions, sizes, face_colors, edge_colors, edge_widths)\n\n    @staticmethod\n    def sanity_check_attributes(\n        marker_shape: MarkerShape,\n        positions: TransBuf,\n        sizes: TransBuf,\n        face_colors: TransBuf,\n        edge_colors: TransBuf,\n        edge_widths: TransBuf,\n    ) -&gt; None:\n        \"\"\"Check that the marker attributes are valid and consistent.\n\n        Args:\n            marker_shape (MarkerShape): The marker shape.\n            positions (TransBuf): The marker positions.\n            sizes (TransBuf): The marker sizes.\n            face_colors (TransBuf): The marker face colors.\n            edge_colors (TransBuf): The marker edge colors.\n            edge_widths (TransBuf): The marker edge widths.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.__init__","title":"<code>__init__(marker_shape: MarkerShape, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf)</code>","text":"<p>Initialize a Markers visual.</p> <p>Parameters:</p> Name Type Description Default <code>marker_shape</code> <code>gsp.types.marker_shape.MarkerShape</code> <p>The shape of the markers.</p> required <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>The positions of the markers.</p> required <code>sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>The sizes of the markers.</p> required <code>face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The face colors of the markers.</p> required <code>edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The edge colors of the markers.</p> required <code>edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>The edge widths of the markers.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def __init__(self, marker_shape: MarkerShape, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf):\n    \"\"\"Initialize a Markers visual.\n\n    Args:\n        marker_shape (MarkerShape): The shape of the markers.\n        positions (TransBuf): The positions of the markers.\n        sizes (TransBuf): The sizes of the markers.\n        face_colors (TransBuf): The face colors of the markers.\n        edge_colors (TransBuf): The edge colors of the markers.\n        edge_widths (TransBuf): The edge widths of the markers.\n    \"\"\"\n    super().__init__()\n\n    self._marker_shape: MarkerShape = marker_shape\n    self._positions: TransBuf = positions\n    self._sizes: TransBuf = sizes\n    self._face_colors: TransBuf = face_colors\n    self._edge_colors: TransBuf = edge_colors\n    self._edge_widths: TransBuf = edge_widths\n\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._marker_shape, self._positions, self._sizes, self._face_colors, self._edge_colors, self._edge_widths)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.get_edge_colors","title":"<code>get_edge_colors() -&gt; TransBuf</code>","text":"<p>Get the marker edge colors.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker edge colors.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def get_edge_colors(self) -&gt; TransBuf:\n    \"\"\"Get the marker edge colors.\n\n    Returns:\n        TransBuf: The marker edge colors.\n    \"\"\"\n    return self._edge_colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.get_edge_widths","title":"<code>get_edge_widths() -&gt; TransBuf</code>","text":"<p>Get the marker edge widths.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker edge widths.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def get_edge_widths(self) -&gt; TransBuf:\n    \"\"\"Get the marker edge widths.\n\n    Returns:\n        TransBuf: The marker edge widths.\n    \"\"\"\n    return self._edge_widths\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.get_face_colors","title":"<code>get_face_colors() -&gt; TransBuf</code>","text":"<p>Get the marker face colors.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker face colors.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def get_face_colors(self) -&gt; TransBuf:\n    \"\"\"Get the marker face colors.\n\n    Returns:\n        TransBuf: The marker face colors.\n    \"\"\"\n    return self._face_colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.get_marker_shape","title":"<code>get_marker_shape() -&gt; MarkerShape</code>","text":"<p>Get the marker shape.</p> <p>Returns:</p> Name Type Description <code>MarkerShape</code> <code>gsp.types.marker_shape.MarkerShape</code> <p>The marker shape.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def get_marker_shape(self) -&gt; MarkerShape:\n    \"\"\"Get the marker shape.\n\n    Returns:\n        MarkerShape: The marker shape.\n    \"\"\"\n    return self._marker_shape\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.get_positions","title":"<code>get_positions() -&gt; TransBuf</code>","text":"<p>Get the marker positions.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker positions.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def get_positions(self) -&gt; TransBuf:\n    \"\"\"Get the marker positions.\n\n    Returns:\n        TransBuf: The marker positions.\n    \"\"\"\n    return self._positions\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.get_sizes","title":"<code>get_sizes() -&gt; TransBuf</code>","text":"<p>Get the marker sizes.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker sizes.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def get_sizes(self) -&gt; TransBuf:\n    \"\"\"Get the marker sizes.\n\n    Returns:\n        TransBuf: The marker sizes.\n    \"\"\"\n    return self._sizes\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.sanity_check_attributes","title":"<code>sanity_check_attributes(marker_shape: MarkerShape, positions: TransBuf, sizes: TransBuf, face_colors: TransBuf, edge_colors: TransBuf, edge_widths: TransBuf) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Check that the marker attributes are valid and consistent.</p> <p>Parameters:</p> Name Type Description Default <code>marker_shape</code> <code>gsp.types.marker_shape.MarkerShape</code> <p>The marker shape.</p> required <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker positions.</p> required <code>sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker sizes.</p> required <code>face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker face colors.</p> required <code>edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker edge colors.</p> required <code>edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>The marker edge widths.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes(\n    marker_shape: MarkerShape,\n    positions: TransBuf,\n    sizes: TransBuf,\n    face_colors: TransBuf,\n    edge_colors: TransBuf,\n    edge_widths: TransBuf,\n) -&gt; None:\n    \"\"\"Check that the marker attributes are valid and consistent.\n\n    Args:\n        marker_shape (MarkerShape): The marker shape.\n        positions (TransBuf): The marker positions.\n        sizes (TransBuf): The marker sizes.\n        face_colors (TransBuf): The marker face colors.\n        edge_colors (TransBuf): The marker edge colors.\n        edge_widths (TransBuf): The marker edge widths.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(marker_shape: MarkerShape, positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer)</code>  <code>staticmethod</code>","text":"<p>Same as .sanity_check_attributes() but accept only Buffers.</p> <p>This method is meant to be used after converting TransBuf to Buffer.</p> <p>Parameters:</p> Name Type Description Default <code>marker_shape</code> <code>gsp.types.marker_shape.MarkerShape</code> <p>The marker shape.</p> required <code>positions</code> <code>gsp.types.buffer.Buffer</code> <p>The marker positions as a Buffer.</p> required <code>sizes</code> <code>gsp.types.buffer.Buffer</code> <p>The marker sizes as a Buffer.</p> required <code>face_colors</code> <code>gsp.types.buffer.Buffer</code> <p>The marker face colors as a Buffer.</p> required <code>edge_colors</code> <code>gsp.types.buffer.Buffer</code> <p>The marker edge colors as a Buffer.</p> required <code>edge_widths</code> <code>gsp.types.buffer.Buffer</code> <p>The marker edge widths as a Buffer.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(\n    marker_shape: MarkerShape, positions: Buffer, sizes: Buffer, face_colors: Buffer, edge_colors: Buffer, edge_widths: Buffer\n):\n    \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n    This method is meant to be used after converting TransBuf to Buffer.\n\n    Args:\n        marker_shape (MarkerShape): The marker shape.\n        positions (Buffer): The marker positions as a Buffer.\n        sizes (Buffer): The marker sizes as a Buffer.\n        face_colors (Buffer): The marker face colors as a Buffer.\n        edge_colors (Buffer): The marker edge colors as a Buffer.\n        edge_widths (Buffer): The marker edge widths as a Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(sizes, Buffer), \"Sizes must be a Buffer\"\n    assert isinstance(face_colors, Buffer), \"Face colors must be a Buffer\"\n    assert isinstance(edge_colors, Buffer), \"Edge colors must be a Buffer\"\n    assert isinstance(edge_widths, Buffer), \"Edge widths must be a Buffer\"\n\n    Markers.sanity_check_attributes(marker_shape, positions, sizes, face_colors, edge_colors, edge_widths)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_attributes","title":"<code>set_attributes(marker_shape: MarkerShape | None = None, positions: TransBuf | None = None, sizes: TransBuf | None = None, face_colors: TransBuf | None = None, edge_colors: TransBuf | None = None, edge_widths: TransBuf | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_attributes(\n    self,\n    marker_shape: MarkerShape | None = None,\n    positions: TransBuf | None = None,\n    sizes: TransBuf | None = None,\n    face_colors: TransBuf | None = None,\n    edge_colors: TransBuf | None = None,\n    edge_widths: TransBuf | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if marker_shape is not None:\n        self._marker_shape = marker_shape\n    if positions is not None:\n        self._positions = positions\n    if sizes is not None:\n        self._sizes = sizes\n    if face_colors is not None:\n        self._face_colors = face_colors\n    if edge_colors is not None:\n        self._edge_colors = edge_colors\n    if edge_widths is not None:\n        self._edge_widths = edge_widths\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_edge_colors","title":"<code>set_edge_colors(edge_colors: TransBuf) -&gt; None</code>","text":"<p>Set the marker edge colors.</p> <p>Parameters:</p> Name Type Description Default <code>edge_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new marker edge colors.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_edge_colors(self, edge_colors: TransBuf) -&gt; None:\n    \"\"\"Set the marker edge colors.\n\n    Args:\n        edge_colors (TransBuf): The new marker edge colors.\n    \"\"\"\n    self._edge_colors = edge_colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_edge_widths","title":"<code>set_edge_widths(edge_widths: TransBuf) -&gt; None</code>","text":"<p>Set the marker edge widths.</p> <p>Parameters:</p> Name Type Description Default <code>edge_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new marker edge widths.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_edge_widths(self, edge_widths: TransBuf) -&gt; None:\n    \"\"\"Set the marker edge widths.\n\n    Args:\n        edge_widths (TransBuf): The new marker edge widths.\n    \"\"\"\n    self._edge_widths = edge_widths\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_face_colors","title":"<code>set_face_colors(face_colors: TransBuf) -&gt; None</code>","text":"<p>Set the marker face colors.</p> <p>Parameters:</p> Name Type Description Default <code>face_colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new marker face colors.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_face_colors(self, face_colors: TransBuf) -&gt; None:\n    \"\"\"Set the marker face colors.\n\n    Args:\n        face_colors (TransBuf): The new marker face colors.\n    \"\"\"\n    self._face_colors = face_colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_marker_shape","title":"<code>set_marker_shape(marker_shape: MarkerShape) -&gt; None</code>","text":"<p>Set the marker shape.</p> <p>Parameters:</p> Name Type Description Default <code>marker_shape</code> <code>gsp.types.marker_shape.MarkerShape</code> <p>The new marker shape.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_marker_shape(self, marker_shape: MarkerShape) -&gt; None:\n    \"\"\"Set the marker shape.\n\n    Args:\n        marker_shape (MarkerShape): The new marker shape.\n    \"\"\"\n    self._marker_shape = marker_shape\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_positions","title":"<code>set_positions(positions: TransBuf) -&gt; None</code>","text":"<p>Set the marker positions.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new marker positions.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_positions(self, positions: TransBuf) -&gt; None:\n    \"\"\"Set the marker positions.\n\n    Args:\n        positions (TransBuf): The new marker positions.\n    \"\"\"\n    self._positions = positions\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.markers.Markers.set_sizes","title":"<code>set_sizes(sizes: TransBuf) -&gt; None</code>","text":"<p>Set the marker sizes.</p> <p>Parameters:</p> Name Type Description Default <code>sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>The new marker sizes.</p> required Source code in <code>src/gsp/visuals/markers.py</code> <pre><code>def set_sizes(self, sizes: TransBuf) -&gt; None:\n    \"\"\"Set the marker sizes.\n\n    Args:\n        sizes (TransBuf): The new marker sizes.\n    \"\"\"\n    self._sizes = sizes\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments","title":"<code>gsp.visuals.segments</code>","text":"<p>Segments visual module.</p>"},{"location":"api/gsp/#gsp.visuals.segments.Segments","title":"<code>Segments</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> <p>Segments visual for rendering line segments.</p> <p>This visual represents a collection of line segments with configurable positions, line widths, cap styles, and colors.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>class Segments(VisualBase):\n    \"\"\"Segments visual for rendering line segments.\n\n    This visual represents a collection of line segments with configurable\n    positions, line widths, cap styles, and colors.\n    \"\"\"\n    __slots__ = [\"_positions\", \"_colors\", \"_line_widths\", \"_cap_style\"]\n\n    def __init__(self, positions: TransBuf, line_widths: TransBuf, cap_style: CapStyle, colors: TransBuf) -&gt; None:\n        \"\"\"Initialize Segments visual.\n\n        Args:\n            positions: Positions of the segment endpoints.\n            line_widths: Widths of the line segments.\n            cap_style: Cap style for the line segments.\n            colors: Colors of the segments.\n        \"\"\"\n        super().__init__()\n\n        self._positions: TransBuf = positions\n        self._line_widths: TransBuf = line_widths\n        self._cap_style: CapStyle = cap_style\n        self._colors: TransBuf = colors\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        \"\"\"Get positions of the segment endpoints.\"\"\"\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        \"\"\"Set positions of the segment endpoints.\n\n        Args:\n            positions: New positions for the segments.\n        \"\"\"\n        self._positions = positions\n        self.check_attributes()\n\n    def get_line_widths(self) -&gt; TransBuf:\n        \"\"\"Get line widths of the segments.\"\"\"\n        return self._line_widths\n\n    def set_line_widths(self, line_widths: TransBuf) -&gt; None:\n        \"\"\"Set line widths of the segments.\n\n        Args:\n            line_widths: New line widths for the segments.\n        \"\"\"\n        self._line_widths = line_widths\n        self.check_attributes()\n\n    def get_cap_style(self) -&gt; CapStyle:\n        \"\"\"Get cap style of the segments.\"\"\"\n        return self._cap_style\n\n    def set_cap_style(self, cap_style: CapStyle) -&gt; None:\n        \"\"\"Set cap style of the segments.\n\n        Args:\n            cap_style: New cap style for the segments.\n        \"\"\"\n        self._cap_style = cap_style\n        self.check_attributes()\n\n    def get_colors(self) -&gt; TransBuf:\n        \"\"\"Get colors of the segments.\"\"\"\n        return self._colors\n\n    def set_colors(self, colors: TransBuf) -&gt; None:\n        \"\"\"Set colors of the segments.\n\n        Args:\n            colors: New colors for the segments.\n        \"\"\"\n        self._colors = colors\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        positions: TransBuf | None = None,\n        line_widths: TransBuf | None = None,\n        cap_style: CapStyle | None = None,\n        colors: TransBuf | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if positions is not None:\n            self._positions = positions\n        if line_widths is not None:\n            self._line_widths = line_widths\n        if cap_style is not None:\n            self._cap_style = cap_style\n        if colors is not None:\n            self._colors = colors\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._positions, self._line_widths, self._cap_style, self._colors)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(positions: Buffer, line_widths: Buffer, cap_style: CapStyle, colors: Buffer) -&gt; None:\n        \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(line_widths, Buffer), \"Line widths must be a Buffer\"\n        assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n\n        Segments.sanity_check_attributes(positions, line_widths, cap_style, colors)\n\n    @staticmethod\n    def sanity_check_attributes(\n        positions: TransBuf,\n        line_widths: TransBuf,\n        cap_style: CapStyle,\n        colors: TransBuf,\n    ) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\n\n        Args:\n            positions: Positions of the segment endpoints.\n            line_widths: Widths of the line segments.\n            cap_style: Cap style for the line segments.\n            colors: Colors of the segments.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.__init__","title":"<code>__init__(positions: TransBuf, line_widths: TransBuf, cap_style: CapStyle, colors: TransBuf) -&gt; None</code>","text":"<p>Initialize Segments visual.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the segment endpoints.</p> required <code>line_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Widths of the line segments.</p> required <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>Cap style for the line segments.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Colors of the segments.</p> required Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def __init__(self, positions: TransBuf, line_widths: TransBuf, cap_style: CapStyle, colors: TransBuf) -&gt; None:\n    \"\"\"Initialize Segments visual.\n\n    Args:\n        positions: Positions of the segment endpoints.\n        line_widths: Widths of the line segments.\n        cap_style: Cap style for the line segments.\n        colors: Colors of the segments.\n    \"\"\"\n    super().__init__()\n\n    self._positions: TransBuf = positions\n    self._line_widths: TransBuf = line_widths\n    self._cap_style: CapStyle = cap_style\n    self._colors: TransBuf = colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._positions, self._line_widths, self._cap_style, self._colors)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.get_cap_style","title":"<code>get_cap_style() -&gt; CapStyle</code>","text":"<p>Get cap style of the segments.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def get_cap_style(self) -&gt; CapStyle:\n    \"\"\"Get cap style of the segments.\"\"\"\n    return self._cap_style\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.get_colors","title":"<code>get_colors() -&gt; TransBuf</code>","text":"<p>Get colors of the segments.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def get_colors(self) -&gt; TransBuf:\n    \"\"\"Get colors of the segments.\"\"\"\n    return self._colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.get_line_widths","title":"<code>get_line_widths() -&gt; TransBuf</code>","text":"<p>Get line widths of the segments.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def get_line_widths(self) -&gt; TransBuf:\n    \"\"\"Get line widths of the segments.\"\"\"\n    return self._line_widths\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.get_positions","title":"<code>get_positions() -&gt; TransBuf</code>","text":"<p>Get positions of the segment endpoints.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def get_positions(self) -&gt; TransBuf:\n    \"\"\"Get positions of the segment endpoints.\"\"\"\n    return self._positions\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.sanity_check_attributes","title":"<code>sanity_check_attributes(positions: TransBuf, line_widths: TransBuf, cap_style: CapStyle, colors: TransBuf) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Check that the attributes are valid and consistent.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the segment endpoints.</p> required <code>line_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Widths of the line segments.</p> required <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>Cap style for the line segments.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Colors of the segments.</p> required Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes(\n    positions: TransBuf,\n    line_widths: TransBuf,\n    cap_style: CapStyle,\n    colors: TransBuf,\n) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\n\n    Args:\n        positions: Positions of the segment endpoints.\n        line_widths: Widths of the line segments.\n        cap_style: Cap style for the line segments.\n        colors: Colors of the segments.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(positions: Buffer, line_widths: Buffer, cap_style: CapStyle, colors: Buffer) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(positions: Buffer, line_widths: Buffer, cap_style: CapStyle, colors: Buffer) -&gt; None:\n    \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(line_widths, Buffer), \"Line widths must be a Buffer\"\n    assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n\n    Segments.sanity_check_attributes(positions, line_widths, cap_style, colors)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, line_widths: TransBuf | None = None, cap_style: CapStyle | None = None, colors: TransBuf | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def set_attributes(\n    self,\n    positions: TransBuf | None = None,\n    line_widths: TransBuf | None = None,\n    cap_style: CapStyle | None = None,\n    colors: TransBuf | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if positions is not None:\n        self._positions = positions\n    if line_widths is not None:\n        self._line_widths = line_widths\n    if cap_style is not None:\n        self._cap_style = cap_style\n    if colors is not None:\n        self._colors = colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.set_cap_style","title":"<code>set_cap_style(cap_style: CapStyle) -&gt; None</code>","text":"<p>Set cap style of the segments.</p> <p>Parameters:</p> Name Type Description Default <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>New cap style for the segments.</p> required Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def set_cap_style(self, cap_style: CapStyle) -&gt; None:\n    \"\"\"Set cap style of the segments.\n\n    Args:\n        cap_style: New cap style for the segments.\n    \"\"\"\n    self._cap_style = cap_style\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.set_colors","title":"<code>set_colors(colors: TransBuf) -&gt; None</code>","text":"<p>Set colors of the segments.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>New colors for the segments.</p> required Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def set_colors(self, colors: TransBuf) -&gt; None:\n    \"\"\"Set colors of the segments.\n\n    Args:\n        colors: New colors for the segments.\n    \"\"\"\n    self._colors = colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.set_line_widths","title":"<code>set_line_widths(line_widths: TransBuf) -&gt; None</code>","text":"<p>Set line widths of the segments.</p> <p>Parameters:</p> Name Type Description Default <code>line_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>New line widths for the segments.</p> required Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def set_line_widths(self, line_widths: TransBuf) -&gt; None:\n    \"\"\"Set line widths of the segments.\n\n    Args:\n        line_widths: New line widths for the segments.\n    \"\"\"\n    self._line_widths = line_widths\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.segments.Segments.set_positions","title":"<code>set_positions(positions: TransBuf) -&gt; None</code>","text":"<p>Set positions of the segment endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>New positions for the segments.</p> required Source code in <code>src/gsp/visuals/segments.py</code> <pre><code>def set_positions(self, positions: TransBuf) -&gt; None:\n    \"\"\"Set positions of the segment endpoints.\n\n    Args:\n        positions: New positions for the segments.\n    \"\"\"\n    self._positions = positions\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths","title":"<code>gsp.visuals.paths</code>","text":"<p>Path rendering visual for drawing connected line segments.</p> <p>This module provides the Paths visual class for rendering continuous paths with customizable line widths, colors, cap styles, and join styles.</p>"},{"location":"api/gsp/#gsp.visuals.paths.Paths","title":"<code>Paths</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> <p>Visual for rendering continuous paths with customizable styling.</p> <p>Paths are sequences of connected line segments that can have varying colors, line widths, and end/join styling.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>class Paths(VisualBase):\n    \"\"\"Visual for rendering continuous paths with customizable styling.\n\n    Paths are sequences of connected line segments that can have varying\n    colors, line widths, and end/join styling.\n    \"\"\"\n\n    __slots__ = [\"_positions\", \"_path_sizes\", \"_colors\", \"_line_widths\", \"_cap_style\", \"_join_style\"]\n\n    def __init__(self, positions: TransBuf, path_sizes: TransBuf, colors: TransBuf, line_widths: TransBuf, cap_style: CapStyle, join_style: JoinStyle) -&gt; None:\n        \"\"\"Initialize the Paths visual.\n\n        Args:\n            positions (TransBuf): 3D positions for all path vertices.\n            path_sizes (TransBuf): Number of vertices in each path.\n            colors (TransBuf): RGBA colors for each path.\n            line_widths (TransBuf): Line widths for each path.\n            cap_style (CapStyle): Style for line endings (round, square, butt).\n            join_style (JoinStyle): Style for line joins (miter, bevel, round).\n        \"\"\"\n        super().__init__()\n\n        self._positions: TransBuf = positions\n        self._path_sizes: TransBuf = path_sizes\n        self._colors: TransBuf = colors\n        self._line_widths: TransBuf = line_widths\n        self._cap_style: CapStyle = cap_style\n        self._join_style: JoinStyle = join_style\n        self.check_attributes()\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        \"\"\"Get the positions buffer.\n\n        Returns:\n            TransBuf: 3D positions for all path vertices.\n        \"\"\"\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        \"\"\"Set the positions buffer.\n\n        Args:\n            positions (TransBuf): 3D positions for all path vertices.\n        \"\"\"\n        self._positions = positions\n        self.check_attributes()\n\n    def get_path_sizes(self) -&gt; TransBuf:\n        \"\"\"Get the path sizes buffer.\n\n        Returns:\n            TransBuf: Number of vertices in each path.\n        \"\"\"\n        return self._path_sizes\n\n    def set_path_sizes(self, path_sizes: TransBuf) -&gt; None:\n        \"\"\"Set the path sizes buffer.\n\n        Args:\n            path_sizes (TransBuf): Number of vertices in each path.\n        \"\"\"\n        self._path_sizes = path_sizes\n        self.check_attributes()\n\n    def get_colors(self) -&gt; TransBuf:\n        \"\"\"Get the colors buffer.\n\n        Returns:\n            TransBuf: RGBA colors for each path.\n        \"\"\"\n        return self._colors\n\n    def set_colors(self, colors: TransBuf) -&gt; None:\n        \"\"\"Set the colors buffer.\n\n        Args:\n            colors (TransBuf): RGBA colors for each path.\n        \"\"\"\n        self._colors = colors\n        self.check_attributes()\n\n    def get_line_widths(self) -&gt; TransBuf:\n        \"\"\"Get the line widths buffer.\n\n        Returns:\n            TransBuf: Line widths for each path.\n        \"\"\"\n        return self._line_widths\n\n    def set_line_widths(self, line_widths: TransBuf) -&gt; None:\n        \"\"\"Set the line widths buffer.\n\n        Args:\n            line_widths (TransBuf): Line widths for each path.\n        \"\"\"\n        self._line_widths = line_widths\n        self.check_attributes()\n\n    def get_join_style(self) -&gt; JoinStyle:\n        \"\"\"Get the join style.\n\n        Returns:\n            JoinStyle: Style for line joins (miter, bevel, round).\n        \"\"\"\n        return self._join_style\n\n    def set_join_style(self, join_style: JoinStyle) -&gt; None:\n        \"\"\"Set the join style.\n\n        Args:\n            join_style (JoinStyle): Style for line joins (miter, bevel, round).\n        \"\"\"\n        self._join_style = join_style\n        self.check_attributes()\n\n    def get_cap_style(self) -&gt; CapStyle:\n        \"\"\"Get the cap style.\n\n        Returns:\n            CapStyle: Style for line endings (round, square, butt).\n        \"\"\"\n        return self._cap_style\n\n    def set_cap_style(self, cap_style: CapStyle) -&gt; None:\n        \"\"\"Set the cap style.\n\n        Args:\n            cap_style (CapStyle): Style for line endings (round, square, butt).\n        \"\"\"\n        self._cap_style = cap_style\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        positions: TransBuf | None = None,\n        path_sizes: TransBuf | None = None,\n        colors: TransBuf | None = None,\n        line_widths: TransBuf | None = None,\n        cap_style: CapStyle | None = None,\n        join_style: JoinStyle | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\n\n        Args:\n            positions (TransBuf | None, optional): 3D positions for all path vertices.\n            path_sizes (TransBuf | None, optional): Number of vertices in each path.\n            colors (TransBuf | None, optional): RGBA colors for each path.\n            line_widths (TransBuf | None, optional): Line widths for each path.\n            cap_style (CapStyle | None, optional): Style for line endings (round, square, butt).\n            join_style (JoinStyle | None, optional): Style for line joins (miter, bevel, round).\n        \"\"\"\n        if positions is not None:\n            self._positions = positions\n        if path_sizes is not None:\n            self._path_sizes = path_sizes\n        if colors is not None:\n            self._colors = colors\n        if line_widths is not None:\n            self._line_widths = line_widths\n        if cap_style is not None:\n            self._cap_style = cap_style\n        if join_style is not None:\n            self._join_style = join_style\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._positions, self._path_sizes, self._colors, self._line_widths, self._cap_style, self._join_style)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(\n        positions: Buffer, path_sizes: Buffer, colors: Buffer, line_widths: Buffer, cap_style: CapStyle, join_style: JoinStyle\n    ) -&gt; None:\n        \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n        It is meant to be used after converting TransBuf to Buffer.\n\n        Args:\n            positions (Buffer): 3D positions for all path vertices.\n            path_sizes (Buffer): Number of vertices in each path.\n            colors (Buffer): RGBA colors for each path.\n            line_widths (Buffer): Line widths for each path.\n            cap_style (CapStyle): Style for line endings.\n            join_style (JoinStyle): Style for line joins.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(path_sizes, Buffer), \"Path sizes must be a Buffer\"\n        assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n        assert isinstance(line_widths, Buffer), \"Line widths must be a Buffer\"\n\n        Paths.sanity_check_attributes(positions, path_sizes, colors, line_widths, cap_style, join_style)\n\n    @staticmethod\n    def sanity_check_attributes(\n        positions: TransBuf,\n        path_sizes: TransBuf,\n        colors: TransBuf,\n        line_widths: TransBuf,\n        cap_style: CapStyle,\n        join_style: JoinStyle,\n    ) -&gt; None:\n        \"\"\"Validate attribute dimensions and compatibility.\n\n        Args:\n            positions (TransBuf): 3D positions for all path vertices.\n            path_sizes (TransBuf): Number of vertices in each path.\n            colors (TransBuf): RGBA colors for each path.\n            line_widths (TransBuf): Line widths for each path.\n            cap_style (CapStyle): Style for line endings.\n            join_style (JoinStyle): Style for line joins.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.__init__","title":"<code>__init__(positions: TransBuf, path_sizes: TransBuf, colors: TransBuf, line_widths: TransBuf, cap_style: CapStyle, join_style: JoinStyle) -&gt; None</code>","text":"<p>Initialize the Paths visual.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>3D positions for all path vertices.</p> required <code>path_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Number of vertices in each path.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>RGBA colors for each path.</p> required <code>line_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Line widths for each path.</p> required <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>Style for line endings (round, square, butt).</p> required <code>join_style</code> <code>gsp.types.join_style.JoinStyle</code> <p>Style for line joins (miter, bevel, round).</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def __init__(self, positions: TransBuf, path_sizes: TransBuf, colors: TransBuf, line_widths: TransBuf, cap_style: CapStyle, join_style: JoinStyle) -&gt; None:\n    \"\"\"Initialize the Paths visual.\n\n    Args:\n        positions (TransBuf): 3D positions for all path vertices.\n        path_sizes (TransBuf): Number of vertices in each path.\n        colors (TransBuf): RGBA colors for each path.\n        line_widths (TransBuf): Line widths for each path.\n        cap_style (CapStyle): Style for line endings (round, square, butt).\n        join_style (JoinStyle): Style for line joins (miter, bevel, round).\n    \"\"\"\n    super().__init__()\n\n    self._positions: TransBuf = positions\n    self._path_sizes: TransBuf = path_sizes\n    self._colors: TransBuf = colors\n    self._line_widths: TransBuf = line_widths\n    self._cap_style: CapStyle = cap_style\n    self._join_style: JoinStyle = join_style\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._positions, self._path_sizes, self._colors, self._line_widths, self._cap_style, self._join_style)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.get_cap_style","title":"<code>get_cap_style() -&gt; CapStyle</code>","text":"<p>Get the cap style.</p> <p>Returns:</p> Name Type Description <code>CapStyle</code> <code>gsp.types.cap_style.CapStyle</code> <p>Style for line endings (round, square, butt).</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def get_cap_style(self) -&gt; CapStyle:\n    \"\"\"Get the cap style.\n\n    Returns:\n        CapStyle: Style for line endings (round, square, butt).\n    \"\"\"\n    return self._cap_style\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.get_colors","title":"<code>get_colors() -&gt; TransBuf</code>","text":"<p>Get the colors buffer.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>RGBA colors for each path.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def get_colors(self) -&gt; TransBuf:\n    \"\"\"Get the colors buffer.\n\n    Returns:\n        TransBuf: RGBA colors for each path.\n    \"\"\"\n    return self._colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.get_join_style","title":"<code>get_join_style() -&gt; JoinStyle</code>","text":"<p>Get the join style.</p> <p>Returns:</p> Name Type Description <code>JoinStyle</code> <code>gsp.types.join_style.JoinStyle</code> <p>Style for line joins (miter, bevel, round).</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def get_join_style(self) -&gt; JoinStyle:\n    \"\"\"Get the join style.\n\n    Returns:\n        JoinStyle: Style for line joins (miter, bevel, round).\n    \"\"\"\n    return self._join_style\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.get_line_widths","title":"<code>get_line_widths() -&gt; TransBuf</code>","text":"<p>Get the line widths buffer.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>Line widths for each path.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def get_line_widths(self) -&gt; TransBuf:\n    \"\"\"Get the line widths buffer.\n\n    Returns:\n        TransBuf: Line widths for each path.\n    \"\"\"\n    return self._line_widths\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.get_path_sizes","title":"<code>get_path_sizes() -&gt; TransBuf</code>","text":"<p>Get the path sizes buffer.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>Number of vertices in each path.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def get_path_sizes(self) -&gt; TransBuf:\n    \"\"\"Get the path sizes buffer.\n\n    Returns:\n        TransBuf: Number of vertices in each path.\n    \"\"\"\n    return self._path_sizes\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.get_positions","title":"<code>get_positions() -&gt; TransBuf</code>","text":"<p>Get the positions buffer.</p> <p>Returns:</p> Name Type Description <code>TransBuf</code> <code>gsp.types.transbuf.TransBuf</code> <p>3D positions for all path vertices.</p> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def get_positions(self) -&gt; TransBuf:\n    \"\"\"Get the positions buffer.\n\n    Returns:\n        TransBuf: 3D positions for all path vertices.\n    \"\"\"\n    return self._positions\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.sanity_check_attributes","title":"<code>sanity_check_attributes(positions: TransBuf, path_sizes: TransBuf, colors: TransBuf, line_widths: TransBuf, cap_style: CapStyle, join_style: JoinStyle) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Validate attribute dimensions and compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>3D positions for all path vertices.</p> required <code>path_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Number of vertices in each path.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>RGBA colors for each path.</p> required <code>line_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Line widths for each path.</p> required <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>Style for line endings.</p> required <code>join_style</code> <code>gsp.types.join_style.JoinStyle</code> <p>Style for line joins.</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes(\n    positions: TransBuf,\n    path_sizes: TransBuf,\n    colors: TransBuf,\n    line_widths: TransBuf,\n    cap_style: CapStyle,\n    join_style: JoinStyle,\n) -&gt; None:\n    \"\"\"Validate attribute dimensions and compatibility.\n\n    Args:\n        positions (TransBuf): 3D positions for all path vertices.\n        path_sizes (TransBuf): Number of vertices in each path.\n        colors (TransBuf): RGBA colors for each path.\n        line_widths (TransBuf): Line widths for each path.\n        cap_style (CapStyle): Style for line endings.\n        join_style (JoinStyle): Style for line joins.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(positions: Buffer, path_sizes: Buffer, colors: Buffer, line_widths: Buffer, cap_style: CapStyle, join_style: JoinStyle) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Same as .sanity_check_attributes() but accept only Buffers.</p> <p>It is meant to be used after converting TransBuf to Buffer.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.buffer.Buffer</code> <p>3D positions for all path vertices.</p> required <code>path_sizes</code> <code>gsp.types.buffer.Buffer</code> <p>Number of vertices in each path.</p> required <code>colors</code> <code>gsp.types.buffer.Buffer</code> <p>RGBA colors for each path.</p> required <code>line_widths</code> <code>gsp.types.buffer.Buffer</code> <p>Line widths for each path.</p> required <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>Style for line endings.</p> required <code>join_style</code> <code>gsp.types.join_style.JoinStyle</code> <p>Style for line joins.</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(\n    positions: Buffer, path_sizes: Buffer, colors: Buffer, line_widths: Buffer, cap_style: CapStyle, join_style: JoinStyle\n) -&gt; None:\n    \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n    It is meant to be used after converting TransBuf to Buffer.\n\n    Args:\n        positions (Buffer): 3D positions for all path vertices.\n        path_sizes (Buffer): Number of vertices in each path.\n        colors (Buffer): RGBA colors for each path.\n        line_widths (Buffer): Line widths for each path.\n        cap_style (CapStyle): Style for line endings.\n        join_style (JoinStyle): Style for line joins.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(path_sizes, Buffer), \"Path sizes must be a Buffer\"\n    assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n    assert isinstance(line_widths, Buffer), \"Line widths must be a Buffer\"\n\n    Paths.sanity_check_attributes(positions, path_sizes, colors, line_widths, cap_style, join_style)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, path_sizes: TransBuf | None = None, colors: TransBuf | None = None, line_widths: TransBuf | None = None, cap_style: CapStyle | None = None, join_style: JoinStyle | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf | None</code> <p>3D positions for all path vertices.</p> <code>None</code> <code>path_sizes</code> <code>gsp.types.transbuf.TransBuf | None</code> <p>Number of vertices in each path.</p> <code>None</code> <code>colors</code> <code>gsp.types.transbuf.TransBuf | None</code> <p>RGBA colors for each path.</p> <code>None</code> <code>line_widths</code> <code>gsp.types.transbuf.TransBuf | None</code> <p>Line widths for each path.</p> <code>None</code> <code>cap_style</code> <code>gsp.types.cap_style.CapStyle | None</code> <p>Style for line endings (round, square, butt).</p> <code>None</code> <code>join_style</code> <code>gsp.types.join_style.JoinStyle | None</code> <p>Style for line joins (miter, bevel, round).</p> <code>None</code> Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_attributes(\n    self,\n    positions: TransBuf | None = None,\n    path_sizes: TransBuf | None = None,\n    colors: TransBuf | None = None,\n    line_widths: TransBuf | None = None,\n    cap_style: CapStyle | None = None,\n    join_style: JoinStyle | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\n\n    Args:\n        positions (TransBuf | None, optional): 3D positions for all path vertices.\n        path_sizes (TransBuf | None, optional): Number of vertices in each path.\n        colors (TransBuf | None, optional): RGBA colors for each path.\n        line_widths (TransBuf | None, optional): Line widths for each path.\n        cap_style (CapStyle | None, optional): Style for line endings (round, square, butt).\n        join_style (JoinStyle | None, optional): Style for line joins (miter, bevel, round).\n    \"\"\"\n    if positions is not None:\n        self._positions = positions\n    if path_sizes is not None:\n        self._path_sizes = path_sizes\n    if colors is not None:\n        self._colors = colors\n    if line_widths is not None:\n        self._line_widths = line_widths\n    if cap_style is not None:\n        self._cap_style = cap_style\n    if join_style is not None:\n        self._join_style = join_style\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_cap_style","title":"<code>set_cap_style(cap_style: CapStyle) -&gt; None</code>","text":"<p>Set the cap style.</p> <p>Parameters:</p> Name Type Description Default <code>cap_style</code> <code>gsp.types.cap_style.CapStyle</code> <p>Style for line endings (round, square, butt).</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_cap_style(self, cap_style: CapStyle) -&gt; None:\n    \"\"\"Set the cap style.\n\n    Args:\n        cap_style (CapStyle): Style for line endings (round, square, butt).\n    \"\"\"\n    self._cap_style = cap_style\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_colors","title":"<code>set_colors(colors: TransBuf) -&gt; None</code>","text":"<p>Set the colors buffer.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>RGBA colors for each path.</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_colors(self, colors: TransBuf) -&gt; None:\n    \"\"\"Set the colors buffer.\n\n    Args:\n        colors (TransBuf): RGBA colors for each path.\n    \"\"\"\n    self._colors = colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_join_style","title":"<code>set_join_style(join_style: JoinStyle) -&gt; None</code>","text":"<p>Set the join style.</p> <p>Parameters:</p> Name Type Description Default <code>join_style</code> <code>gsp.types.join_style.JoinStyle</code> <p>Style for line joins (miter, bevel, round).</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_join_style(self, join_style: JoinStyle) -&gt; None:\n    \"\"\"Set the join style.\n\n    Args:\n        join_style (JoinStyle): Style for line joins (miter, bevel, round).\n    \"\"\"\n    self._join_style = join_style\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_line_widths","title":"<code>set_line_widths(line_widths: TransBuf) -&gt; None</code>","text":"<p>Set the line widths buffer.</p> <p>Parameters:</p> Name Type Description Default <code>line_widths</code> <code>gsp.types.transbuf.TransBuf</code> <p>Line widths for each path.</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_line_widths(self, line_widths: TransBuf) -&gt; None:\n    \"\"\"Set the line widths buffer.\n\n    Args:\n        line_widths (TransBuf): Line widths for each path.\n    \"\"\"\n    self._line_widths = line_widths\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_path_sizes","title":"<code>set_path_sizes(path_sizes: TransBuf) -&gt; None</code>","text":"<p>Set the path sizes buffer.</p> <p>Parameters:</p> Name Type Description Default <code>path_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Number of vertices in each path.</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_path_sizes(self, path_sizes: TransBuf) -&gt; None:\n    \"\"\"Set the path sizes buffer.\n\n    Args:\n        path_sizes (TransBuf): Number of vertices in each path.\n    \"\"\"\n    self._path_sizes = path_sizes\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.paths.Paths.set_positions","title":"<code>set_positions(positions: TransBuf) -&gt; None</code>","text":"<p>Set the positions buffer.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>3D positions for all path vertices.</p> required Source code in <code>src/gsp/visuals/paths.py</code> <pre><code>def set_positions(self, positions: TransBuf) -&gt; None:\n    \"\"\"Set the positions buffer.\n\n    Args:\n        positions (TransBuf): 3D positions for all path vertices.\n    \"\"\"\n    self._positions = positions\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels","title":"<code>gsp.visuals.pixels</code>","text":"<p>Pixels visual module.</p>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels","title":"<code>Pixels</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> <p>Pixels visual for rendering individual colored pixels.</p> <p>This visual represents a collection of pixels with configurable positions, colors, and groups for efficient rendering.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>class Pixels(VisualBase):\n    \"\"\"Pixels visual for rendering individual colored pixels.\n\n    This visual represents a collection of pixels with configurable positions,\n    colors, and groups for efficient rendering.\n    \"\"\"\n    __slots__ = [\"__positions\", \"__colors\", \"__groups\"]\n\n    def __init__(self, positions: TransBuf, colors: TransBuf, groups: Groups):\n        \"\"\"Initialize Pixels visual.\n\n        Args:\n            positions: Positions of the pixels.\n            colors: Colors of the pixels.\n            groups: Groups for organizing pixels.\n        \"\"\"\n        super().__init__()\n\n        self.__positions: TransBuf = positions\n        self.__colors: TransBuf = colors\n        self.__groups: Groups = groups\n\n        self.check_attributes()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return string representation of the Pixels visual.\"\"\"\n        return f\"Pixels(positions={self.__positions}, colors={self.__colors}, groups={self.__groups})\"\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        \"\"\"Get positions of the pixels.\"\"\"\n        return self.__positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        \"\"\"Set positions of the pixels.\n\n        Args:\n            positions: New positions for the pixels.\n        \"\"\"\n        self.__positions = positions\n        self.check_attributes()\n\n    def get_colors(self) -&gt; TransBuf:\n        \"\"\"Get colors of the pixels.\"\"\"\n        return self.__colors\n\n    def set_colors(self, colors: TransBuf) -&gt; None:\n        \"\"\"Set colors of the pixels.\n\n        Args:\n            colors: New colors for the pixels.\n        \"\"\"\n        self.__colors = colors\n        self.check_attributes()\n\n    def get_groups(self) -&gt; Groups:\n        \"\"\"Get groups for organizing pixels.\"\"\"\n        return self.__groups\n\n    def set_groups(self, groups: Groups) -&gt; None:\n        \"\"\"Set groups for organizing pixels.\n\n        Args:\n            groups: New groups for the pixels.\n        \"\"\"\n        self.__groups = groups\n        self.check_attributes()\n\n    def set_attributes(self, positions: TransBuf | None = None, colors: TransBuf | None = None, groups: Groups | None = None) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if positions is not None:\n            self.__positions = positions\n        if colors is not None:\n            self.__colors = colors\n        if groups is not None:\n            self.__groups = groups\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self.__positions, self.__colors, self.__groups)\n\n    @staticmethod\n    def sanity_check_attribute_buffers(positions: Buffer, colors: Buffer, groups: Groups):\n        \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n\n        Pixels.sanity_check_attributes(positions, colors, groups)\n\n    @staticmethod\n    def sanity_check_attributes(positions: TransBuf, colors: TransBuf, groups: Groups):\n        \"\"\"Check that the attributes are valid and consistent.\n\n        Args:\n            positions: Positions of the pixels.\n            colors: Colors of the pixels.\n            groups: Groups for organizing pixels.\n        \"\"\"\n        # =============================================================================\n        # if any of the attributes is a TransformChain not fully defined, skip the sanity check\n        # =============================================================================\n\n        if isinstance(positions, TransformChain) and not positions.is_fully_defined():\n            return\n        if isinstance(colors, TransformChain) and not colors.is_fully_defined():\n            return\n\n        # =============================================================================\n        # Check groups\n        # =============================================================================\n\n        # get position_count and group_count\n        position_count = positions.get_count() if isinstance(positions, Buffer) else positions.get_buffer_count()\n        group_count = GroupUtils.get_group_count(position_count, groups)\n\n        # Check groups matches position count\n        GroupUtils.sanity_check(position_count, groups)\n\n        # =============================================================================\n        # Check each attributes\n        # =============================================================================\n\n        # Check colors attribute\n        color_count = colors.get_count() if isinstance(colors, Buffer) else colors.get_buffer_count()\n        assert color_count == group_count, f\"Colors count {color_count} must match group count {group_count}\"\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.__init__","title":"<code>__init__(positions: TransBuf, colors: TransBuf, groups: Groups)</code>","text":"<p>Initialize Pixels visual.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the pixels.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Colors of the pixels.</p> required <code>groups</code> <code>gsp.types.group.Groups</code> <p>Groups for organizing pixels.</p> required Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def __init__(self, positions: TransBuf, colors: TransBuf, groups: Groups):\n    \"\"\"Initialize Pixels visual.\n\n    Args:\n        positions: Positions of the pixels.\n        colors: Colors of the pixels.\n        groups: Groups for organizing pixels.\n    \"\"\"\n    super().__init__()\n\n    self.__positions: TransBuf = positions\n    self.__colors: TransBuf = colors\n    self.__groups: Groups = groups\n\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return string representation of the Pixels visual.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return string representation of the Pixels visual.\"\"\"\n    return f\"Pixels(positions={self.__positions}, colors={self.__colors}, groups={self.__groups})\"\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self.__positions, self.__colors, self.__groups)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.get_colors","title":"<code>get_colors() -&gt; TransBuf</code>","text":"<p>Get colors of the pixels.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def get_colors(self) -&gt; TransBuf:\n    \"\"\"Get colors of the pixels.\"\"\"\n    return self.__colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.get_groups","title":"<code>get_groups() -&gt; Groups</code>","text":"<p>Get groups for organizing pixels.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def get_groups(self) -&gt; Groups:\n    \"\"\"Get groups for organizing pixels.\"\"\"\n    return self.__groups\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.get_positions","title":"<code>get_positions() -&gt; TransBuf</code>","text":"<p>Get positions of the pixels.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def get_positions(self) -&gt; TransBuf:\n    \"\"\"Get positions of the pixels.\"\"\"\n    return self.__positions\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.sanity_check_attribute_buffers","title":"<code>sanity_check_attribute_buffers(positions: Buffer, colors: Buffer, groups: Groups)</code>  <code>staticmethod</code>","text":"<p>Same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>@staticmethod\ndef sanity_check_attribute_buffers(positions: Buffer, colors: Buffer, groups: Groups):\n    \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n\n    Pixels.sanity_check_attributes(positions, colors, groups)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.sanity_check_attributes","title":"<code>sanity_check_attributes(positions: TransBuf, colors: TransBuf, groups: Groups)</code>  <code>staticmethod</code>","text":"<p>Check that the attributes are valid and consistent.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the pixels.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Colors of the pixels.</p> required <code>groups</code> <code>gsp.types.group.Groups</code> <p>Groups for organizing pixels.</p> required Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes(positions: TransBuf, colors: TransBuf, groups: Groups):\n    \"\"\"Check that the attributes are valid and consistent.\n\n    Args:\n        positions: Positions of the pixels.\n        colors: Colors of the pixels.\n        groups: Groups for organizing pixels.\n    \"\"\"\n    # =============================================================================\n    # if any of the attributes is a TransformChain not fully defined, skip the sanity check\n    # =============================================================================\n\n    if isinstance(positions, TransformChain) and not positions.is_fully_defined():\n        return\n    if isinstance(colors, TransformChain) and not colors.is_fully_defined():\n        return\n\n    # =============================================================================\n    # Check groups\n    # =============================================================================\n\n    # get position_count and group_count\n    position_count = positions.get_count() if isinstance(positions, Buffer) else positions.get_buffer_count()\n    group_count = GroupUtils.get_group_count(position_count, groups)\n\n    # Check groups matches position count\n    GroupUtils.sanity_check(position_count, groups)\n\n    # =============================================================================\n    # Check each attributes\n    # =============================================================================\n\n    # Check colors attribute\n    color_count = colors.get_count() if isinstance(colors, Buffer) else colors.get_buffer_count()\n    assert color_count == group_count, f\"Colors count {color_count} must match group count {group_count}\"\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, colors: TransBuf | None = None, groups: Groups | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def set_attributes(self, positions: TransBuf | None = None, colors: TransBuf | None = None, groups: Groups | None = None) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if positions is not None:\n        self.__positions = positions\n    if colors is not None:\n        self.__colors = colors\n    if groups is not None:\n        self.__groups = groups\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.set_colors","title":"<code>set_colors(colors: TransBuf) -&gt; None</code>","text":"<p>Set colors of the pixels.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>New colors for the pixels.</p> required Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def set_colors(self, colors: TransBuf) -&gt; None:\n    \"\"\"Set colors of the pixels.\n\n    Args:\n        colors: New colors for the pixels.\n    \"\"\"\n    self.__colors = colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.set_groups","title":"<code>set_groups(groups: Groups) -&gt; None</code>","text":"<p>Set groups for organizing pixels.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>gsp.types.group.Groups</code> <p>New groups for the pixels.</p> required Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def set_groups(self, groups: Groups) -&gt; None:\n    \"\"\"Set groups for organizing pixels.\n\n    Args:\n        groups: New groups for the pixels.\n    \"\"\"\n    self.__groups = groups\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.pixels.Pixels.set_positions","title":"<code>set_positions(positions: TransBuf) -&gt; None</code>","text":"<p>Set positions of the pixels.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>New positions for the pixels.</p> required Source code in <code>src/gsp/visuals/pixels.py</code> <pre><code>def set_positions(self, positions: TransBuf) -&gt; None:\n    \"\"\"Set positions of the pixels.\n\n    Args:\n        positions: New positions for the pixels.\n    \"\"\"\n    self.__positions = positions\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts","title":"<code>gsp.visuals.texts</code>","text":"<p>\"Texts visual module.</p>"},{"location":"api/gsp/#gsp.visuals.texts.Texts","title":"<code>Texts</code>","text":"<p>               Bases: <code>gsp.types.visual_base.VisualBase</code></p> <p>Texts visual.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>class Texts(VisualBase):\n    \"\"\"Texts visual.\"\"\"\n    __slots__ = [\"_positions\", \"_strings\", \"_colors\", \"_font_sizes\", \"_anchors\", \"_angles\", \"_font_name\"]\n\n    def __init__(\n        self,\n        positions: TransBuf,\n        strings: list[str],\n        colors: TransBuf,\n        font_sizes: TransBuf,\n        anchors: TransBuf,\n        angles: TransBuf,\n        font_name: str,\n    ) -&gt; None:\n        \"\"\"Initialize Texts visual.\n\n        Args:\n            positions (TransBuf): Positions of the texts.\n            strings (list[str]): List of text strings.\n            colors (TransBuf): Colors of the texts.\n            font_sizes (TransBuf): Font sizes of the texts.\n            anchors (TransBuf): Anchor positions of the texts.\n            angles (TransBuf): Rotation angles of the texts.\n            font_name (str): Font name for the texts.\n        \"\"\"\n        super().__init__()\n\n        self._positions: TransBuf = positions\n        self._strings: list[str] = strings\n        self._colors: TransBuf = colors\n        self._font_sizes: TransBuf = font_sizes\n        self._anchors: TransBuf = anchors\n        self._angles: TransBuf = angles\n        self._font_name: str = font_name\n        self.check_attributes()\n\n    # =============================================================================\n    # get/set attributes\n    # =============================================================================\n\n    def get_positions(self) -&gt; TransBuf:\n        \"\"\"Get positions of the texts.\"\"\"\n        return self._positions\n\n    def set_positions(self, positions: TransBuf) -&gt; None:\n        \"\"\"Set positions of the texts.\n\n        Args:\n            positions: New positions for the texts.\n        \"\"\"\n        self._positions = positions\n        self.check_attributes()\n\n    def get_strings(self) -&gt; list[str]:\n        \"\"\"Get text strings.\"\"\"\n        return self._strings\n\n    def set_strings(self, strings: list[str]) -&gt; None:\n        \"\"\"Set text strings.\n\n        Args:\n            strings: New text strings.\n        \"\"\"\n        self._strings = strings\n        self.check_attributes()\n\n    def get_colors(self) -&gt; TransBuf:\n        \"\"\"Get colors of the texts.\"\"\"\n        return self._colors\n\n    def set_colors(self, colors: TransBuf) -&gt; None:\n        \"\"\"Set colors of the texts.\n\n        Args:\n            colors: New colors for the texts.\n        \"\"\"\n        self._colors = colors\n        self.check_attributes()\n\n    def get_font_sizes(self) -&gt; TransBuf:\n        \"\"\"Get font sizes of the texts.\"\"\"\n        return self._font_sizes\n\n    def set_font_sizes(self, font_sizes: TransBuf) -&gt; None:\n        \"\"\"Set font sizes of the texts.\n\n        Args:\n            font_sizes: New font sizes for the texts.\n        \"\"\"\n        self._font_sizes = font_sizes\n        self.check_attributes()\n\n    def get_anchors(self) -&gt; TransBuf:\n        \"\"\"Get anchor positions of the texts.\"\"\"\n        return self._anchors\n\n    def set_anchors(self, anchors: TransBuf) -&gt; None:\n        \"\"\"Set anchor positions of the texts.\n\n        Args:\n            anchors: New anchor positions for the texts.\n        \"\"\"\n        self._anchors = anchors\n        self.check_attributes()\n\n    def get_angles(self) -&gt; TransBuf:\n        \"\"\"Get rotation angles of the texts.\"\"\"\n        return self._angles\n\n    def set_angles(self, angles: TransBuf) -&gt; None:\n        \"\"\"Set rotation angles of the texts.\n\n        Args:\n            angles: New rotation angles for the texts.\n        \"\"\"\n        self._angles = angles\n        self.check_attributes()\n\n    def get_font_name(self) -&gt; str:\n        \"\"\"Get font name used for the texts.\"\"\"\n        return self._font_name\n\n    def set_font_name(self, font_name: str) -&gt; None:\n        \"\"\"Set font name for the texts.\n\n        Args:\n            font_name: New font name for the texts.\n        \"\"\"\n        self._font_name = font_name\n        self.check_attributes()\n\n    def set_attributes(\n        self,\n        positions: TransBuf | None = None,\n        texts: list[str] | None = None,\n        colors: TransBuf | None = None,\n        font_sizes: TransBuf | None = None,\n        anchors: TransBuf | None = None,\n        angles: TransBuf | None = None,\n        font_name: str | None = None,\n    ) -&gt; None:\n        \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n        if positions is not None:\n            self._positions = positions\n        if texts is not None:\n            self._strings = texts\n        if colors is not None:\n            self._colors = colors\n        if font_sizes is not None:\n            self._font_sizes = font_sizes\n        if anchors is not None:\n            self._anchors = anchors\n        if angles is not None:\n            self._angles = angles\n        if font_name is not None:\n            self._font_name = font_name\n        self.check_attributes()\n\n    # =============================================================================\n    # Sanity check functions\n    # =============================================================================\n\n    def check_attributes(self) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\"\"\"\n        self.sanity_check_attributes(self._positions, self._strings, self._colors, self._font_sizes, self._anchors, self._angles, self._font_name)\n\n    @staticmethod\n    def sanity_check_attributes_buffer(\n        positions: Buffer, texts: list[str], colors: Buffer, font_sizes: Buffer, anchors: Buffer, angles: Buffer, font_name: str\n    ) -&gt; None:\n        \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n        - It is meant to be used after converting TransBuf to Buffer.\n        \"\"\"\n        # sanity check - each attribute must be a Buffer (not a transform chain)\n        assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n        assert isinstance(texts, list), \"Texts must be a list of strings\"\n        assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n        assert isinstance(font_sizes, Buffer), \"Font sizes must be a Buffer\"\n        assert isinstance(anchors, Buffer), \"Anchors must be a Buffer\"\n        assert isinstance(angles, Buffer), \"Angles must be a Buffer\"\n        assert isinstance(font_name, str), \"Font name must be a string\"\n\n        Texts.sanity_check_attributes(positions, texts, colors, font_sizes, anchors, angles, font_name)\n\n    @staticmethod\n    def sanity_check_attributes(\n        positions: TransBuf,\n        texts: list[str],\n        colors: TransBuf,\n        font_sizes: TransBuf,\n        anchors: TransBuf,\n        angles: TransBuf,\n        font_name: str,\n    ) -&gt; None:\n        \"\"\"Check that the attributes are valid and consistent.\n\n        Args:\n            positions: Positions of the texts.\n            texts: List of text strings.\n            colors: Colors of the texts.\n            font_sizes: Font sizes of the texts.\n            anchors: Anchor positions of the texts.\n            angles: Rotation angles of the texts.\n            font_name: Font name for the texts.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.__init__","title":"<code>__init__(positions: TransBuf, strings: list[str], colors: TransBuf, font_sizes: TransBuf, anchors: TransBuf, angles: TransBuf, font_name: str) -&gt; None</code>","text":"<p>Initialize Texts visual.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the texts.</p> required <code>strings</code> <code>list[str]</code> <p>List of text strings.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Colors of the texts.</p> required <code>font_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Font sizes of the texts.</p> required <code>anchors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Anchor positions of the texts.</p> required <code>angles</code> <code>gsp.types.transbuf.TransBuf</code> <p>Rotation angles of the texts.</p> required <code>font_name</code> <code>str</code> <p>Font name for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def __init__(\n    self,\n    positions: TransBuf,\n    strings: list[str],\n    colors: TransBuf,\n    font_sizes: TransBuf,\n    anchors: TransBuf,\n    angles: TransBuf,\n    font_name: str,\n) -&gt; None:\n    \"\"\"Initialize Texts visual.\n\n    Args:\n        positions (TransBuf): Positions of the texts.\n        strings (list[str]): List of text strings.\n        colors (TransBuf): Colors of the texts.\n        font_sizes (TransBuf): Font sizes of the texts.\n        anchors (TransBuf): Anchor positions of the texts.\n        angles (TransBuf): Rotation angles of the texts.\n        font_name (str): Font name for the texts.\n    \"\"\"\n    super().__init__()\n\n    self._positions: TransBuf = positions\n    self._strings: list[str] = strings\n    self._colors: TransBuf = colors\n    self._font_sizes: TransBuf = font_sizes\n    self._anchors: TransBuf = anchors\n    self._angles: TransBuf = angles\n    self._font_name: str = font_name\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.check_attributes","title":"<code>check_attributes() -&gt; None</code>","text":"<p>Check that the attributes are valid and consistent.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def check_attributes(self) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\"\"\"\n    self.sanity_check_attributes(self._positions, self._strings, self._colors, self._font_sizes, self._anchors, self._angles, self._font_name)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_anchors","title":"<code>get_anchors() -&gt; TransBuf</code>","text":"<p>Get anchor positions of the texts.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_anchors(self) -&gt; TransBuf:\n    \"\"\"Get anchor positions of the texts.\"\"\"\n    return self._anchors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_angles","title":"<code>get_angles() -&gt; TransBuf</code>","text":"<p>Get rotation angles of the texts.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_angles(self) -&gt; TransBuf:\n    \"\"\"Get rotation angles of the texts.\"\"\"\n    return self._angles\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_colors","title":"<code>get_colors() -&gt; TransBuf</code>","text":"<p>Get colors of the texts.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_colors(self) -&gt; TransBuf:\n    \"\"\"Get colors of the texts.\"\"\"\n    return self._colors\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_font_name","title":"<code>get_font_name() -&gt; str</code>","text":"<p>Get font name used for the texts.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_font_name(self) -&gt; str:\n    \"\"\"Get font name used for the texts.\"\"\"\n    return self._font_name\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_font_sizes","title":"<code>get_font_sizes() -&gt; TransBuf</code>","text":"<p>Get font sizes of the texts.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_font_sizes(self) -&gt; TransBuf:\n    \"\"\"Get font sizes of the texts.\"\"\"\n    return self._font_sizes\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_positions","title":"<code>get_positions() -&gt; TransBuf</code>","text":"<p>Get positions of the texts.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_positions(self) -&gt; TransBuf:\n    \"\"\"Get positions of the texts.\"\"\"\n    return self._positions\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.get_strings","title":"<code>get_strings() -&gt; list[str]</code>","text":"<p>Get text strings.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def get_strings(self) -&gt; list[str]:\n    \"\"\"Get text strings.\"\"\"\n    return self._strings\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.sanity_check_attributes","title":"<code>sanity_check_attributes(positions: TransBuf, texts: list[str], colors: TransBuf, font_sizes: TransBuf, anchors: TransBuf, angles: TransBuf, font_name: str) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Check that the attributes are valid and consistent.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>Positions of the texts.</p> required <code>texts</code> <code>list[str]</code> <p>List of text strings.</p> required <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Colors of the texts.</p> required <code>font_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>Font sizes of the texts.</p> required <code>anchors</code> <code>gsp.types.transbuf.TransBuf</code> <p>Anchor positions of the texts.</p> required <code>angles</code> <code>gsp.types.transbuf.TransBuf</code> <p>Rotation angles of the texts.</p> required <code>font_name</code> <code>str</code> <p>Font name for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes(\n    positions: TransBuf,\n    texts: list[str],\n    colors: TransBuf,\n    font_sizes: TransBuf,\n    anchors: TransBuf,\n    angles: TransBuf,\n    font_name: str,\n) -&gt; None:\n    \"\"\"Check that the attributes are valid and consistent.\n\n    Args:\n        positions: Positions of the texts.\n        texts: List of text strings.\n        colors: Colors of the texts.\n        font_sizes: Font sizes of the texts.\n        anchors: Anchor positions of the texts.\n        angles: Rotation angles of the texts.\n        font_name: Font name for the texts.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.sanity_check_attributes_buffer","title":"<code>sanity_check_attributes_buffer(positions: Buffer, texts: list[str], colors: Buffer, font_sizes: Buffer, anchors: Buffer, angles: Buffer, font_name: str) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Same as .sanity_check_attributes() but accept only Buffers.</p> <ul> <li>It is meant to be used after converting TransBuf to Buffer.</li> </ul> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>@staticmethod\ndef sanity_check_attributes_buffer(\n    positions: Buffer, texts: list[str], colors: Buffer, font_sizes: Buffer, anchors: Buffer, angles: Buffer, font_name: str\n) -&gt; None:\n    \"\"\"Same as .sanity_check_attributes() but accept only Buffers.\n\n    - It is meant to be used after converting TransBuf to Buffer.\n    \"\"\"\n    # sanity check - each attribute must be a Buffer (not a transform chain)\n    assert isinstance(positions, Buffer), \"Positions must be a Buffer\"\n    assert isinstance(texts, list), \"Texts must be a list of strings\"\n    assert isinstance(colors, Buffer), \"Colors must be a Buffer\"\n    assert isinstance(font_sizes, Buffer), \"Font sizes must be a Buffer\"\n    assert isinstance(anchors, Buffer), \"Anchors must be a Buffer\"\n    assert isinstance(angles, Buffer), \"Angles must be a Buffer\"\n    assert isinstance(font_name, str), \"Font name must be a string\"\n\n    Texts.sanity_check_attributes(positions, texts, colors, font_sizes, anchors, angles, font_name)\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_anchors","title":"<code>set_anchors(anchors: TransBuf) -&gt; None</code>","text":"<p>Set anchor positions of the texts.</p> <p>Parameters:</p> Name Type Description Default <code>anchors</code> <code>gsp.types.transbuf.TransBuf</code> <p>New anchor positions for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_anchors(self, anchors: TransBuf) -&gt; None:\n    \"\"\"Set anchor positions of the texts.\n\n    Args:\n        anchors: New anchor positions for the texts.\n    \"\"\"\n    self._anchors = anchors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_angles","title":"<code>set_angles(angles: TransBuf) -&gt; None</code>","text":"<p>Set rotation angles of the texts.</p> <p>Parameters:</p> Name Type Description Default <code>angles</code> <code>gsp.types.transbuf.TransBuf</code> <p>New rotation angles for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_angles(self, angles: TransBuf) -&gt; None:\n    \"\"\"Set rotation angles of the texts.\n\n    Args:\n        angles: New rotation angles for the texts.\n    \"\"\"\n    self._angles = angles\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_attributes","title":"<code>set_attributes(positions: TransBuf | None = None, texts: list[str] | None = None, colors: TransBuf | None = None, font_sizes: TransBuf | None = None, anchors: TransBuf | None = None, angles: TransBuf | None = None, font_name: str | None = None) -&gt; None</code>","text":"<p>Set multiple attributes at once and then check their validity.</p> Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_attributes(\n    self,\n    positions: TransBuf | None = None,\n    texts: list[str] | None = None,\n    colors: TransBuf | None = None,\n    font_sizes: TransBuf | None = None,\n    anchors: TransBuf | None = None,\n    angles: TransBuf | None = None,\n    font_name: str | None = None,\n) -&gt; None:\n    \"\"\"Set multiple attributes at once and then check their validity.\"\"\"\n    if positions is not None:\n        self._positions = positions\n    if texts is not None:\n        self._strings = texts\n    if colors is not None:\n        self._colors = colors\n    if font_sizes is not None:\n        self._font_sizes = font_sizes\n    if anchors is not None:\n        self._anchors = anchors\n    if angles is not None:\n        self._angles = angles\n    if font_name is not None:\n        self._font_name = font_name\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_colors","title":"<code>set_colors(colors: TransBuf) -&gt; None</code>","text":"<p>Set colors of the texts.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>gsp.types.transbuf.TransBuf</code> <p>New colors for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_colors(self, colors: TransBuf) -&gt; None:\n    \"\"\"Set colors of the texts.\n\n    Args:\n        colors: New colors for the texts.\n    \"\"\"\n    self._colors = colors\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_font_name","title":"<code>set_font_name(font_name: str) -&gt; None</code>","text":"<p>Set font name for the texts.</p> <p>Parameters:</p> Name Type Description Default <code>font_name</code> <code>str</code> <p>New font name for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_font_name(self, font_name: str) -&gt; None:\n    \"\"\"Set font name for the texts.\n\n    Args:\n        font_name: New font name for the texts.\n    \"\"\"\n    self._font_name = font_name\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_font_sizes","title":"<code>set_font_sizes(font_sizes: TransBuf) -&gt; None</code>","text":"<p>Set font sizes of the texts.</p> <p>Parameters:</p> Name Type Description Default <code>font_sizes</code> <code>gsp.types.transbuf.TransBuf</code> <p>New font sizes for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_font_sizes(self, font_sizes: TransBuf) -&gt; None:\n    \"\"\"Set font sizes of the texts.\n\n    Args:\n        font_sizes: New font sizes for the texts.\n    \"\"\"\n    self._font_sizes = font_sizes\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_positions","title":"<code>set_positions(positions: TransBuf) -&gt; None</code>","text":"<p>Set positions of the texts.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>gsp.types.transbuf.TransBuf</code> <p>New positions for the texts.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_positions(self, positions: TransBuf) -&gt; None:\n    \"\"\"Set positions of the texts.\n\n    Args:\n        positions: New positions for the texts.\n    \"\"\"\n    self._positions = positions\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#gsp.visuals.texts.Texts.set_strings","title":"<code>set_strings(strings: list[str]) -&gt; None</code>","text":"<p>Set text strings.</p> <p>Parameters:</p> Name Type Description Default <code>strings</code> <code>list[str]</code> <p>New text strings.</p> required Source code in <code>src/gsp/visuals/texts.py</code> <pre><code>def set_strings(self, strings: list[str]) -&gt; None:\n    \"\"\"Set text strings.\n\n    Args:\n        strings: New text strings.\n    \"\"\"\n    self._strings = strings\n    self.check_attributes()\n</code></pre>"},{"location":"api/gsp/#transforms-module","title":"Transforms Module","text":""},{"location":"api/gsp/#gsp.transforms","title":"<code>gsp.transforms</code>","text":"<p>GSP Transforms Package.</p>"},{"location":"api/gsp/#gsp.transforms.transform_chain","title":"<code>gsp.transforms.transform_chain</code>","text":"<p>Transform chain module for composing transformations.</p> <p>This module provides the TransformChain class which allows chaining multiple transform links to process data through a series of transformations.</p>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain","title":"<code>TransformChain</code>","text":"<p>Chain of transformations to apply to data.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>class TransformChain:\n    \"\"\"Chain of transformations to apply to data.\"\"\"\n\n    __slots__ = [\"__links\", \"__buffer_count\", \"__buffer_type\"]\n\n    def __init__(self, buffer_count: int, buffer_type: BufferType | None) -&gt; None:\n        \"\"\"Initialize a TransformChain.\n\n        Args:\n            buffer_count (int): Number of elements in the output Buffer. -1 if not defined yet.\n            buffer_type (BufferType | None): Type of the output Buffer. None if not defined yet.\n        \"\"\"\n        self.__links: list[TransformLinkBase] = []\n        \"\"\"Ordered list of links defining the transform.\"\"\"\n\n        # sanity check\n        if buffer_count &lt; 0:\n            assert buffer_count == -1, \"TransformChain: buffer_count must be -1 (undefined) or &gt;= 0\"\n\n        self.__buffer_count = buffer_count\n        \"\"\"Number of elements in the output Buffer. -1 if not defined yet.\"\"\"\n\n        self.__buffer_type = buffer_type\n        \"\"\"Type of the output Buffer. None if not defined yet.\"\"\"\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    def is_fully_defined(self) -&gt; bool:\n        \"\"\"Check if the TransformChain is fully defined.\n\n        A TransformChain is fully defined when both buffer_type is not None\n        and buffer_count is &gt;= 0.\n\n        Returns:\n            bool: True if fully defined, False otherwise.\n        \"\"\"\n        if self.__buffer_type is None:\n            return False\n        if self.__buffer_count &lt; 0:\n            return False\n        return True\n\n    def get_buffer_count(self) -&gt; int:\n        \"\"\"Get the number of elements in the output Buffer.\n\n        Note:\n            This method should only be called if is_fully_defined() returns True.\n\n        Returns:\n            int: The number of elements in the output Buffer.\n\n        Raises:\n            AssertionError: If buffer_type is None or buffer_count is negative.\n        \"\"\"\n        # sanity check - buffer_count MUST be defined\n        assert self.__buffer_type is not None, \"TransformChain.get_buffer_count: buffer_type is None. use .is_fully_defined() to check.\"\n        assert self.__buffer_count &gt;= 0, \"TransformChain.get_buffer_count: buffer_count is negative. use .is_fully_defined() to check.\"\n\n        # return the buffer count\n        return self.__buffer_count\n\n    def get_buffer_type(self) -&gt; BufferType:\n        \"\"\"Get the type of the output Buffer.\n\n        Note:\n            This method should only be called if is_fully_defined() returns True.\n\n        Returns:\n            BufferType: The type of the output Buffer.\n\n        Raises:\n            AssertionError: If buffer_type is None or buffer_count is negative.\n        \"\"\"\n        # sanity check - buffer_type MUST be defined\n        assert self.__buffer_type is not None, \"TransformChain.get_buffer_type: buffer_type is None. use .is_fully_defined() to check.\"\n        assert self.__buffer_count &gt;= 0, \"TransformChain.get_buffer_count: buffer_count is negative. use .is_fully_defined() to check.\"\n\n        # return the buffer type\n        return self.__buffer_type\n\n    # =============================================================================\n    # .add/.remove/.clear the links\n    # =============================================================================\n\n    def add(self, link: TransformLinkBase) -&gt; None:\n        \"\"\"Add a TransformLink to the chain.\n\n        Args:\n            link: The TransformLink to add to the chain.\n        \"\"\"\n        self.__links.append(link)\n\n    def remove(self, link: TransformLinkBase) -&gt; None:\n        \"\"\"Remove a TransformLink from the chain.\n\n        Args:\n            link: The TransformLink to remove from the chain.\n\n        Raises:\n            ValueError: If the link is not found in the chain.\n        \"\"\"\n        self.__links.remove(link)\n\n    # =============================================================================\n    # .run()\n    # =============================================================================\n\n    def run(self) -&gt; Buffer:\n        \"\"\"Compute the transform and return a Buffer with the result.\n\n        Applies each link in the chain sequentially, passing the output of\n        each link to the next link in the chain.\n\n        Returns:\n            Buffer: The final transformed buffer.\n\n        Raises:\n            AssertionError: If no buffer is produced by the transform chain.\n        \"\"\"\n        # Create a new Buffer to hold the transformed data\n        buffer = None\n\n        # Apply each link in the chain\n        for link in self.__links:\n            buffer = link.apply(buffer)\n\n        # Sanity check the output buffer\n        assert buffer is not None, \"TransformChain.to_buffer: No buffer produced by the transform chain.\"\n\n        # Return the final buffer\n        return buffer\n\n    # =============================================================================\n    # Serialisation\n    # =============================================================================\n\n    def serialize(self) -&gt; dict[str, Any]:\n        \"\"\"Serialize the TransformChain to a dictionary.\n\n        Returns:\n            dict[str, Any]: The serialized TransformChain containing buffer_count,\n                buffer_type, and links.\n        \"\"\"\n        links_data = [link.serialize() for link in self.__links]\n        chain_serialized = {\n            \"buffer_count\": self.__buffer_count,\n            \"buffer_type\": self.__buffer_type.name if self.__buffer_type is not None else None,\n            \"links\": links_data,\n        }\n        return chain_serialized\n\n    @staticmethod\n    def deserialize(data: dict[str, Any]) -&gt; \"TransformChain\":\n        \"\"\"Deserialize a TransformChain from a dictionary.\n\n        Args:\n            data (dict[str, Any]): The serialized TransformChain.\n\n        Returns:\n            TransformChain: The deserialized TransformChain instance.\n        \"\"\"\n        buffer_count = int(data[\"buffer_count\"])\n        buffer_type_str: str | None = data[\"buffer_type\"]\n        buffer_type = BufferType[buffer_type_str] if buffer_type_str is not None else None\n\n        transform_chain = TransformChain(buffer_count, buffer_type)\n\n        links_data: list[dict[str, Any]] = data[\"links\"]\n        for link_data in links_data:\n            link_type: str = link_data[\"link_type\"]\n            link_class: type[TransformLinkBase] = TransformRegistry.get_link_class(link_type)\n            link_instance = link_class.deserialize(link_data)\n            transform_chain.add(link_instance)\n\n        return transform_chain\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.__buffer_count","title":"<code>__buffer_count = buffer_count</code>  <code>instance-attribute</code>","text":"<p>Number of elements in the output Buffer. -1 if not defined yet.</p>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.__buffer_type","title":"<code>__buffer_type = buffer_type</code>  <code>instance-attribute</code>","text":"<p>Type of the output Buffer. None if not defined yet.</p>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.__links","title":"<code>__links: list[TransformLinkBase] = []</code>  <code>instance-attribute</code>","text":"<p>Ordered list of links defining the transform.</p>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.__init__","title":"<code>__init__(buffer_count: int, buffer_type: BufferType | None) -&gt; None</code>","text":"<p>Initialize a TransformChain.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_count</code> <code>int</code> <p>Number of elements in the output Buffer. -1 if not defined yet.</p> required <code>buffer_type</code> <code>gsp.types.BufferType | None</code> <p>Type of the output Buffer. None if not defined yet.</p> required Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def __init__(self, buffer_count: int, buffer_type: BufferType | None) -&gt; None:\n    \"\"\"Initialize a TransformChain.\n\n    Args:\n        buffer_count (int): Number of elements in the output Buffer. -1 if not defined yet.\n        buffer_type (BufferType | None): Type of the output Buffer. None if not defined yet.\n    \"\"\"\n    self.__links: list[TransformLinkBase] = []\n    \"\"\"Ordered list of links defining the transform.\"\"\"\n\n    # sanity check\n    if buffer_count &lt; 0:\n        assert buffer_count == -1, \"TransformChain: buffer_count must be -1 (undefined) or &gt;= 0\"\n\n    self.__buffer_count = buffer_count\n    \"\"\"Number of elements in the output Buffer. -1 if not defined yet.\"\"\"\n\n    self.__buffer_type = buffer_type\n    \"\"\"Type of the output Buffer. None if not defined yet.\"\"\"\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.add","title":"<code>add(link: TransformLinkBase) -&gt; None</code>","text":"<p>Add a TransformLink to the chain.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>gsp.transforms.transform_link_base.TransformLinkBase</code> <p>The TransformLink to add to the chain.</p> required Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def add(self, link: TransformLinkBase) -&gt; None:\n    \"\"\"Add a TransformLink to the chain.\n\n    Args:\n        link: The TransformLink to add to the chain.\n    \"\"\"\n    self.__links.append(link)\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.deserialize","title":"<code>deserialize(data: dict[str, Any]) -&gt; TransformChain</code>  <code>staticmethod</code>","text":"<p>Deserialize a TransformChain from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, typing.Any]</code> <p>The serialized TransformChain.</p> required <p>Returns:</p> Name Type Description <code>TransformChain</code> <code>gsp.transforms.transform_chain.TransformChain</code> <p>The deserialized TransformChain instance.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>@staticmethod\ndef deserialize(data: dict[str, Any]) -&gt; \"TransformChain\":\n    \"\"\"Deserialize a TransformChain from a dictionary.\n\n    Args:\n        data (dict[str, Any]): The serialized TransformChain.\n\n    Returns:\n        TransformChain: The deserialized TransformChain instance.\n    \"\"\"\n    buffer_count = int(data[\"buffer_count\"])\n    buffer_type_str: str | None = data[\"buffer_type\"]\n    buffer_type = BufferType[buffer_type_str] if buffer_type_str is not None else None\n\n    transform_chain = TransformChain(buffer_count, buffer_type)\n\n    links_data: list[dict[str, Any]] = data[\"links\"]\n    for link_data in links_data:\n        link_type: str = link_data[\"link_type\"]\n        link_class: type[TransformLinkBase] = TransformRegistry.get_link_class(link_type)\n        link_instance = link_class.deserialize(link_data)\n        transform_chain.add(link_instance)\n\n    return transform_chain\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.get_buffer_count","title":"<code>get_buffer_count() -&gt; int</code>","text":"<p>Get the number of elements in the output Buffer.</p> Note <p>This method should only be called if is_fully_defined() returns True.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the output Buffer.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If buffer_type is None or buffer_count is negative.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def get_buffer_count(self) -&gt; int:\n    \"\"\"Get the number of elements in the output Buffer.\n\n    Note:\n        This method should only be called if is_fully_defined() returns True.\n\n    Returns:\n        int: The number of elements in the output Buffer.\n\n    Raises:\n        AssertionError: If buffer_type is None or buffer_count is negative.\n    \"\"\"\n    # sanity check - buffer_count MUST be defined\n    assert self.__buffer_type is not None, \"TransformChain.get_buffer_count: buffer_type is None. use .is_fully_defined() to check.\"\n    assert self.__buffer_count &gt;= 0, \"TransformChain.get_buffer_count: buffer_count is negative. use .is_fully_defined() to check.\"\n\n    # return the buffer count\n    return self.__buffer_count\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.get_buffer_type","title":"<code>get_buffer_type() -&gt; BufferType</code>","text":"<p>Get the type of the output Buffer.</p> Note <p>This method should only be called if is_fully_defined() returns True.</p> <p>Returns:</p> Name Type Description <code>BufferType</code> <code>gsp.types.BufferType</code> <p>The type of the output Buffer.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If buffer_type is None or buffer_count is negative.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def get_buffer_type(self) -&gt; BufferType:\n    \"\"\"Get the type of the output Buffer.\n\n    Note:\n        This method should only be called if is_fully_defined() returns True.\n\n    Returns:\n        BufferType: The type of the output Buffer.\n\n    Raises:\n        AssertionError: If buffer_type is None or buffer_count is negative.\n    \"\"\"\n    # sanity check - buffer_type MUST be defined\n    assert self.__buffer_type is not None, \"TransformChain.get_buffer_type: buffer_type is None. use .is_fully_defined() to check.\"\n    assert self.__buffer_count &gt;= 0, \"TransformChain.get_buffer_count: buffer_count is negative. use .is_fully_defined() to check.\"\n\n    # return the buffer type\n    return self.__buffer_type\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.is_fully_defined","title":"<code>is_fully_defined() -&gt; bool</code>","text":"<p>Check if the TransformChain is fully defined.</p> <p>A TransformChain is fully defined when both buffer_type is not None and buffer_count is &gt;= 0.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if fully defined, False otherwise.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def is_fully_defined(self) -&gt; bool:\n    \"\"\"Check if the TransformChain is fully defined.\n\n    A TransformChain is fully defined when both buffer_type is not None\n    and buffer_count is &gt;= 0.\n\n    Returns:\n        bool: True if fully defined, False otherwise.\n    \"\"\"\n    if self.__buffer_type is None:\n        return False\n    if self.__buffer_count &lt; 0:\n        return False\n    return True\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.remove","title":"<code>remove(link: TransformLinkBase) -&gt; None</code>","text":"<p>Remove a TransformLink from the chain.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>gsp.transforms.transform_link_base.TransformLinkBase</code> <p>The TransformLink to remove from the chain.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the link is not found in the chain.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def remove(self, link: TransformLinkBase) -&gt; None:\n    \"\"\"Remove a TransformLink from the chain.\n\n    Args:\n        link: The TransformLink to remove from the chain.\n\n    Raises:\n        ValueError: If the link is not found in the chain.\n    \"\"\"\n    self.__links.remove(link)\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.run","title":"<code>run() -&gt; Buffer</code>","text":"<p>Compute the transform and return a Buffer with the result.</p> <p>Applies each link in the chain sequentially, passing the output of each link to the next link in the chain.</p> <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.Buffer</code> <p>The final transformed buffer.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If no buffer is produced by the transform chain.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def run(self) -&gt; Buffer:\n    \"\"\"Compute the transform and return a Buffer with the result.\n\n    Applies each link in the chain sequentially, passing the output of\n    each link to the next link in the chain.\n\n    Returns:\n        Buffer: The final transformed buffer.\n\n    Raises:\n        AssertionError: If no buffer is produced by the transform chain.\n    \"\"\"\n    # Create a new Buffer to hold the transformed data\n    buffer = None\n\n    # Apply each link in the chain\n    for link in self.__links:\n        buffer = link.apply(buffer)\n\n    # Sanity check the output buffer\n    assert buffer is not None, \"TransformChain.to_buffer: No buffer produced by the transform chain.\"\n\n    # Return the final buffer\n    return buffer\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_chain.TransformChain.serialize","title":"<code>serialize() -&gt; dict[str, Any]</code>","text":"<p>Serialize the TransformChain to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>dict[str, Any]: The serialized TransformChain containing buffer_count, buffer_type, and links.</p> Source code in <code>src/gsp/transforms/transform_chain.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n    \"\"\"Serialize the TransformChain to a dictionary.\n\n    Returns:\n        dict[str, Any]: The serialized TransformChain containing buffer_count,\n            buffer_type, and links.\n    \"\"\"\n    links_data = [link.serialize() for link in self.__links]\n    chain_serialized = {\n        \"buffer_count\": self.__buffer_count,\n        \"buffer_type\": self.__buffer_type.name if self.__buffer_type is not None else None,\n        \"links\": links_data,\n    }\n    return chain_serialized\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_link_base","title":"<code>gsp.transforms.transform_link_base</code>","text":"<p>Transform Link Base Module.</p>"},{"location":"api/gsp/#gsp.transforms.transform_link_base.TransformLinkBase","title":"<code>TransformLinkBase</code>","text":"<p>               Bases: <code>abc.ABC</code></p> <p>Base class for a link in a Transform chain.</p> Source code in <code>src/gsp/transforms/transform_link_base.py</code> <pre><code>class TransformLinkBase(ABC):\n    \"\"\"Base class for a link in a Transform chain.\"\"\"\n\n    @abstractmethod\n    def apply(self, buffer_src: Buffer | None) -&gt; Buffer:\n        \"\"\"Apply the transformation to the given buffer and return a new buffer.\n\n        Args:\n            buffer_src (Buffer | None): The source buffer to transform. Can be None.\n\n        Returns:\n            Buffer: The transformed buffer.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def serialize(self) -&gt; dict[str, Any]:\n        \"\"\"Serialize the TransformLink to a dictionary.\n\n        Returns:\n            dict[str, Any]: The serialized TransformLink.\n        \"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def deserialize(data: dict[str, Any]) -&gt; \"TransformLinkBase\":\n        \"\"\"Deserialize a TransformLink from a dictionary.\n\n        Args:\n            data (dict[str, Any]): The serialized TransformLink.\n\n        Returns:\n            TransformLinkBase: The deserialized TransformLink instance.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_link_base.TransformLinkBase.apply","title":"<code>apply(buffer_src: Buffer | None) -&gt; Buffer</code>  <code>abstractmethod</code>","text":"<p>Apply the transformation to the given buffer and return a new buffer.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_src</code> <code>gsp.types.Buffer | None</code> <p>The source buffer to transform. Can be None.</p> required <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.Buffer</code> <p>The transformed buffer.</p> Source code in <code>src/gsp/transforms/transform_link_base.py</code> <pre><code>@abstractmethod\ndef apply(self, buffer_src: Buffer | None) -&gt; Buffer:\n    \"\"\"Apply the transformation to the given buffer and return a new buffer.\n\n    Args:\n        buffer_src (Buffer | None): The source buffer to transform. Can be None.\n\n    Returns:\n        Buffer: The transformed buffer.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_link_base.TransformLinkBase.deserialize","title":"<code>deserialize(data: dict[str, Any]) -&gt; TransformLinkBase</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Deserialize a TransformLink from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, typing.Any]</code> <p>The serialized TransformLink.</p> required <p>Returns:</p> Name Type Description <code>TransformLinkBase</code> <code>gsp.transforms.transform_link_base.TransformLinkBase</code> <p>The deserialized TransformLink instance.</p> Source code in <code>src/gsp/transforms/transform_link_base.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef deserialize(data: dict[str, Any]) -&gt; \"TransformLinkBase\":\n    \"\"\"Deserialize a TransformLink from a dictionary.\n\n    Args:\n        data (dict[str, Any]): The serialized TransformLink.\n\n    Returns:\n        TransformLinkBase: The deserialized TransformLink instance.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#gsp.transforms.transform_link_base.TransformLinkBase.serialize","title":"<code>serialize() -&gt; dict[str, Any]</code>  <code>abstractmethod</code>","text":"<p>Serialize the TransformLink to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, typing.Any]</code> <p>dict[str, Any]: The serialized TransformLink.</p> Source code in <code>src/gsp/transforms/transform_link_base.py</code> <pre><code>@abstractmethod\ndef serialize(self) -&gt; dict[str, Any]:\n    \"\"\"Serialize the TransformLink to a dictionary.\n\n    Returns:\n        dict[str, Any]: The serialized TransformLink.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp/#utilities-module","title":"Utilities Module","text":""},{"location":"api/gsp/#gsp.utils","title":"<code>gsp.utils</code>","text":"<p>Utility modules for GSP.</p>"},{"location":"api/gsp/#gsp.utils.cmap_utils","title":"<code>gsp.utils.cmap_utils</code>","text":"<p>Colormap utilities for mapping values to colors using matplotlib colormaps.</p>"},{"location":"api/gsp/#gsp.utils.cmap_utils.CmapUtils","title":"<code>CmapUtils</code>","text":"<p>Utility class for colormap operations. Leverage matplotlib colormaps.</p> Source code in <code>src/gsp/utils/cmap_utils.py</code> <pre><code>class CmapUtils:\n    \"\"\"Utility class for colormap operations. Leverage [matplotlib colormaps](https://matplotlib.org/stable/tutorials/colors/colormaps.html).\"\"\"\n\n    @staticmethod\n    def has_color_map(colormap_name: str) -&gt; bool:\n        \"\"\"Check if the given colormap name is recognized by matplotlib.\n\n        Args:\n            colormap_name (str): Name of the colormap to check.\n\n        Returns:\n            bool: True if the colormap exists, False otherwise.\n        \"\"\"\n        try:\n            matplotlib.cm.get_cmap(colormap_name)\n            return True\n        except ValueError:\n            return False\n\n    @staticmethod\n    def get_color_map(colormap_name: str, values: np.ndarray, vmin: float | None = None, vmax: float | None = None) -&gt; Buffer:\n        \"\"\"Get colors from a colormap for the given values.\n\n        Args:\n            colormap_name (str): Name of the colormap (e.g., 'plasma', 'viridis', etc.).\n            values (np.ndarray): Array of input values to map to colors.\n            vmin (float|None): Minimum value for values normalization. if None, use min of values.\n            vmax (float|None): Maximum value for values normalization. if None, use max of values.\n\n        Returns:\n            Buffer: A Buffer containing the RGBA8 colors mapped from the input values.\n        \"\"\"\n        # Handle default parameters\n        vmin = vmin if vmin is not None else values.min()\n        vmax = vmax if vmax is not None else values.max()\n\n        # sanity check\n        assert CmapUtils.has_color_map(colormap_name), f\"Colormap '{colormap_name}' is not recognized.\"\n\n        mpl_color_map = matplotlib.cm.get_cmap(colormap_name)\n\n        # sanity check\n        assert vmin is not None, \"vmin should not be None\"\n        assert vmax is not None, \"vmax should not be None\"\n\n        normalized_values = (values - vmin) / (vmax - vmin)\n        normalized_values = np.clip(normalized_values, 0.0, 1.0)\n        color_mapped_normalized = mpl_color_map(normalized_values)  # normalized values to [0, 1]\n        color_mapped_255 = (color_mapped_normalized * 255).astype(np.uint8)\n\n        # Create a Buffer\n        color_buffer = Buffer(color_mapped_255.__len__(), buffer_type=BufferType.rgba8)\n        color_buffer.set_data(bytearray(color_mapped_255.tobytes()), 0, color_mapped_255.__len__())\n\n        # Return the color buffer\n        return color_buffer\n</code></pre>"},{"location":"api/gsp/#gsp.utils.cmap_utils.CmapUtils.get_color_map","title":"<code>get_color_map(colormap_name: str, values: np.ndarray, vmin: float | None = None, vmax: float | None = None) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Get colors from a colormap for the given values.</p> <p>Parameters:</p> Name Type Description Default <code>colormap_name</code> <code>str</code> <p>Name of the colormap (e.g., 'plasma', 'viridis', etc.).</p> required <code>values</code> <code>numpy.ndarray</code> <p>Array of input values to map to colors.</p> required <code>vmin</code> <code>float | None</code> <p>Minimum value for values normalization. if None, use min of values.</p> <code>None</code> <code>vmax</code> <code>float | None</code> <p>Maximum value for values normalization. if None, use max of values.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Buffer</code> <code>gsp.types.Buffer</code> <p>A Buffer containing the RGBA8 colors mapped from the input values.</p> Source code in <code>src/gsp/utils/cmap_utils.py</code> <pre><code>@staticmethod\ndef get_color_map(colormap_name: str, values: np.ndarray, vmin: float | None = None, vmax: float | None = None) -&gt; Buffer:\n    \"\"\"Get colors from a colormap for the given values.\n\n    Args:\n        colormap_name (str): Name of the colormap (e.g., 'plasma', 'viridis', etc.).\n        values (np.ndarray): Array of input values to map to colors.\n        vmin (float|None): Minimum value for values normalization. if None, use min of values.\n        vmax (float|None): Maximum value for values normalization. if None, use max of values.\n\n    Returns:\n        Buffer: A Buffer containing the RGBA8 colors mapped from the input values.\n    \"\"\"\n    # Handle default parameters\n    vmin = vmin if vmin is not None else values.min()\n    vmax = vmax if vmax is not None else values.max()\n\n    # sanity check\n    assert CmapUtils.has_color_map(colormap_name), f\"Colormap '{colormap_name}' is not recognized.\"\n\n    mpl_color_map = matplotlib.cm.get_cmap(colormap_name)\n\n    # sanity check\n    assert vmin is not None, \"vmin should not be None\"\n    assert vmax is not None, \"vmax should not be None\"\n\n    normalized_values = (values - vmin) / (vmax - vmin)\n    normalized_values = np.clip(normalized_values, 0.0, 1.0)\n    color_mapped_normalized = mpl_color_map(normalized_values)  # normalized values to [0, 1]\n    color_mapped_255 = (color_mapped_normalized * 255).astype(np.uint8)\n\n    # Create a Buffer\n    color_buffer = Buffer(color_mapped_255.__len__(), buffer_type=BufferType.rgba8)\n    color_buffer.set_data(bytearray(color_mapped_255.tobytes()), 0, color_mapped_255.__len__())\n\n    # Return the color buffer\n    return color_buffer\n</code></pre>"},{"location":"api/gsp/#gsp.utils.cmap_utils.CmapUtils.has_color_map","title":"<code>has_color_map(colormap_name: str) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Check if the given colormap name is recognized by matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>colormap_name</code> <code>str</code> <p>Name of the colormap to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the colormap exists, False otherwise.</p> Source code in <code>src/gsp/utils/cmap_utils.py</code> <pre><code>@staticmethod\ndef has_color_map(colormap_name: str) -&gt; bool:\n    \"\"\"Check if the given colormap name is recognized by matplotlib.\n\n    Args:\n        colormap_name (str): Name of the colormap to check.\n\n    Returns:\n        bool: True if the colormap exists, False otherwise.\n    \"\"\"\n    try:\n        matplotlib.cm.get_cmap(colormap_name)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils","title":"<code>gsp.utils.group_utils</code>","text":"<p>Utility functions for handling and manipulating group objects.</p> <p>This module provides utilities for working with Groups, which can be represented in multiple formats: int, list[int], or list[list[int]].</p>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils","title":"<code>GroupUtils</code>","text":"<p>Utility class for group operations and validation.</p> <p>This class provides static methods for: - Validating group objects - Computing group counts and indices - Converting between different group formats</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>class GroupUtils:\n    \"\"\"Utility class for group operations and validation.\n\n    This class provides static methods for:\n    - Validating group objects\n    - Computing group counts and indices\n    - Converting between different group formats\n    \"\"\"\n\n    @staticmethod\n    def get_group_count(vertex_count: int, groups: Groups) -&gt; int:\n        \"\"\"Return the number of groups from the groups object.\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (Groups): groups object\n\n        Returns:\n            int: number of groups\n\n        Raises:\n            NotImplementedError: if the groups object type is not supported\n        \"\"\"\n        groups_format = GroupUtils._groups_format(groups)\n        if groups_format == GroupUtils.FORMAT_INT:\n            groups_typed = typing.cast(int, groups)\n            group_count = vertex_count // groups_typed\n        elif groups_format == GroupUtils.FORMAT_LIST_INT:\n            groups_typed = typing.cast(list[int], groups)\n            group_count = len(groups_typed)\n        elif groups_format == GroupUtils.FORMAT_LIST_LIST_INT:\n            groups_typed = typing.cast(list[list[int]], groups)\n            group_count = len(groups_typed)\n        else:\n            raise NotImplementedError(f\"Group buffer shape not supported: {type(groups)}\")\n\n        return group_count\n\n    # =============================================================================\n    # is_instance_of_groups\n    # =============================================================================\n\n    @staticmethod\n    def is_instance_of_groups(groups: Groups) -&gt; bool:\n        \"\"\"Check if the type of groups is valid.\n\n        Deep check where all elements are checked.\n        Does not check the values themselves, only the types.\n\n        Groups can be:\n        - int\n        - list[int]\n        - list[list[int]]\n\n        Args:\n            groups (Groups): groups object\n\n        Returns:\n            bool: True if groups is a valid Groups object, False otherwise.\n        \"\"\"\n        if isinstance(groups, int):\n            return True\n        elif isinstance(groups, list) and all(isinstance(int_value, int) for int_value in groups):\n            return True\n        elif isinstance(groups, list) and all(isinstance(group, list) for group in groups) and all(isinstance(int_value, int) for int_list in groups for int_value in int_list):  # type: ignore[union-attr]\n            return True\n        else:\n            return False\n\n    # =============================================================================\n    # ._groups_format()\n    # =============================================================================\n\n    FORMAT_INT = \"format_int\"\n    FORMAT_LIST_INT = \"format_list_int\"\n    FORMAT_LIST_LIST_INT = \"format_list_list_int\"\n\n    @staticmethod\n    def _groups_format(groups: Groups) -&gt; Literal[\"format_int\", \"format_list_int\", \"format_list_list_int\"]:\n        \"\"\"Return the format of the groups object as a string.\n\n        No check is done.\n\n        Args:\n            groups (Groups): groups object\n\n        Returns:\n            Literal[\"format_int\", \"format_list_int\", \"format_list_list_int\"]: \"format_int\", \"format_list_int\", \"format_list_list_int\"\n\n        Raises:\n            ValueError: if the groups object is not valid\n        \"\"\"\n        if isinstance(groups, int):\n            return GroupUtils.FORMAT_INT\n        elif isinstance(groups, list) and groups.__len__() &gt; 0 and isinstance(groups[0], int):\n            return GroupUtils.FORMAT_LIST_INT\n        elif isinstance(groups, list) and groups.__len__() &gt; 0 and isinstance(groups[0], list) and groups[0].__len__() &gt; 0 and isinstance(groups[0][0], int):\n            return GroupUtils.FORMAT_LIST_LIST_INT\n        else:\n            raise ValueError(f\"Groups object is not valid: {type(groups)}\")\n\n    # =============================================================================\n    # Sanity Checks\n    # =============================================================================\n\n    @staticmethod\n    def sanity_check(vertex_count: int, groups: Groups) -&gt; None:\n        \"\"\"Perform sanity checks on the groups object, raising exceptions if not valid.\n\n        Raise:\n            ValueError: if the groups object is not valid.\n        \"\"\"\n        if not GroupUtils.is_instance_of_groups(groups):\n            raise ValueError(f\"Groups object is not valid: {type(groups)}\")\n\n        groups_mode = GroupUtils._groups_format(groups)\n\n        if groups_mode == GroupUtils.FORMAT_INT:\n            groups_int = typing.cast(int, groups)\n            if groups_int &lt;= 0:\n                raise ValueError(f\"Groups as int must be positive, got {groups_int}\")\n            if groups_int &gt; vertex_count:\n                raise ValueError(f\"Groups as int must be less than or equal to vertex_count, got groups={groups_int}, vertex_count={vertex_count}\")\n            if vertex_count % groups_int != 0:\n                raise ValueError(f\"Groups as int must divide vertex_count, got vertex_count={vertex_count}, groups={groups_int}\")\n        elif groups_mode == GroupUtils.FORMAT_LIST_INT:\n            groups_list_int = typing.cast(list[int], groups)\n            if any(group_size &lt;= 0 for group_size in groups_list_int):\n                raise ValueError(f\"Groups as list[int], group sizes must be all positive, got {groups_list_int}\")\n            if sum(groups_list_int) != vertex_count:\n                raise ValueError(\n                    f\"Sum of groups size as list[int] must equal vertex_count, got sum(groups)={sum(groups_list_int)}, vertex_count={vertex_count}\"\n                )\n        elif groups_mode == GroupUtils.FORMAT_LIST_LIST_INT:\n            groups_list_list_int = typing.cast(list[list[int]], groups)\n            all_indices = [index for group in groups_list_list_int for index in group]\n            if any(index &lt; 0 or index &gt;= vertex_count for index in all_indices):\n                raise ValueError(f\"Groups as list[list[int]], all indices must be in range [0, {vertex_count-1}], got indices={all_indices}\")\n            if len(set(all_indices)) != len(all_indices):\n                raise ValueError(f\"Groups as list[list[int]], all indices must be unique, got indices={all_indices}\")\n\n        # TODO check that the list matches the vertex count where needed\n        # TODO check that no list is empty\n\n    @staticmethod\n    def sanity_check_safe(vertex_count: int, groups: Groups) -&gt; bool:\n        \"\"\"Perform sanity checks on the groups object.\n\n        Same as .sanity_check_groups() but does not raise exceptions if not valid.\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (Groups): groups object\n\n        Returns:\n            bool: True if the groups object is valid, False otherwise.\n        \"\"\"\n        try:\n            GroupUtils.sanity_check(vertex_count, groups)\n            return True\n        except ValueError:\n            return False\n\n    # =============================================================================\n    # .compute_indices_per_group\n    # =============================================================================\n\n    @staticmethod\n    def compute_indices_per_group(vertex_count: int, groups: Groups) -&gt; list[list[int]]:\n        \"\"\"Compute indices_per_group for groups depending on the type of groups.\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (Groups): groups object\n\n        Returns:\n            list[list[int]]: list of vertex indices per group\n\n        Raises:\n            NotImplementedError: if the groups object type is not supported\n        \"\"\"\n        # sanity check\n        assert GroupUtils.sanity_check_safe(vertex_count, groups), \"groups failed sanity check\"\n\n        groups_format = GroupUtils._groups_format(groups)\n        if groups_format == GroupUtils.FORMAT_INT:\n            groups_typed = typing.cast(int, groups)\n            indices_per_group = GroupUtils._compute_indices_per_group_int(vertex_count, groups_typed)\n        elif groups_format == GroupUtils.FORMAT_LIST_INT:\n            groups_typed = typing.cast(list[int], groups)\n            indices_per_group = GroupUtils._compute_indices_per_group_list_int(vertex_count, groups_typed)\n        elif groups_format == GroupUtils.FORMAT_LIST_LIST_INT:\n            groups_typed = typing.cast(list[list[int]], groups)\n            indices_per_group = GroupUtils._compute_indices_per_group_list_list_int(vertex_count, groups_typed)\n        else:\n            raise NotImplementedError(f\"Group buffer shape not supported: {type(groups)}\")\n\n        return indices_per_group\n\n    # =============================================================================\n    # ._compute_indices_per_group_*() for each format\n    # =============================================================================\n\n    @staticmethod\n    def _compute_indices_per_group_int(vertex_count: int, groups: int) -&gt; list[list[int]]:\n        \"\"\"Compute indices_per_group for groups as int.\n\n        The int represents the size of each group.\n\n        group_count = vertex_count // groups\n        indices_per_group = list[list[int]]\n\n        Examples:\n        - vertex_count = 6, groups = 2 - divisible - all groups are vertex_count // groups long\n          - indices_per_group = [[0, 1], [2, 3], [4, 5]]\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (int): size of each group\n\n        Returns:\n            list[list[int]]: list of vertex indices per group\n        \"\"\"\n        # Initialize output variables\n        group_count: int = vertex_count // groups\n        indices_per_group: list[list[int]] = []\n\n        # Create the indices per group for this case\n        element_count_per_group = groups\n\n        for group_index in range(group_count):\n            start_index = element_count_per_group * group_index\n            end_index = element_count_per_group * (group_index + 1)\n\n            # Fill the indices for this group\n            indices_per_group.append(list(range(start_index, end_index)))\n\n        return indices_per_group\n\n    @staticmethod\n    def _compute_indices_per_group_list_int(vertex_count: int, groups: list[int]) -&gt; list[list[int]]:\n        \"\"\"Compute indices_per_group for groups as list[int].\n\n        In this case, each int represents the size of each group.\n\n        group_count = len(groups)\n        indices_per_group = list[list[int]]\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (list[int]): list of group sizes\n\n        Returns:\n            list[list[int]]: list of vertex indices per group\n        \"\"\"\n        # Initialize output variables\n        indices_per_group: list[list[int]] = []\n\n        # Create the indices per group for this case\n        current_index = 0\n        for group_size in groups:\n            # Fill the indices for this group\n            group_indices = list(range(current_index, current_index + group_size))\n            indices_per_group.append(group_indices)\n\n            # Update the current index\n            current_index += group_size\n\n        return indices_per_group\n\n    @staticmethod\n    def _compute_indices_per_group_list_list_int(vertex_count: int, groups: list[list[int]]) -&gt; list[list[int]]:\n        \"\"\"Compute indices_per_group for groups as list[list[int]].\n\n        In this case, the groups are directly the indices per group themselves.\n\n        group_count = len(groups)\n        indices_per_group = list[list[int]]\n\n        Args:\n            vertex_count (int): number of vertices\n            groups (list[list[int]]): list of vertex indices per group\n\n        Returns:\n            list[list[int]]: list of vertex indices per group\n        \"\"\"\n        # Initialize output variables\n        indices_per_group: list[list[int]] = groups\n\n        return indices_per_group\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.compute_indices_per_group","title":"<code>compute_indices_per_group(vertex_count: int, groups: Groups) -&gt; list[list[int]]</code>  <code>staticmethod</code>","text":"<p>Compute indices_per_group for groups depending on the type of groups.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_count</code> <code>int</code> <p>number of vertices</p> required <code>groups</code> <code>gsp.types.group.Groups</code> <p>groups object</p> required <p>Returns:</p> Type Description <code>list[list[int]]</code> <p>list[list[int]]: list of vertex indices per group</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if the groups object type is not supported</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef compute_indices_per_group(vertex_count: int, groups: Groups) -&gt; list[list[int]]:\n    \"\"\"Compute indices_per_group for groups depending on the type of groups.\n\n    Args:\n        vertex_count (int): number of vertices\n        groups (Groups): groups object\n\n    Returns:\n        list[list[int]]: list of vertex indices per group\n\n    Raises:\n        NotImplementedError: if the groups object type is not supported\n    \"\"\"\n    # sanity check\n    assert GroupUtils.sanity_check_safe(vertex_count, groups), \"groups failed sanity check\"\n\n    groups_format = GroupUtils._groups_format(groups)\n    if groups_format == GroupUtils.FORMAT_INT:\n        groups_typed = typing.cast(int, groups)\n        indices_per_group = GroupUtils._compute_indices_per_group_int(vertex_count, groups_typed)\n    elif groups_format == GroupUtils.FORMAT_LIST_INT:\n        groups_typed = typing.cast(list[int], groups)\n        indices_per_group = GroupUtils._compute_indices_per_group_list_int(vertex_count, groups_typed)\n    elif groups_format == GroupUtils.FORMAT_LIST_LIST_INT:\n        groups_typed = typing.cast(list[list[int]], groups)\n        indices_per_group = GroupUtils._compute_indices_per_group_list_list_int(vertex_count, groups_typed)\n    else:\n        raise NotImplementedError(f\"Group buffer shape not supported: {type(groups)}\")\n\n    return indices_per_group\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.get_group_count","title":"<code>get_group_count(vertex_count: int, groups: Groups) -&gt; int</code>  <code>staticmethod</code>","text":"<p>Return the number of groups from the groups object.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_count</code> <code>int</code> <p>number of vertices</p> required <code>groups</code> <code>gsp.types.group.Groups</code> <p>groups object</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of groups</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if the groups object type is not supported</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef get_group_count(vertex_count: int, groups: Groups) -&gt; int:\n    \"\"\"Return the number of groups from the groups object.\n\n    Args:\n        vertex_count (int): number of vertices\n        groups (Groups): groups object\n\n    Returns:\n        int: number of groups\n\n    Raises:\n        NotImplementedError: if the groups object type is not supported\n    \"\"\"\n    groups_format = GroupUtils._groups_format(groups)\n    if groups_format == GroupUtils.FORMAT_INT:\n        groups_typed = typing.cast(int, groups)\n        group_count = vertex_count // groups_typed\n    elif groups_format == GroupUtils.FORMAT_LIST_INT:\n        groups_typed = typing.cast(list[int], groups)\n        group_count = len(groups_typed)\n    elif groups_format == GroupUtils.FORMAT_LIST_LIST_INT:\n        groups_typed = typing.cast(list[list[int]], groups)\n        group_count = len(groups_typed)\n    else:\n        raise NotImplementedError(f\"Group buffer shape not supported: {type(groups)}\")\n\n    return group_count\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.is_instance_of_groups","title":"<code>is_instance_of_groups(groups: Groups) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Check if the type of groups is valid.</p> <p>Deep check where all elements are checked. Does not check the values themselves, only the types.</p> <p>Groups can be: - int - list[int] - list[list[int]]</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>gsp.types.group.Groups</code> <p>groups object</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if groups is a valid Groups object, False otherwise.</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef is_instance_of_groups(groups: Groups) -&gt; bool:\n    \"\"\"Check if the type of groups is valid.\n\n    Deep check where all elements are checked.\n    Does not check the values themselves, only the types.\n\n    Groups can be:\n    - int\n    - list[int]\n    - list[list[int]]\n\n    Args:\n        groups (Groups): groups object\n\n    Returns:\n        bool: True if groups is a valid Groups object, False otherwise.\n    \"\"\"\n    if isinstance(groups, int):\n        return True\n    elif isinstance(groups, list) and all(isinstance(int_value, int) for int_value in groups):\n        return True\n    elif isinstance(groups, list) and all(isinstance(group, list) for group in groups) and all(isinstance(int_value, int) for int_list in groups for int_value in int_list):  # type: ignore[union-attr]\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.sanity_check","title":"<code>sanity_check(vertex_count: int, groups: Groups) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Perform sanity checks on the groups object, raising exceptions if not valid.</p> Raise <p>ValueError: if the groups object is not valid.</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef sanity_check(vertex_count: int, groups: Groups) -&gt; None:\n    \"\"\"Perform sanity checks on the groups object, raising exceptions if not valid.\n\n    Raise:\n        ValueError: if the groups object is not valid.\n    \"\"\"\n    if not GroupUtils.is_instance_of_groups(groups):\n        raise ValueError(f\"Groups object is not valid: {type(groups)}\")\n\n    groups_mode = GroupUtils._groups_format(groups)\n\n    if groups_mode == GroupUtils.FORMAT_INT:\n        groups_int = typing.cast(int, groups)\n        if groups_int &lt;= 0:\n            raise ValueError(f\"Groups as int must be positive, got {groups_int}\")\n        if groups_int &gt; vertex_count:\n            raise ValueError(f\"Groups as int must be less than or equal to vertex_count, got groups={groups_int}, vertex_count={vertex_count}\")\n        if vertex_count % groups_int != 0:\n            raise ValueError(f\"Groups as int must divide vertex_count, got vertex_count={vertex_count}, groups={groups_int}\")\n    elif groups_mode == GroupUtils.FORMAT_LIST_INT:\n        groups_list_int = typing.cast(list[int], groups)\n        if any(group_size &lt;= 0 for group_size in groups_list_int):\n            raise ValueError(f\"Groups as list[int], group sizes must be all positive, got {groups_list_int}\")\n        if sum(groups_list_int) != vertex_count:\n            raise ValueError(\n                f\"Sum of groups size as list[int] must equal vertex_count, got sum(groups)={sum(groups_list_int)}, vertex_count={vertex_count}\"\n            )\n    elif groups_mode == GroupUtils.FORMAT_LIST_LIST_INT:\n        groups_list_list_int = typing.cast(list[list[int]], groups)\n        all_indices = [index for group in groups_list_list_int for index in group]\n        if any(index &lt; 0 or index &gt;= vertex_count for index in all_indices):\n            raise ValueError(f\"Groups as list[list[int]], all indices must be in range [0, {vertex_count-1}], got indices={all_indices}\")\n        if len(set(all_indices)) != len(all_indices):\n            raise ValueError(f\"Groups as list[list[int]], all indices must be unique, got indices={all_indices}\")\n</code></pre>"},{"location":"api/gsp/#gsp.utils.group_utils.GroupUtils.sanity_check_safe","title":"<code>sanity_check_safe(vertex_count: int, groups: Groups) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Perform sanity checks on the groups object.</p> <p>Same as .sanity_check_groups() but does not raise exceptions if not valid.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_count</code> <code>int</code> <p>number of vertices</p> required <code>groups</code> <code>gsp.types.group.Groups</code> <p>groups object</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the groups object is valid, False otherwise.</p> Source code in <code>src/gsp/utils/group_utils.py</code> <pre><code>@staticmethod\ndef sanity_check_safe(vertex_count: int, groups: Groups) -&gt; bool:\n    \"\"\"Perform sanity checks on the groups object.\n\n    Same as .sanity_check_groups() but does not raise exceptions if not valid.\n\n    Args:\n        vertex_count (int): number of vertices\n        groups (Groups): groups object\n\n    Returns:\n        bool: True if the groups object is valid, False otherwise.\n    \"\"\"\n    try:\n        GroupUtils.sanity_check(vertex_count, groups)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/gsp/#gsp.utils.math_utils","title":"<code>gsp.utils.math_utils</code>","text":"<p>Mathematical utility functions for GSP.</p> <p>This module provides mathematical operations and transformations used throughout the GSP library, including: - Model-View-Projection (MVP) transformations for 3D graphics</p>"},{"location":"api/gsp/#gsp.utils.math_utils.MathUtils","title":"<code>MathUtils</code>","text":"<p>Utility class for mathematical operations in GSP.</p> <p>This class provides static methods for common mathematical operations used in graphics programming, such as matrix transformations.</p> Source code in <code>src/gsp/utils/math_utils.py</code> <pre><code>class MathUtils:\n    \"\"\"Utility class for mathematical operations in GSP.\n\n    This class provides static methods for common mathematical operations\n    used in graphics programming, such as matrix transformations.\n    \"\"\"\n\n    @staticmethod\n    def apply_mvp_to_vertices(vertices: np.ndarray, model_matrix: np.ndarray, view_matrix: np.ndarray, projection_matrix: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Applies Model-View-Projection transformation to the vertices.\n\n        Args:\n            vertices (np.ndarray): Input vertices of shape (N, 3).\n            model_matrix (np.ndarray): Model matrix of shape (4, 4).\n            view_matrix (np.ndarray): View matrix of shape (4, 4).\n            projection_matrix (np.ndarray): Projection matrix of shape (4, 4).\n\n        Returns:\n            np.ndarray: Transformed vertices of shape (N, 3).\n        \"\"\"\n        # sanity checks\n        assert vertices.ndim == 2 and vertices.shape[1] == 3, f\"Expected vertices shape (N, 3), got {vertices.shape}\"\n        assert model_matrix.shape == (4, 4), f\"Expected model_matrix shape (4, 4), got {model_matrix.shape}\"\n        assert view_matrix.shape == (4, 4), f\"Expected view_matrix shape (4, 4), got {view_matrix.shape}\"\n        assert projection_matrix.shape == (4, 4), f\"Expected projection_matrix shape (4, 4), got {projection_matrix.shape}\"\n\n        # Compute the Model-View-Projection (MVP) matrix\n        mvp_matrix = projection_matrix @ view_matrix @ model_matrix\n\n        # convert vertices to homogeneous coordinates (x, y, z) -&gt; (x, y, z, w=1.0)\n        ws_column = np.ones((vertices.shape[0], 1), dtype=np.float32)\n        vertices_homogeneous = np.hstack((vertices, ws_column))  # shape (N, 4) for N vertices\n\n        # Apply the MVP transformation to the vertices\n        vertices_transformed = (mvp_matrix @ vertices_homogeneous.T).T  # shape (N, 4)\n\n        # Perform perspective division to get normalized device coordinates (NDC)\n        vertices_homo_transformed = vertices_transformed / vertices_transformed[:, 3:4]  # divide by w - shape (N, 4)\n        vertices_3d_transformed = vertices_homo_transformed[:, :3]  # drop w-coordinate - shape (N, 3)\n\n        # NOTE: no need to map NDC to screen coordinates as canvas is drawn directly in NDC coordinates 2d\n        pass\n\n        # return the transformed vertices\n        return vertices_3d_transformed\n</code></pre>"},{"location":"api/gsp/#gsp.utils.math_utils.MathUtils.apply_mvp_to_vertices","title":"<code>apply_mvp_to_vertices(vertices: np.ndarray, model_matrix: np.ndarray, view_matrix: np.ndarray, projection_matrix: np.ndarray) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Applies Model-View-Projection transformation to the vertices.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>numpy.ndarray</code> <p>Input vertices of shape (N, 3).</p> required <code>model_matrix</code> <code>numpy.ndarray</code> <p>Model matrix of shape (4, 4).</p> required <code>view_matrix</code> <code>numpy.ndarray</code> <p>View matrix of shape (4, 4).</p> required <code>projection_matrix</code> <code>numpy.ndarray</code> <p>Projection matrix of shape (4, 4).</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Transformed vertices of shape (N, 3).</p> Source code in <code>src/gsp/utils/math_utils.py</code> <pre><code>@staticmethod\ndef apply_mvp_to_vertices(vertices: np.ndarray, model_matrix: np.ndarray, view_matrix: np.ndarray, projection_matrix: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Applies Model-View-Projection transformation to the vertices.\n\n    Args:\n        vertices (np.ndarray): Input vertices of shape (N, 3).\n        model_matrix (np.ndarray): Model matrix of shape (4, 4).\n        view_matrix (np.ndarray): View matrix of shape (4, 4).\n        projection_matrix (np.ndarray): Projection matrix of shape (4, 4).\n\n    Returns:\n        np.ndarray: Transformed vertices of shape (N, 3).\n    \"\"\"\n    # sanity checks\n    assert vertices.ndim == 2 and vertices.shape[1] == 3, f\"Expected vertices shape (N, 3), got {vertices.shape}\"\n    assert model_matrix.shape == (4, 4), f\"Expected model_matrix shape (4, 4), got {model_matrix.shape}\"\n    assert view_matrix.shape == (4, 4), f\"Expected view_matrix shape (4, 4), got {view_matrix.shape}\"\n    assert projection_matrix.shape == (4, 4), f\"Expected projection_matrix shape (4, 4), got {projection_matrix.shape}\"\n\n    # Compute the Model-View-Projection (MVP) matrix\n    mvp_matrix = projection_matrix @ view_matrix @ model_matrix\n\n    # convert vertices to homogeneous coordinates (x, y, z) -&gt; (x, y, z, w=1.0)\n    ws_column = np.ones((vertices.shape[0], 1), dtype=np.float32)\n    vertices_homogeneous = np.hstack((vertices, ws_column))  # shape (N, 4) for N vertices\n\n    # Apply the MVP transformation to the vertices\n    vertices_transformed = (mvp_matrix @ vertices_homogeneous.T).T  # shape (N, 4)\n\n    # Perform perspective division to get normalized device coordinates (NDC)\n    vertices_homo_transformed = vertices_transformed / vertices_transformed[:, 3:4]  # divide by w - shape (N, 4)\n    vertices_3d_transformed = vertices_homo_transformed[:, :3]  # drop w-coordinate - shape (N, 3)\n\n    # NOTE: no need to map NDC to screen coordinates as canvas is drawn directly in NDC coordinates 2d\n    pass\n\n    # return the transformed vertices\n    return vertices_3d_transformed\n</code></pre>"},{"location":"api/gsp/#gsp.utils.transbuf_utils","title":"<code>gsp.utils.transbuf_utils</code>","text":"<p>Utility functions for working with TransBuf objects.</p> <p>This module provides helper functions to convert TransBuf instances to Buffer objects, handling both direct Buffer instances and TransformChain objects.</p>"},{"location":"api/gsp/#gsp.utils.transbuf_utils.TransBufUtils","title":"<code>TransBufUtils</code>","text":"<p>Utility class for TransBuf conversions and operations.</p> <p>This class provides static methods for converting TransBuf objects to Buffer objects, supporting both direct Buffer instances and TransformChain objects that need to be executed.</p> Source code in <code>src/gsp/utils/transbuf_utils.py</code> <pre><code>class TransBufUtils:\n    \"\"\"Utility class for TransBuf conversions and operations.\n\n    This class provides static methods for converting TransBuf objects\n    to Buffer objects, supporting both direct Buffer instances and\n    TransformChain objects that need to be executed.\n    \"\"\"\n\n    @staticmethod\n    def to_buffer(trans_buf: TransBuf) -&gt; Buffer:\n        \"\"\"Convert a TransBuf to a Buffer.\n\n        Args:\n            trans_buf: A TransBuf object which can be either a Buffer or a TransformChain.\n\n        Returns:\n            A Buffer object. If the input is already a Buffer, it's returned directly.\n            If it's a TransformChain, it's executed and the resulting Buffer is returned.\n\n        Raises:\n            ValueError: If the trans_buf is neither a Buffer nor a TransformChain.\n        \"\"\"\n        if isinstance(trans_buf, Buffer):\n            buffer = typing.cast(Buffer, trans_buf)\n            return buffer\n        elif isinstance(trans_buf, TransformChain):\n            transform_chain = typing.cast(TransformChain, trans_buf)\n            buffer = transform_chain.run()\n            return buffer\n        else:\n            raise ValueError(f\"Unsupported type for transbuf_to_buffer {type(trans_buf)}\")\n</code></pre>"},{"location":"api/gsp/#gsp.utils.transbuf_utils.TransBufUtils.to_buffer","title":"<code>to_buffer(trans_buf: TransBuf) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Convert a TransBuf to a Buffer.</p> <p>Parameters:</p> Name Type Description Default <code>trans_buf</code> <code>gsp.types.transbuf.TransBuf</code> <p>A TransBuf object which can be either a Buffer or a TransformChain.</p> required <p>Returns:</p> Type Description <code>gsp.types.buffer.Buffer</code> <p>A Buffer object. If the input is already a Buffer, it's returned directly.</p> <code>gsp.types.buffer.Buffer</code> <p>If it's a TransformChain, it's executed and the resulting Buffer is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the trans_buf is neither a Buffer nor a TransformChain.</p> Source code in <code>src/gsp/utils/transbuf_utils.py</code> <pre><code>@staticmethod\ndef to_buffer(trans_buf: TransBuf) -&gt; Buffer:\n    \"\"\"Convert a TransBuf to a Buffer.\n\n    Args:\n        trans_buf: A TransBuf object which can be either a Buffer or a TransformChain.\n\n    Returns:\n        A Buffer object. If the input is already a Buffer, it's returned directly.\n        If it's a TransformChain, it's executed and the resulting Buffer is returned.\n\n    Raises:\n        ValueError: If the trans_buf is neither a Buffer nor a TransformChain.\n    \"\"\"\n    if isinstance(trans_buf, Buffer):\n        buffer = typing.cast(Buffer, trans_buf)\n        return buffer\n    elif isinstance(trans_buf, TransformChain):\n        transform_chain = typing.cast(TransformChain, trans_buf)\n        buffer = transform_chain.run()\n        return buffer\n    else:\n        raise ValueError(f\"Unsupported type for transbuf_to_buffer {type(trans_buf)}\")\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils","title":"<code>gsp.utils.unit_utils</code>","text":"<p>\"Utility functions for unit conversions related to display and typography.</p>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils","title":"<code>UnitUtils</code>","text":"<p>Utility class for unit conversions related to display and typography.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>class UnitUtils:\n    \"\"\"Utility class for unit conversions related to display and typography.\"\"\"\n    @staticmethod\n    def in_to_cm(inches: float) -&gt; float:\n        \"\"\"Convert inches to centimeters.\n\n        Args:\n            inches (float): Length in inches.\n\n        Returns:\n            float: Length in centimeters.\n        \"\"\"\n        return inches * 2.54\n\n    @staticmethod\n    def cm_to_in(cm: float) -&gt; float:\n        \"\"\"Convert centimeters to inches.\n\n        Args:\n            cm (float): Length in centimeters.\n\n        Returns:\n            float: Length in inches.\n        \"\"\"\n        return cm / 2.54\n\n    @staticmethod\n    def device_pixel_ratio() -&gt; float:\n        \"\"\"Get the device pixel ratio for high-DPI displays.\n\n        Returns:\n            float: Device pixel ratio (typically 1.0 for standard displays, &gt;1.0 for high-DPI).\n        \"\"\"\n        # detect if running on a macOS retina display or other high-DPI display\n        # This is a placeholder implementation; actual detection may vary based on the GUI framework used.\n        is_macosx = \"darwin\" in sys.platform\n        if is_macosx:\n            return 2.0  # Common value for retina displays\n        return 1.0\n\n    @staticmethod\n    def pixel_to_point(pixel_size: float, dpi: float) -&gt; float:\n        \"\"\"Convert pixel size to typographic point size based on DPI.\n\n        Args:\n            pixel_size (float): Size in pixels.\n            dpi (float): Dots per inch of the display.\n\n        Returns:\n            float: Size in points.\n        \"\"\"\n        inches_per_pixel = 1.0 / dpi\n        points_per_inch = 72.0\n        point_size = pixel_size * inches_per_pixel * points_per_inch\n        return point_size\n\n    @staticmethod\n    def point_to_pixel(point_size: float, dpi: float) -&gt; float:\n        \"\"\"Convert point size to pixel size based on DPI.\n\n        Args:\n            point_size (float): Size in points.\n            dpi (float): Dots per inch of the display.\n\n        Returns:\n            float: Size in pixels.\n        \"\"\"\n        inches_per_point = 1.0 / 72.0\n        pixels_per_inch = dpi\n        pixel_size = point_size * inches_per_point * pixels_per_inch\n        return pixel_size\n\n    # =============================================================================\n    # numpy array versions\n    # =============================================================================\n\n    @staticmethod\n    def pixel_to_point_numpy(pixel_sizes: np.ndarray, dpi: float) -&gt; np.ndarray:\n        \"\"\"Convert an array of pixel sizes to point sizes based on DPI.\n\n        Args:\n            pixel_sizes (np.ndarray): Array of sizes in pixels.\n            dpi (float): Dots per inch of the display.\n\n        Returns:\n            np.ndarray: Array of sizes in points.\n        \"\"\"\n        inches_per_pixel = 1.0 / dpi\n        points_per_inch = 72.0\n        point_sizes = pixel_sizes * inches_per_pixel * points_per_inch\n        return point_sizes\n\n    @staticmethod\n    def point_to_pixel_numpy(point_sizes: np.ndarray, dpi: float) -&gt; np.ndarray:\n        \"\"\"Convert an array of point sizes to pixel sizes based on DPI.\n\n        Args:\n            point_sizes (np.ndarray): Array of sizes in points.\n            dpi (float): Dots per inch of the display.\n\n        Returns:\n            np.ndarray: Array of sizes in pixels.\n        \"\"\"\n        inches_per_point = 1.0 / 72.0\n        pixels_per_inch = dpi\n        pixel_sizes = point_sizes * inches_per_point * pixels_per_inch\n        return pixel_sizes\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.cm_to_in","title":"<code>cm_to_in(cm: float) -&gt; float</code>  <code>staticmethod</code>","text":"<p>Convert centimeters to inches.</p> <p>Parameters:</p> Name Type Description Default <code>cm</code> <code>float</code> <p>Length in centimeters.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length in inches.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef cm_to_in(cm: float) -&gt; float:\n    \"\"\"Convert centimeters to inches.\n\n    Args:\n        cm (float): Length in centimeters.\n\n    Returns:\n        float: Length in inches.\n    \"\"\"\n    return cm / 2.54\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.device_pixel_ratio","title":"<code>device_pixel_ratio() -&gt; float</code>  <code>staticmethod</code>","text":"<p>Get the device pixel ratio for high-DPI displays.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Device pixel ratio (typically 1.0 for standard displays, &gt;1.0 for high-DPI).</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef device_pixel_ratio() -&gt; float:\n    \"\"\"Get the device pixel ratio for high-DPI displays.\n\n    Returns:\n        float: Device pixel ratio (typically 1.0 for standard displays, &gt;1.0 for high-DPI).\n    \"\"\"\n    # detect if running on a macOS retina display or other high-DPI display\n    # This is a placeholder implementation; actual detection may vary based on the GUI framework used.\n    is_macosx = \"darwin\" in sys.platform\n    if is_macosx:\n        return 2.0  # Common value for retina displays\n    return 1.0\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.in_to_cm","title":"<code>in_to_cm(inches: float) -&gt; float</code>  <code>staticmethod</code>","text":"<p>Convert inches to centimeters.</p> <p>Parameters:</p> Name Type Description Default <code>inches</code> <code>float</code> <p>Length in inches.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length in centimeters.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef in_to_cm(inches: float) -&gt; float:\n    \"\"\"Convert inches to centimeters.\n\n    Args:\n        inches (float): Length in inches.\n\n    Returns:\n        float: Length in centimeters.\n    \"\"\"\n    return inches * 2.54\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.pixel_to_point","title":"<code>pixel_to_point(pixel_size: float, dpi: float) -&gt; float</code>  <code>staticmethod</code>","text":"<p>Convert pixel size to typographic point size based on DPI.</p> <p>Parameters:</p> Name Type Description Default <code>pixel_size</code> <code>float</code> <p>Size in pixels.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch of the display.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Size in points.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef pixel_to_point(pixel_size: float, dpi: float) -&gt; float:\n    \"\"\"Convert pixel size to typographic point size based on DPI.\n\n    Args:\n        pixel_size (float): Size in pixels.\n        dpi (float): Dots per inch of the display.\n\n    Returns:\n        float: Size in points.\n    \"\"\"\n    inches_per_pixel = 1.0 / dpi\n    points_per_inch = 72.0\n    point_size = pixel_size * inches_per_pixel * points_per_inch\n    return point_size\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.pixel_to_point_numpy","title":"<code>pixel_to_point_numpy(pixel_sizes: np.ndarray, dpi: float) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Convert an array of pixel sizes to point sizes based on DPI.</p> <p>Parameters:</p> Name Type Description Default <code>pixel_sizes</code> <code>numpy.ndarray</code> <p>Array of sizes in pixels.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch of the display.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Array of sizes in points.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef pixel_to_point_numpy(pixel_sizes: np.ndarray, dpi: float) -&gt; np.ndarray:\n    \"\"\"Convert an array of pixel sizes to point sizes based on DPI.\n\n    Args:\n        pixel_sizes (np.ndarray): Array of sizes in pixels.\n        dpi (float): Dots per inch of the display.\n\n    Returns:\n        np.ndarray: Array of sizes in points.\n    \"\"\"\n    inches_per_pixel = 1.0 / dpi\n    points_per_inch = 72.0\n    point_sizes = pixel_sizes * inches_per_pixel * points_per_inch\n    return point_sizes\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.point_to_pixel","title":"<code>point_to_pixel(point_size: float, dpi: float) -&gt; float</code>  <code>staticmethod</code>","text":"<p>Convert point size to pixel size based on DPI.</p> <p>Parameters:</p> Name Type Description Default <code>point_size</code> <code>float</code> <p>Size in points.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch of the display.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Size in pixels.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef point_to_pixel(point_size: float, dpi: float) -&gt; float:\n    \"\"\"Convert point size to pixel size based on DPI.\n\n    Args:\n        point_size (float): Size in points.\n        dpi (float): Dots per inch of the display.\n\n    Returns:\n        float: Size in pixels.\n    \"\"\"\n    inches_per_point = 1.0 / 72.0\n    pixels_per_inch = dpi\n    pixel_size = point_size * inches_per_point * pixels_per_inch\n    return pixel_size\n</code></pre>"},{"location":"api/gsp/#gsp.utils.unit_utils.UnitUtils.point_to_pixel_numpy","title":"<code>point_to_pixel_numpy(point_sizes: np.ndarray, dpi: float) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Convert an array of point sizes to pixel sizes based on DPI.</p> <p>Parameters:</p> Name Type Description Default <code>point_sizes</code> <code>numpy.ndarray</code> <p>Array of sizes in points.</p> required <code>dpi</code> <code>float</code> <p>Dots per inch of the display.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>np.ndarray: Array of sizes in pixels.</p> Source code in <code>src/gsp/utils/unit_utils.py</code> <pre><code>@staticmethod\ndef point_to_pixel_numpy(point_sizes: np.ndarray, dpi: float) -&gt; np.ndarray:\n    \"\"\"Convert an array of point sizes to pixel sizes based on DPI.\n\n    Args:\n        point_sizes (np.ndarray): Array of sizes in points.\n        dpi (float): Dots per inch of the display.\n\n    Returns:\n        np.ndarray: Array of sizes in pixels.\n    \"\"\"\n    inches_per_point = 1.0 / 72.0\n    pixels_per_inch = dpi\n    pixel_sizes = point_sizes * inches_per_point * pixels_per_inch\n    return pixel_sizes\n</code></pre>"},{"location":"api/gsp/#gsp.utils.uuid_utils","title":"<code>gsp.utils.uuid_utils</code>","text":"<p>Utility functions for UUID generation.</p>"},{"location":"api/gsp/#gsp.utils.uuid_utils.UuidUtils","title":"<code>UuidUtils</code>","text":"<p>Utility class for generating UUIDs.</p> Source code in <code>src/gsp/utils/uuid_utils.py</code> <pre><code>class UuidUtils:\n    \"\"\"Utility class for generating UUIDs.\"\"\"\n\n    GSP_UUID_COUNTER: int = 0\n\n    @staticmethod\n    def generate_uuid() -&gt; str:\n        \"\"\"Generate a UUID version 4.\n\n        Returns:\n            str: The generated UUID.\n        \"\"\"\n        # if GSP_UUID_COUNTER is set, use a deterministic uuid for testing purposes\n        # - uuid becomes \"uuid-counter-&lt;counter&gt;\"\n        if \"GSP_UUID_COUNTER\" in os.environ:\n            _uuid = UuidUtils.GSP_UUID_COUNTER\n            UuidUtils.GSP_UUID_COUNTER += 1\n            return f\"uuid-counter-{_uuid}\"\n\n        # uuid4 = UuidUtils._generate_uuid_v4_with_uuid()\n        uuid4 = UuidUtils._generate_uuid_v4_with_numpy()\n        return uuid4\n\n    @staticmethod\n    def _generate_uuid_v4_with_numpy() -&gt; str:\n        \"\"\"Generate a UUID version 4 using numpy for random byte generation.\n\n        Thus it can be made deterministic by setting the numpy random seed.\n        \"\"\"\n        # 1. Generate 16 random bytes (128 bits) using numpy\n        # We use uint8 for byte representation\n        random_bytes = np.random.randint(0, 256, size=16, dtype=np.uint8)\n\n        # Convert the numpy array of bytes into a standard Python byte string\n        # This is necessary because bit manipulation on numpy arrays is tricky/non-standard\n        byte_string = bytes(random_bytes.tolist())\n\n        # 2. Apply the UUID version 4 (variant 1) rules:\n\n        # Rule 1: Set the four most significant bits of the 7th byte (octet 6) to 0100_2\n        # This sets the UUID version to 4.\n        # The 7th byte is at index 6 (0-indexed).\n        # To set the first four bits to 0100 (4 in hex), we clear the upper 4 bits\n        # and then set them to 4. (byte_string[6] &amp; 0b1111) clears the upper bits,\n        # then | 0x40 is wrong. It should be (byte_string[6] &amp; 0x0F) | 0x40.\n\n        # We must use a mutable structure to modify the bytes.\n        # We'll use a standard Python list of integers (0-255) for easy modification.\n        byte_list = list(byte_string)\n\n        # Set Version (byte 6, index 6): 0x40 (0100xxxx)\n        byte_list[6] = (byte_list[6] &amp; 0x0F) | 0x40\n\n        # Rule 2: Set the two most significant bits of the 9th byte (octet 8) to 10_2\n        # This sets the UUID variant to 'Reserved (RFC 4122)'.\n        # The 9th byte is at index 8.\n        # To set the first two bits to 10 (8 in hex or 0x80), we clear the upper 2 bits\n        # and then set them to 10. (byte_list[8] &amp; 0x3F) clears the upper 2 bits,\n        # then | 0x80 sets them to 10.\n        byte_list[8] = (byte_list[8] &amp; 0x3F) | 0x80\n\n        # 3. Format the bytes into a standard UUID string format (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)\n        # We convert the list back to bytes and then to hexadecimal.\n        final_bytes = bytes(byte_list)\n        hex_str = final_bytes.hex()\n\n        # Insert hyphens\n        uuid_v4 = f\"{hex_str[0:8]}-{hex_str[8:12]}-{hex_str[12:16]}-{hex_str[16:20]}-{hex_str[20:32]}\"\n\n        return uuid_v4\n\n    @staticmethod\n    def _generate_uuid_v4_with_uuid() -&gt; str:\n        \"\"\"Generate a UUID version 4 using the standard library uuid module.\"\"\"\n        import uuid\n\n        uuid_v4 = str(uuid.uuid4())\n\n        return uuid_v4\n</code></pre>"},{"location":"api/gsp/#gsp.utils.uuid_utils.UuidUtils.generate_uuid","title":"<code>generate_uuid() -&gt; str</code>  <code>staticmethod</code>","text":"<p>Generate a UUID version 4.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated UUID.</p> Source code in <code>src/gsp/utils/uuid_utils.py</code> <pre><code>@staticmethod\ndef generate_uuid() -&gt; str:\n    \"\"\"Generate a UUID version 4.\n\n    Returns:\n        str: The generated UUID.\n    \"\"\"\n    # if GSP_UUID_COUNTER is set, use a deterministic uuid for testing purposes\n    # - uuid becomes \"uuid-counter-&lt;counter&gt;\"\n    if \"GSP_UUID_COUNTER\" in os.environ:\n        _uuid = UuidUtils.GSP_UUID_COUNTER\n        UuidUtils.GSP_UUID_COUNTER += 1\n        return f\"uuid-counter-{_uuid}\"\n\n    # uuid4 = UuidUtils._generate_uuid_v4_with_uuid()\n    uuid4 = UuidUtils._generate_uuid_v4_with_numpy()\n    return uuid4\n</code></pre>"},{"location":"api/gsp/#constants","title":"Constants","text":""},{"location":"api/gsp/#gsp.constants","title":"<code>gsp.constants</code>","text":"<p>Common constants for GSP including color definitions.</p>"},{"location":"api/gsp/#gsp.constants.Constants","title":"<code>Constants</code>","text":"<p>Common constants in GSP. e.g. colors.</p> Source code in <code>src/gsp/constants.py</code> <pre><code>class Constants:\n    \"\"\"Common constants in GSP. e.g. colors.\"\"\"\n\n    class Color:\n        \"\"\"Common colors as RGBA bytearrays.\n\n        Each color is represented as a bytearray of four integers\n        corresponding to the red, green, blue, and alpha (opacity) channels, respectively.\n        Each channel value ranges from 0 to 255.\n        \"\"\"\n\n        white = bytearray([255, 255, 255, 255])\n        black = bytearray([0, 0, 0, 255])\n        red = bytearray([255, 0, 0, 255])\n        green = bytearray([0, 255, 0, 255])\n        blue = bytearray([0, 0, 255, 255])\n\n        yellow = bytearray([255, 255, 0, 255])\n        magenta = bytearray([255, 0, 255, 255])\n        cyan = bytearray([0, 255, 255, 255])\n\n        light_gray = bytearray([211, 211, 211, 255])\n        gray = bytearray([128, 128, 128, 255])\n        dark_gray = bytearray([64, 64, 64, 255])\n\n        transparent = bytearray([0, 0, 0, 0])\n</code></pre>"},{"location":"api/gsp/#gsp.constants.Constants.Color","title":"<code>Color</code>","text":"<p>Common colors as RGBA bytearrays.</p> <p>Each color is represented as a bytearray of four integers corresponding to the red, green, blue, and alpha (opacity) channels, respectively. Each channel value ranges from 0 to 255.</p> Source code in <code>src/gsp/constants.py</code> <pre><code>class Color:\n    \"\"\"Common colors as RGBA bytearrays.\n\n    Each color is represented as a bytearray of four integers\n    corresponding to the red, green, blue, and alpha (opacity) channels, respectively.\n    Each channel value ranges from 0 to 255.\n    \"\"\"\n\n    white = bytearray([255, 255, 255, 255])\n    black = bytearray([0, 0, 0, 255])\n    red = bytearray([255, 0, 0, 255])\n    green = bytearray([0, 255, 0, 255])\n    blue = bytearray([0, 0, 255, 255])\n\n    yellow = bytearray([255, 255, 0, 255])\n    magenta = bytearray([255, 0, 255, 255])\n    cyan = bytearray([0, 255, 255, 255])\n\n    light_gray = bytearray([211, 211, 211, 255])\n    gray = bytearray([128, 128, 128, 255])\n    dark_gray = bytearray([64, 64, 64, 255])\n\n    transparent = bytearray([0, 0, 0, 0])\n</code></pre>"},{"location":"api/gsp_datoviz/","title":"GSP Datoviz API Reference","text":"<p>The GSP Datoviz backend provides high-performance rendering using the Datoviz library.</p>"},{"location":"api/gsp_datoviz/#overview","title":"Overview","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz","title":"<code>gsp_datoviz</code>","text":"<p>GSP Datoviz package.</p>"},{"location":"api/gsp_datoviz/#renderer-module","title":"Renderer Module","text":"<p>The renderer module contains the main Datoviz renderer implementation and specialized renderers for different visual types.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer","title":"<code>gsp_datoviz.renderer</code>","text":"<p>Renderer module for GSP Datoviz.</p>"},{"location":"api/gsp_datoviz/#datoviz-renderer","title":"Datoviz Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer","title":"<code>gsp_datoviz.renderer.datoviz_renderer</code>","text":"<p>Datoviz renderer implementation.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer","title":"<code>DatovizRenderer</code>","text":"<p>               Bases: <code>gsp.types.renderer_base.RendererBase</code></p> <p>Datoviz renderer implementation.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>class DatovizRenderer(RendererBase):\n    \"\"\"Datoviz renderer implementation.\"\"\"\n    def __init__(self, canvas: Canvas, offscreen: bool = False) -&gt; None:\n        \"\"\"Initialize the Datoviz renderer.\n\n        Args:\n            canvas (Canvas): The GSP canvas to render on.\n            offscreen (bool, optional): Whether to run the datoviz App in offscreen mode. Defaults to False.\n        \"\"\"\n        self._canvas = canvas\n        self._dvz_app: dvz.App = dvz.App(background=\"white\", offscreen=offscreen)\n        self._dvz_offscreen = offscreen\n        self._dvz_figure: _DvzFigure = self._dvz_app.figure(\n            width=canvas.get_width(),\n            height=canvas.get_height(),\n        )\n        self._dvz_panels: dict[str, _DvzPanel] = {}\n        \"\"\"datoviz panel per gsp viewport UUID\"\"\"\n        self._dvz_visuals: dict[str, _DvzVisual] = {}\n        \"\"\"datoviz visual per gsp visual group UUID\"\"\"\n\n        self._group_count: dict[str, int] = {}\n        \"\"\"group count per visual UUID\"\"\"\n\n    def close(self) -&gt; None:\n        \"\"\"Close the datoviz renderer and its app.\"\"\"\n        self._dvz_app.destroy()\n\n    def get_canvas(self) -&gt; Canvas:\n        \"\"\"Get the GSP canvas associated with the renderer.\"\"\"\n        return self._canvas\n\n    def get_dvz_app(self) -&gt; dvz.App:\n        \"\"\"Get the datoviz App associated with the renderer.\"\"\"\n        return self._dvz_app\n\n    def get_dvz_figure(self) -&gt; _DvzFigure:\n        \"\"\"Get the datoviz Figure associated with the renderer.\"\"\"\n        return self._dvz_figure\n\n    def show(self) -&gt; None:\n        \"\"\"Show the datoviz window and start the app.\"\"\"\n        # handle non-interactive mode for tests\n        in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n        if in_test:\n            return\n\n        # listen to keyboard events - if 'q' is pressed, stop the app\n        @self._dvz_app.connect(self._dvz_figure)\n        def on_keyboard(event):\n            # print(f\"{event.key_event()} key {event.key()} ({event.key_name()})\")\n            if event.key_event() == \"press\" and event.key_name() == \"q\":\n                self._dvz_app.stop()\n\n        # run the datoviz app to show the window\n        self._dvz_app.run()\n\n    # =============================================================================\n    # .render() function\n    # =============================================================================\n    def render(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n        return_image: bool = True,  # NOTE: make False by default. datoviz screenshot can cause segmentation fault in some cases\n        image_format: str = \"png\",\n    ) -&gt; bytes:\n        \"\"\"Render the given viewports and visuals using datoviz.\n\n        Args:\n            viewports (Sequence[Viewport]): Sequence of viewports to render.\n            visuals (Sequence[VisualBase]): Sequence of visual objects to render.\n            model_matrices (Sequence[TransBuf]): Sequence of transformation buffers for the visuals.\n            cameras (Sequence[Camera]): Sequence of cameras for each viewport.\n            return_image (bool, optional): Whether to return the rendered image as bytes. Defaults to True.\n            image_format (str, optional): The image format to return (\"png\"). Defaults to \"png\".\n\n        Returns:\n            bytes: The rendered image data if return_image is True, else empty bytes.\n        \"\"\"\n        # =============================================================================\n        # Create all viewport if needed\n        # =============================================================================\n\n        for viewport in viewports:\n            _dvz_panel = self._getOrCreateDvzPanel(viewport)\n\n        # =============================================================================\n        # Render all visual\n        # =============================================================================\n\n        for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n            self._render_visual(viewport, visual, model_matrix, camera)\n\n        # =============================================================================\n        # Return an image if needed\n        # =============================================================================\n\n        # sanity check\n        has_offscreen = bool(self._dvz_app.c_flags | dvz.APP_FLAGS_OFFSCREEN)\n        if return_image and not has_offscreen:\n            raise Exception(\"DatovizRenderer.render(): cannot return image when datoviz App is not in offscreen mode\")\n\n        rendered_image = b\"\"\n        if return_image:\n            if self._dvz_offscreen is True:\n                assert image_format in [\"png\"], f\"Unsupported image format: {image_format}\"\n                image_path = pathlib.Path(__file__).parent / \"_datoviz_offscreen_python.png\"\n                self._dvz_app.screenshot(self._dvz_figure, str(image_path))\n                with open(image_path, \"rb\") as file_reader:\n                    rendered_image = file_reader.read()\n                image_path.unlink()\n            else:\n                # NOTE: datoviz requires the datoviz App to be in offscreen mode to capture screenshot\n                # - this is a workaround to init a temporary offscreen datoviz App to capture the image\n\n                # Init a temporary offscreen datoviz renderer to capture the image\n                _renderer_offscreen = DatovizRenderer(self._canvas, offscreen=True)\n                # do render call\n                rendered_image = _renderer_offscreen.render(viewports, visuals, model_matrices, cameras, return_image=True)\n                # close the offscreen renderer\n                _renderer_offscreen.close()\n\n        return rendered_image\n\n    # =============================================================================\n    # ._render_pixels()\n    # =============================================================================\n\n    def _render_visual(self, viewport: Viewport, visual: VisualBase, model_matrix: TransBuf, camera: Camera) -&gt; None:\n        if isinstance(visual, Pixels):\n            from .datoviz_renderer_pixels import DatovizRendererPixels\n\n            DatovizRendererPixels.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Points):\n            from .datoviz_renderer_points import DatovizRendererPoints\n\n            DatovizRendererPoints.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Paths):\n            from .datoviz_renderer_paths import DatovizRendererPaths\n\n            DatovizRendererPaths.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Markers):\n            from .datoviz_renderer_markers import DatovizRendererMarkers\n\n            DatovizRendererMarkers.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Segments):\n            from .datoviz_renderer_segments import DatovizRendererSegments\n\n            DatovizRendererSegments.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Texts):\n            from .datoviz_renderer_texts import DatovizRendererTexts\n\n            DatovizRendererTexts.render(self, viewport, visual, model_matrix, camera)\n        else:\n            raise NotImplementedError(f\"DatovizRenderer.render() does not support visual of type {type(visual)}\")\n\n    # =============================================================================\n    # Get or create datoviz panel for viewport\n    # =============================================================================\n\n    def _getOrCreateDvzPanel(self, viewport: Viewport) -&gt; _DvzPanel:\n        viewport_uuid = viewport.get_uuid()\n        # if it already exists, return it\n        if viewport_uuid in self._dvz_panels:\n            return self._dvz_panels[viewport_uuid]\n\n        # create the datoviz panel\n        dvz_offset = (viewport.get_x(), self.get_canvas().get_height() - viewport.get_y() - viewport.get_height())\n        # dvz_offset = (viewport.get_x(), viewport.get_y())\n        dvz_size = (viewport.get_width(), viewport.get_height())\n        dvz_panel = self._dvz_figure.panel(\n            offset=dvz_offset,\n            size=dvz_size,\n        )\n\n        # store it\n        self._dvz_panels[viewport_uuid] = dvz_panel\n\n        # return newly created panel\n        return dvz_panel\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.__init__","title":"<code>__init__(canvas: Canvas, offscreen: bool = False) -&gt; None</code>","text":"<p>Initialize the Datoviz renderer.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>gsp.core.canvas.Canvas</code> <p>The GSP canvas to render on.</p> required <code>offscreen</code> <code>bool</code> <p>Whether to run the datoviz App in offscreen mode. Defaults to False.</p> <code>False</code> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def __init__(self, canvas: Canvas, offscreen: bool = False) -&gt; None:\n    \"\"\"Initialize the Datoviz renderer.\n\n    Args:\n        canvas (Canvas): The GSP canvas to render on.\n        offscreen (bool, optional): Whether to run the datoviz App in offscreen mode. Defaults to False.\n    \"\"\"\n    self._canvas = canvas\n    self._dvz_app: dvz.App = dvz.App(background=\"white\", offscreen=offscreen)\n    self._dvz_offscreen = offscreen\n    self._dvz_figure: _DvzFigure = self._dvz_app.figure(\n        width=canvas.get_width(),\n        height=canvas.get_height(),\n    )\n    self._dvz_panels: dict[str, _DvzPanel] = {}\n    \"\"\"datoviz panel per gsp viewport UUID\"\"\"\n    self._dvz_visuals: dict[str, _DvzVisual] = {}\n    \"\"\"datoviz visual per gsp visual group UUID\"\"\"\n\n    self._group_count: dict[str, int] = {}\n    \"\"\"group count per visual UUID\"\"\"\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the datoviz renderer and its app.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the datoviz renderer and its app.\"\"\"\n    self._dvz_app.destroy()\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.get_canvas","title":"<code>get_canvas() -&gt; Canvas</code>","text":"<p>Get the GSP canvas associated with the renderer.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def get_canvas(self) -&gt; Canvas:\n    \"\"\"Get the GSP canvas associated with the renderer.\"\"\"\n    return self._canvas\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.get_dvz_app","title":"<code>get_dvz_app() -&gt; dvz.App</code>","text":"<p>Get the datoviz App associated with the renderer.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def get_dvz_app(self) -&gt; dvz.App:\n    \"\"\"Get the datoviz App associated with the renderer.\"\"\"\n    return self._dvz_app\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.get_dvz_figure","title":"<code>get_dvz_figure() -&gt; _DvzFigure</code>","text":"<p>Get the datoviz Figure associated with the renderer.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def get_dvz_figure(self) -&gt; _DvzFigure:\n    \"\"\"Get the datoviz Figure associated with the renderer.\"\"\"\n    return self._dvz_figure\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.render","title":"<code>render(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera], return_image: bool = True, image_format: str = 'png') -&gt; bytes</code>","text":"<p>Render the given viewports and visuals using datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>Sequence of viewports to render.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>Sequence of visual objects to render.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>Sequence of transformation buffers for the visuals.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>Sequence of cameras for each viewport.</p> required <code>return_image</code> <code>bool</code> <p>Whether to return the rendered image as bytes. Defaults to True.</p> <code>True</code> <code>image_format</code> <code>str</code> <p>The image format to return (\"png\"). Defaults to \"png\".</p> <code>'png'</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The rendered image data if return_image is True, else empty bytes.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def render(\n    self,\n    viewports: Sequence[Viewport],\n    visuals: Sequence[VisualBase],\n    model_matrices: Sequence[TransBuf],\n    cameras: Sequence[Camera],\n    return_image: bool = True,  # NOTE: make False by default. datoviz screenshot can cause segmentation fault in some cases\n    image_format: str = \"png\",\n) -&gt; bytes:\n    \"\"\"Render the given viewports and visuals using datoviz.\n\n    Args:\n        viewports (Sequence[Viewport]): Sequence of viewports to render.\n        visuals (Sequence[VisualBase]): Sequence of visual objects to render.\n        model_matrices (Sequence[TransBuf]): Sequence of transformation buffers for the visuals.\n        cameras (Sequence[Camera]): Sequence of cameras for each viewport.\n        return_image (bool, optional): Whether to return the rendered image as bytes. Defaults to True.\n        image_format (str, optional): The image format to return (\"png\"). Defaults to \"png\".\n\n    Returns:\n        bytes: The rendered image data if return_image is True, else empty bytes.\n    \"\"\"\n    # =============================================================================\n    # Create all viewport if needed\n    # =============================================================================\n\n    for viewport in viewports:\n        _dvz_panel = self._getOrCreateDvzPanel(viewport)\n\n    # =============================================================================\n    # Render all visual\n    # =============================================================================\n\n    for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n        self._render_visual(viewport, visual, model_matrix, camera)\n\n    # =============================================================================\n    # Return an image if needed\n    # =============================================================================\n\n    # sanity check\n    has_offscreen = bool(self._dvz_app.c_flags | dvz.APP_FLAGS_OFFSCREEN)\n    if return_image and not has_offscreen:\n        raise Exception(\"DatovizRenderer.render(): cannot return image when datoviz App is not in offscreen mode\")\n\n    rendered_image = b\"\"\n    if return_image:\n        if self._dvz_offscreen is True:\n            assert image_format in [\"png\"], f\"Unsupported image format: {image_format}\"\n            image_path = pathlib.Path(__file__).parent / \"_datoviz_offscreen_python.png\"\n            self._dvz_app.screenshot(self._dvz_figure, str(image_path))\n            with open(image_path, \"rb\") as file_reader:\n                rendered_image = file_reader.read()\n            image_path.unlink()\n        else:\n            # NOTE: datoviz requires the datoviz App to be in offscreen mode to capture screenshot\n            # - this is a workaround to init a temporary offscreen datoviz App to capture the image\n\n            # Init a temporary offscreen datoviz renderer to capture the image\n            _renderer_offscreen = DatovizRenderer(self._canvas, offscreen=True)\n            # do render call\n            rendered_image = _renderer_offscreen.render(viewports, visuals, model_matrices, cameras, return_image=True)\n            # close the offscreen renderer\n            _renderer_offscreen.close()\n\n    return rendered_image\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer.show","title":"<code>show() -&gt; None</code>","text":"<p>Show the datoviz window and start the app.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the datoviz window and start the app.\"\"\"\n    # handle non-interactive mode for tests\n    in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n    if in_test:\n        return\n\n    # listen to keyboard events - if 'q' is pressed, stop the app\n    @self._dvz_app.connect(self._dvz_figure)\n    def on_keyboard(event):\n        # print(f\"{event.key_event()} key {event.key()} ({event.key_name()})\")\n        if event.key_event() == \"press\" and event.key_name() == \"q\":\n            self._dvz_app.stop()\n\n    # run the datoviz app to show the window\n    self._dvz_app.run()\n</code></pre>"},{"location":"api/gsp_datoviz/#markers-renderer","title":"Markers Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_markers","title":"<code>gsp_datoviz.renderer.datoviz_renderer_markers</code>","text":"<p>\"Datoviz renderer for Markers visuals.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_markers.DatovizRendererMarkers","title":"<code>DatovizRendererMarkers</code>","text":"<p>Datoviz renderer for Markers visuals.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_markers.py</code> <pre><code>class DatovizRendererMarkers:\n    \"\"\"Datoviz renderer for Markers visuals.\"\"\"\n    @staticmethod\n    def render(\n        renderer: DatovizRenderer,\n        viewport: Viewport,\n        markers: Markers,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; None:\n        \"\"\"Render Markers visuals using Datoviz.\n\n        Args:\n            renderer (DatovizRenderer): The Datoviz renderer instance.\n            viewport (Viewport): The viewport to render in.\n            markers (Markers): The Markers visual to render.\n            model_matrix (TransBuf): The model matrix for the visual.\n            camera (Camera): The camera used for rendering.\n        \"\"\"\n        dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(markers.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 3d - shape (N, 3)\n        vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        sizes_buffer = TransBufUtils.to_buffer(markers.get_sizes())\n        face_colors_buffer = TransBufUtils.to_buffer(markers.get_face_colors())\n        edge_colors_buffer = TransBufUtils.to_buffer(markers.get_edge_colors())\n        edge_widths_buffer = TransBufUtils.to_buffer(markers.get_edge_widths())\n\n        # Convert buffers to numpy arrays)\n        sizes_pt2_numpy = Bufferx.to_numpy(sizes_buffer)\n        face_colors_numpy = Bufferx.to_numpy(face_colors_buffer)\n        edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer)\n        edge_widths_pt_numpy = Bufferx.to_numpy(edge_widths_buffer)\n\n        # Convert sizes from point^2 to pixel\n        radius_pt_numpy = np.sqrt(sizes_pt2_numpy / np.pi)\n        radius_px_numpy = UnitUtils.point_to_pixel_numpy(radius_pt_numpy, renderer.get_canvas().get_dpi())\n        diameter_px_numpy = radius_px_numpy * 2.0 * UnitUtils.device_pixel_ratio()\n        diameter_px_numpy = diameter_px_numpy.reshape(-1)\n\n        edge_widths_px_numpy = UnitUtils.point_to_pixel_numpy(edge_widths_pt_numpy, renderer.get_canvas().get_dpi())\n        edge_widths_px_numpy = edge_widths_px_numpy * UnitUtils.device_pixel_ratio()\n        edge_widths_px_numpy = edge_widths_px_numpy.reshape(-1)\n\n        # =============================================================================\n        # Create the datoviz visual if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{markers.get_uuid()}\"\n\n        # Create datoviz_visual if they do not exist\n        if artist_uuid not in renderer._dvz_visuals:\n            dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n            dvz_markers = renderer._dvz_app.marker(position=dummy_position_numpy)\n            renderer._dvz_visuals[artist_uuid] = dvz_markers\n            # Add the new visual to the panel\n            dvz_panel.add(dvz_markers)\n\n        # =============================================================================\n        # Update all attributes\n        # =============================================================================\n\n        # get the datoviz visual\n        dvz_markers = typing.cast(_DvzMarkers, renderer._dvz_visuals[artist_uuid])\n\n        # set attributes\n        dvz_markers.set_position(vertices_3d)\n\n        # Set the proper parameters\n        dvz_markers.set_size(diameter_px_numpy)\n        dvz_markers.set_color(face_colors_numpy)\n        dvz_markers.set_linewidth(edge_widths_px_numpy[0])\n        dvz_markers.set_edgecolor(edge_colors_numpy[0].tolist())  # datoviz only supports a single edge color\n\n        # sanity check - if edge_widths_px_numpy are not all the same, warn the user\n        if not np.all(edge_widths_px_numpy == edge_widths_px_numpy[0]):\n            warnings.warn(\"DatovizRendererMarkers: edge widths per marker are not fully supported by datoviz. \" \"Using the first edge width for all markers.\")\n        # sanity check - if edge_colors_numpy are not all the same, warn the user\n        if not np.all(edge_colors_numpy == edge_colors_numpy[0]):\n            warnings.warn(\"DatovizRendererMarkers: edge colors per marker are not fully supported by datoviz. \" \"Using the first edge color for all markers.\")\n\n        # Set mode, shape and aspect\n        dvz_markers.set_mode(\"code\")\n        dvz_markers.set_shape(ConverterUtils.marker_shape_gsp_to_dvz(markers.get_marker_shape()))\n\n        # Determine the `aspect` depending on face and edge colors/widths\n        is_face_color_transparent = bool(np.all(face_colors_numpy[:, 3] == 0))\n        is_edge_color_transparent = bool(np.all(edge_colors_numpy[:, 3] == 0))\n        is_edge_width_zero = bool(np.all(edge_widths_px_numpy == 0))\n        has_edge = not is_edge_color_transparent and not is_edge_width_zero\n        if not is_face_color_transparent:\n            if has_edge:\n                dvz_markers.set_aspect(\"outline\")\n            else:\n                dvz_markers.set_aspect(\"filled\")\n        else:\n            dvz_markers.set_aspect(\"stroke\")\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_markers.DatovizRendererMarkers.render","title":"<code>render(renderer: DatovizRenderer, viewport: Viewport, markers: Markers, model_matrix: TransBuf, camera: Camera) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Render Markers visuals using Datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer</code> <p>The Datoviz renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render in.</p> required <code>markers</code> <code>gsp.visuals.markers.Markers</code> <p>The Markers visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model matrix for the visual.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera used for rendering.</p> required Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_markers.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: DatovizRenderer,\n    viewport: Viewport,\n    markers: Markers,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; None:\n    \"\"\"Render Markers visuals using Datoviz.\n\n    Args:\n        renderer (DatovizRenderer): The Datoviz renderer instance.\n        viewport (Viewport): The viewport to render in.\n        markers (Markers): The Markers visual to render.\n        model_matrix (TransBuf): The model matrix for the visual.\n        camera (Camera): The camera used for rendering.\n    \"\"\"\n    dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(markers.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 3d - shape (N, 3)\n    vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    sizes_buffer = TransBufUtils.to_buffer(markers.get_sizes())\n    face_colors_buffer = TransBufUtils.to_buffer(markers.get_face_colors())\n    edge_colors_buffer = TransBufUtils.to_buffer(markers.get_edge_colors())\n    edge_widths_buffer = TransBufUtils.to_buffer(markers.get_edge_widths())\n\n    # Convert buffers to numpy arrays)\n    sizes_pt2_numpy = Bufferx.to_numpy(sizes_buffer)\n    face_colors_numpy = Bufferx.to_numpy(face_colors_buffer)\n    edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer)\n    edge_widths_pt_numpy = Bufferx.to_numpy(edge_widths_buffer)\n\n    # Convert sizes from point^2 to pixel\n    radius_pt_numpy = np.sqrt(sizes_pt2_numpy / np.pi)\n    radius_px_numpy = UnitUtils.point_to_pixel_numpy(radius_pt_numpy, renderer.get_canvas().get_dpi())\n    diameter_px_numpy = radius_px_numpy * 2.0 * UnitUtils.device_pixel_ratio()\n    diameter_px_numpy = diameter_px_numpy.reshape(-1)\n\n    edge_widths_px_numpy = UnitUtils.point_to_pixel_numpy(edge_widths_pt_numpy, renderer.get_canvas().get_dpi())\n    edge_widths_px_numpy = edge_widths_px_numpy * UnitUtils.device_pixel_ratio()\n    edge_widths_px_numpy = edge_widths_px_numpy.reshape(-1)\n\n    # =============================================================================\n    # Create the datoviz visual if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{markers.get_uuid()}\"\n\n    # Create datoviz_visual if they do not exist\n    if artist_uuid not in renderer._dvz_visuals:\n        dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n        dvz_markers = renderer._dvz_app.marker(position=dummy_position_numpy)\n        renderer._dvz_visuals[artist_uuid] = dvz_markers\n        # Add the new visual to the panel\n        dvz_panel.add(dvz_markers)\n\n    # =============================================================================\n    # Update all attributes\n    # =============================================================================\n\n    # get the datoviz visual\n    dvz_markers = typing.cast(_DvzMarkers, renderer._dvz_visuals[artist_uuid])\n\n    # set attributes\n    dvz_markers.set_position(vertices_3d)\n\n    # Set the proper parameters\n    dvz_markers.set_size(diameter_px_numpy)\n    dvz_markers.set_color(face_colors_numpy)\n    dvz_markers.set_linewidth(edge_widths_px_numpy[0])\n    dvz_markers.set_edgecolor(edge_colors_numpy[0].tolist())  # datoviz only supports a single edge color\n\n    # sanity check - if edge_widths_px_numpy are not all the same, warn the user\n    if not np.all(edge_widths_px_numpy == edge_widths_px_numpy[0]):\n        warnings.warn(\"DatovizRendererMarkers: edge widths per marker are not fully supported by datoviz. \" \"Using the first edge width for all markers.\")\n    # sanity check - if edge_colors_numpy are not all the same, warn the user\n    if not np.all(edge_colors_numpy == edge_colors_numpy[0]):\n        warnings.warn(\"DatovizRendererMarkers: edge colors per marker are not fully supported by datoviz. \" \"Using the first edge color for all markers.\")\n\n    # Set mode, shape and aspect\n    dvz_markers.set_mode(\"code\")\n    dvz_markers.set_shape(ConverterUtils.marker_shape_gsp_to_dvz(markers.get_marker_shape()))\n\n    # Determine the `aspect` depending on face and edge colors/widths\n    is_face_color_transparent = bool(np.all(face_colors_numpy[:, 3] == 0))\n    is_edge_color_transparent = bool(np.all(edge_colors_numpy[:, 3] == 0))\n    is_edge_width_zero = bool(np.all(edge_widths_px_numpy == 0))\n    has_edge = not is_edge_color_transparent and not is_edge_width_zero\n    if not is_face_color_transparent:\n        if has_edge:\n            dvz_markers.set_aspect(\"outline\")\n        else:\n            dvz_markers.set_aspect(\"filled\")\n    else:\n        dvz_markers.set_aspect(\"stroke\")\n</code></pre>"},{"location":"api/gsp_datoviz/#paths-renderer","title":"Paths Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_paths","title":"<code>gsp_datoviz.renderer.datoviz_renderer_paths</code>","text":"<p>Datoviz renderer for Paths visuals.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_paths.DatovizRendererPaths","title":"<code>DatovizRendererPaths</code>","text":"<p>Datoviz renderer for Paths visuals.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_paths.py</code> <pre><code>class DatovizRendererPaths:\n    \"\"\"Datoviz renderer for Paths visuals.\"\"\"\n    @staticmethod\n    def render(\n        renderer: DatovizRenderer,\n        viewport: Viewport,\n        paths: Paths,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; None:\n        \"\"\"Render Paths visuals using Datoviz.\n\n        Args:\n            renderer (DatovizRenderer): The Datoviz renderer instance.\n            viewport (Viewport): The viewport to render in.\n            paths (Paths): The Paths visual to render.\n            model_matrix (TransBuf): The model matrix for the visual.\n            camera (Camera): The camera used for rendering.\n        \"\"\"\n        dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(paths.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 3d - shape (N, 3)\n        vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n        # =============================================================================\n        # Get attributes\n        # =============================================================================\n\n        # get attributes from TransBuf to buffer\n        path_sizes_buffer = TransBufUtils.to_buffer(paths.get_path_sizes())\n        colors_buffer = TransBufUtils.to_buffer(paths.get_colors())\n        line_widths_buffer = TransBufUtils.to_buffer(paths.get_line_widths())\n\n        # convert buffers to numpy arrays\n        path_sizes_numpy = Bufferx.to_numpy(path_sizes_buffer)\n        colors_numpy = Bufferx.to_numpy(colors_buffer)\n        line_widths_pt_numpy = Bufferx.to_numpy(line_widths_buffer)\n\n        # Convert sizes from point^2 to pixel diameter\n        line_widths_px_numpy = UnitUtils.point_to_pixel_numpy(line_widths_pt_numpy, renderer.get_canvas().get_dpi())\n\n        path_sizes_numpy = path_sizes_numpy.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n        line_widths_px_numpy = line_widths_px_numpy.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n\n        # =============================================================================\n        # Create the datoviz visual if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{paths.get_uuid()}\"\n\n        # Create datoviz_visual if they do not exist\n        if artist_uuid not in renderer._dvz_visuals:\n            dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n            dummy_path_sizes_numpy = np.array([1], dtype=np.uint32)\n            dvz_paths = renderer._dvz_app.path()\n            dvz_paths.set_position(dummy_position_numpy, groups=dummy_path_sizes_numpy)\n            renderer._dvz_visuals[artist_uuid] = dvz_paths\n            # Add the new visual to the panel\n            dvz_panel.add(dvz_paths)\n\n        # =============================================================================\n        # Update all attributes\n        # =============================================================================\n\n        # get the datoviz visual\n        dvz_paths = typing.cast(_DvzPaths, renderer._dvz_visuals[artist_uuid])\n\n        dvz_paths.set_position(vertices_3d, groups=path_sizes_numpy)\n        dvz_paths.set_color(colors_numpy)\n        dvz_paths.set_linewidth(line_widths_px_numpy)\n        dvz_paths.set_cap(ConverterUtils.cap_style_gsp_to_dvz(paths.get_cap_style()))\n        dvz_paths.set_join(ConverterUtils.join_style_gsp_to_dvz(paths.get_join_style()))\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_paths.DatovizRendererPaths.render","title":"<code>render(renderer: DatovizRenderer, viewport: Viewport, paths: Paths, model_matrix: TransBuf, camera: Camera) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Render Paths visuals using Datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer</code> <p>The Datoviz renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render in.</p> required <code>paths</code> <code>gsp.visuals.paths.Paths</code> <p>The Paths visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model matrix for the visual.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera used for rendering.</p> required Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_paths.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: DatovizRenderer,\n    viewport: Viewport,\n    paths: Paths,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; None:\n    \"\"\"Render Paths visuals using Datoviz.\n\n    Args:\n        renderer (DatovizRenderer): The Datoviz renderer instance.\n        viewport (Viewport): The viewport to render in.\n        paths (Paths): The Paths visual to render.\n        model_matrix (TransBuf): The model matrix for the visual.\n        camera (Camera): The camera used for rendering.\n    \"\"\"\n    dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(paths.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 3d - shape (N, 3)\n    vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n    # =============================================================================\n    # Get attributes\n    # =============================================================================\n\n    # get attributes from TransBuf to buffer\n    path_sizes_buffer = TransBufUtils.to_buffer(paths.get_path_sizes())\n    colors_buffer = TransBufUtils.to_buffer(paths.get_colors())\n    line_widths_buffer = TransBufUtils.to_buffer(paths.get_line_widths())\n\n    # convert buffers to numpy arrays\n    path_sizes_numpy = Bufferx.to_numpy(path_sizes_buffer)\n    colors_numpy = Bufferx.to_numpy(colors_buffer)\n    line_widths_pt_numpy = Bufferx.to_numpy(line_widths_buffer)\n\n    # Convert sizes from point^2 to pixel diameter\n    line_widths_px_numpy = UnitUtils.point_to_pixel_numpy(line_widths_pt_numpy, renderer.get_canvas().get_dpi())\n\n    path_sizes_numpy = path_sizes_numpy.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n    line_widths_px_numpy = line_widths_px_numpy.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n\n    # =============================================================================\n    # Create the datoviz visual if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{paths.get_uuid()}\"\n\n    # Create datoviz_visual if they do not exist\n    if artist_uuid not in renderer._dvz_visuals:\n        dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n        dummy_path_sizes_numpy = np.array([1], dtype=np.uint32)\n        dvz_paths = renderer._dvz_app.path()\n        dvz_paths.set_position(dummy_position_numpy, groups=dummy_path_sizes_numpy)\n        renderer._dvz_visuals[artist_uuid] = dvz_paths\n        # Add the new visual to the panel\n        dvz_panel.add(dvz_paths)\n\n    # =============================================================================\n    # Update all attributes\n    # =============================================================================\n\n    # get the datoviz visual\n    dvz_paths = typing.cast(_DvzPaths, renderer._dvz_visuals[artist_uuid])\n\n    dvz_paths.set_position(vertices_3d, groups=path_sizes_numpy)\n    dvz_paths.set_color(colors_numpy)\n    dvz_paths.set_linewidth(line_widths_px_numpy)\n    dvz_paths.set_cap(ConverterUtils.cap_style_gsp_to_dvz(paths.get_cap_style()))\n    dvz_paths.set_join(ConverterUtils.join_style_gsp_to_dvz(paths.get_join_style()))\n</code></pre>"},{"location":"api/gsp_datoviz/#pixels-renderer","title":"Pixels Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_pixels","title":"<code>gsp_datoviz.renderer.datoviz_renderer_pixels</code>","text":"<p>Datoviz renderer for Pixels visuals.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_pixels.DatovizRendererPixels","title":"<code>DatovizRendererPixels</code>","text":"<p>Datoviz renderer for Pixels visuals.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_pixels.py</code> <pre><code>class DatovizRendererPixels:\n    \"\"\"Datoviz renderer for Pixels visuals.\"\"\"\n    @staticmethod\n    def render(\n        renderer: DatovizRenderer,\n        viewport: Viewport,\n        pixels: Pixels,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; None:\n        \"\"\"Render Pixels visuals using Datoviz.\n\n        Args:\n            renderer (DatovizRenderer): The Datoviz renderer instance.\n            viewport (Viewport): The viewport to render in.\n            pixels (Pixels): The Pixels visual to render.\n            model_matrix (TransBuf): The model matrix for the visual.\n            camera (Camera): The camera used for rendering.\n        \"\"\"\n        dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(pixels.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 3d - shape (N, 3)\n        vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n        # =============================================================================\n        # Get attributes\n        # =============================================================================\n\n        # get attributes from TransBuf to buffer\n        colors_buffer = TransBufUtils.to_buffer(pixels.get_colors())\n\n        # convert buffers to numpy arrays\n        colors_numpy = Bufferx.to_numpy(colors_buffer)\n\n        # =============================================================================\n        #   Compute indices_per_group for groups depending on the type of groups\n        # =============================================================================\n\n        indices_per_group = GroupUtils.compute_indices_per_group(vertices_3d.__len__(), pixels.get_groups())\n        group_count = GroupUtils.get_group_count(vertices_3d.__len__(), pixels.get_groups())\n\n        # =============================================================================\n        # Create the datoviz pixels if needed\n        # =============================================================================\n\n        artist_uuid_prefix = f\"{viewport.get_uuid()}_{pixels.get_uuid()}\"\n\n        # update stored group count\n        old_group_count = None\n        if artist_uuid_prefix in renderer._group_count:\n            old_group_count = renderer._group_count[artist_uuid_prefix]\n        renderer._group_count[artist_uuid_prefix] = group_count\n\n        # If the group count has changed, destroy old datoviz_visuals\n        if old_group_count is not None and old_group_count != group_count:\n            for group_index in range(old_group_count):\n                group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n                if group_uuid in renderer._dvz_visuals:\n                    dvz_pixels = typing.cast(_DvzPixel, renderer._dvz_visuals[group_uuid])\n                    dvz_panel.remove(dvz_pixels)\n                    del renderer._dvz_visuals[group_uuid]\n\n        # Create datoviz_visual if they do not exist\n        sample_group_uuid = f\"{artist_uuid_prefix}_group_0\"\n        if sample_group_uuid not in renderer._dvz_visuals:\n            for group_index in range(group_count):\n                dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n                dummy_color_numpy = np.array([[255, 0, 0, 255]], dtype=np.uint8).reshape((-1, 4))\n                dvz_pixels = renderer._dvz_app.pixel(\n                    position=dummy_position_numpy,\n                    color=dummy_color_numpy,\n                )\n                group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n                renderer._dvz_visuals[group_uuid] = dvz_pixels\n                # Add the new pixels to the panel\n                dvz_panel.add(dvz_pixels)\n\n        # =============================================================================\n        # Update all attributes\n        # =============================================================================\n\n        for group_index in range(group_count):\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n\n            # get the datoviz pixels\n            dvz_pixels = typing.cast(_DvzPixel, renderer._dvz_visuals[group_uuid])\n\n            # set attributes\n            group_vertices = vertices_3d[indices_per_group[group_index]]\n            dvz_pixels.set_position(group_vertices)\n\n            # set group_colors\n            group_colors = np.tile(colors_numpy[group_index], group_vertices.__len__()).reshape((-1, 4))\n            dvz_pixels.set_color(group_colors)\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_pixels.DatovizRendererPixels.render","title":"<code>render(renderer: DatovizRenderer, viewport: Viewport, pixels: Pixels, model_matrix: TransBuf, camera: Camera) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Render Pixels visuals using Datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer</code> <p>The Datoviz renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render in.</p> required <code>pixels</code> <code>gsp.visuals.pixels.Pixels</code> <p>The Pixels visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model matrix for the visual.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera used for rendering.</p> required Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_pixels.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: DatovizRenderer,\n    viewport: Viewport,\n    pixels: Pixels,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; None:\n    \"\"\"Render Pixels visuals using Datoviz.\n\n    Args:\n        renderer (DatovizRenderer): The Datoviz renderer instance.\n        viewport (Viewport): The viewport to render in.\n        pixels (Pixels): The Pixels visual to render.\n        model_matrix (TransBuf): The model matrix for the visual.\n        camera (Camera): The camera used for rendering.\n    \"\"\"\n    dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(pixels.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 3d - shape (N, 3)\n    vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n    # =============================================================================\n    # Get attributes\n    # =============================================================================\n\n    # get attributes from TransBuf to buffer\n    colors_buffer = TransBufUtils.to_buffer(pixels.get_colors())\n\n    # convert buffers to numpy arrays\n    colors_numpy = Bufferx.to_numpy(colors_buffer)\n\n    # =============================================================================\n    #   Compute indices_per_group for groups depending on the type of groups\n    # =============================================================================\n\n    indices_per_group = GroupUtils.compute_indices_per_group(vertices_3d.__len__(), pixels.get_groups())\n    group_count = GroupUtils.get_group_count(vertices_3d.__len__(), pixels.get_groups())\n\n    # =============================================================================\n    # Create the datoviz pixels if needed\n    # =============================================================================\n\n    artist_uuid_prefix = f\"{viewport.get_uuid()}_{pixels.get_uuid()}\"\n\n    # update stored group count\n    old_group_count = None\n    if artist_uuid_prefix in renderer._group_count:\n        old_group_count = renderer._group_count[artist_uuid_prefix]\n    renderer._group_count[artist_uuid_prefix] = group_count\n\n    # If the group count has changed, destroy old datoviz_visuals\n    if old_group_count is not None and old_group_count != group_count:\n        for group_index in range(old_group_count):\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n            if group_uuid in renderer._dvz_visuals:\n                dvz_pixels = typing.cast(_DvzPixel, renderer._dvz_visuals[group_uuid])\n                dvz_panel.remove(dvz_pixels)\n                del renderer._dvz_visuals[group_uuid]\n\n    # Create datoviz_visual if they do not exist\n    sample_group_uuid = f\"{artist_uuid_prefix}_group_0\"\n    if sample_group_uuid not in renderer._dvz_visuals:\n        for group_index in range(group_count):\n            dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n            dummy_color_numpy = np.array([[255, 0, 0, 255]], dtype=np.uint8).reshape((-1, 4))\n            dvz_pixels = renderer._dvz_app.pixel(\n                position=dummy_position_numpy,\n                color=dummy_color_numpy,\n            )\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n            renderer._dvz_visuals[group_uuid] = dvz_pixels\n            # Add the new pixels to the panel\n            dvz_panel.add(dvz_pixels)\n\n    # =============================================================================\n    # Update all attributes\n    # =============================================================================\n\n    for group_index in range(group_count):\n        group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n\n        # get the datoviz pixels\n        dvz_pixels = typing.cast(_DvzPixel, renderer._dvz_visuals[group_uuid])\n\n        # set attributes\n        group_vertices = vertices_3d[indices_per_group[group_index]]\n        dvz_pixels.set_position(group_vertices)\n\n        # set group_colors\n        group_colors = np.tile(colors_numpy[group_index], group_vertices.__len__()).reshape((-1, 4))\n        dvz_pixels.set_color(group_colors)\n</code></pre>"},{"location":"api/gsp_datoviz/#points-renderer","title":"Points Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_points","title":"<code>gsp_datoviz.renderer.datoviz_renderer_points</code>","text":"<p>Datoviz renderer for Points visuals.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_points.DatovizRendererPoints","title":"<code>DatovizRendererPoints</code>","text":"<p>Datoviz renderer for Points visuals.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_points.py</code> <pre><code>class DatovizRendererPoints:\n    \"\"\"Datoviz renderer for Points visuals.\"\"\"\n    @staticmethod\n    def render(\n        renderer: DatovizRenderer,\n        viewport: Viewport,\n        points: Points,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; None:\n        \"\"\"Render Points visuals using Datoviz.\n\n        Args:\n            renderer (DatovizRenderer): The Datoviz renderer instance.\n            viewport (Viewport): The viewport to render in.\n            points (Points): The Points visual to render.\n            model_matrix (TransBuf): The model matrix for the visual.\n            camera (Camera): The camera used for rendering.\n        \"\"\"\n        dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(points.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 3d - shape (N, 3)\n        vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n        # =============================================================================\n        # Get attributes\n        # =============================================================================\n\n        # get attributes from TransBuf to buffer\n        sizes_buffer = TransBufUtils.to_buffer(points.get_sizes())\n        face_colors_buffer = TransBufUtils.to_buffer(points.get_face_colors())\n\n        # convert buffers to numpy arrays\n        face_colors_numpy = Bufferx.to_numpy(face_colors_buffer)\n\n        # Convert sizes from point^2 to pixel diameter\n        sizes_pt2_numpy = Bufferx.to_numpy(sizes_buffer)\n        radius_pt_numpy = np.sqrt(sizes_pt2_numpy / np.pi)\n        radius_px_numpy = UnitUtils.point_to_pixel_numpy(radius_pt_numpy, renderer.get_canvas().get_dpi())\n        diameter_px_numpy = radius_px_numpy * 2.0 * UnitUtils.device_pixel_ratio()\n\n        # =============================================================================\n        # Create the datoviz visual if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{points.get_uuid()}\"\n\n        # Create datoviz_visual if they do not exist\n        if artist_uuid not in renderer._dvz_visuals:\n            dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n            dummy_color_numpy = np.array([[255, 0, 0, 255]], dtype=np.uint8).reshape((-1, 4))\n            dummy_size_numpy = np.array([1], dtype=np.float32).reshape((-1, 1)).reshape(-1)\n            dvz_points = renderer._dvz_app.point(\n                position=dummy_position_numpy,\n                color=dummy_color_numpy,\n                size=dummy_size_numpy,\n            )\n            renderer._dvz_visuals[artist_uuid] = dvz_points\n            # Add the new visual to the panel\n            dvz_panel.add(dvz_points)\n\n        # =============================================================================\n        # Update all attributes\n        # =============================================================================\n\n        # get the datoviz visual\n        dvz_points = typing.cast(_DvzPoints, renderer._dvz_visuals[artist_uuid])\n\n        # set attributes\n        dvz_points.set_position(vertices_3d)\n\n        # set group_sizes\n        group_sizes = np.tile(diameter_px_numpy, vertices_3d.__len__()).reshape((-1, 1))\n        group_sizes = group_sizes.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n        dvz_points.set_size(group_sizes)\n\n        # set group_colors\n        group_colors = np.tile(face_colors_numpy, vertices_3d.__len__()).reshape((-1, 4))\n        dvz_points.set_color(group_colors)\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_points.DatovizRendererPoints.render","title":"<code>render(renderer: DatovizRenderer, viewport: Viewport, points: Points, model_matrix: TransBuf, camera: Camera) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Render Points visuals using Datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer</code> <p>The Datoviz renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render in.</p> required <code>points</code> <code>gsp.visuals.points.Points</code> <p>The Points visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model matrix for the visual.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera used for rendering.</p> required Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_points.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: DatovizRenderer,\n    viewport: Viewport,\n    points: Points,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; None:\n    \"\"\"Render Points visuals using Datoviz.\n\n    Args:\n        renderer (DatovizRenderer): The Datoviz renderer instance.\n        viewport (Viewport): The viewport to render in.\n        points (Points): The Points visual to render.\n        model_matrix (TransBuf): The model matrix for the visual.\n        camera (Camera): The camera used for rendering.\n    \"\"\"\n    dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(points.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 3d - shape (N, 3)\n    vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n    # =============================================================================\n    # Get attributes\n    # =============================================================================\n\n    # get attributes from TransBuf to buffer\n    sizes_buffer = TransBufUtils.to_buffer(points.get_sizes())\n    face_colors_buffer = TransBufUtils.to_buffer(points.get_face_colors())\n\n    # convert buffers to numpy arrays\n    face_colors_numpy = Bufferx.to_numpy(face_colors_buffer)\n\n    # Convert sizes from point^2 to pixel diameter\n    sizes_pt2_numpy = Bufferx.to_numpy(sizes_buffer)\n    radius_pt_numpy = np.sqrt(sizes_pt2_numpy / np.pi)\n    radius_px_numpy = UnitUtils.point_to_pixel_numpy(radius_pt_numpy, renderer.get_canvas().get_dpi())\n    diameter_px_numpy = radius_px_numpy * 2.0 * UnitUtils.device_pixel_ratio()\n\n    # =============================================================================\n    # Create the datoviz visual if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{points.get_uuid()}\"\n\n    # Create datoviz_visual if they do not exist\n    if artist_uuid not in renderer._dvz_visuals:\n        dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n        dummy_color_numpy = np.array([[255, 0, 0, 255]], dtype=np.uint8).reshape((-1, 4))\n        dummy_size_numpy = np.array([1], dtype=np.float32).reshape((-1, 1)).reshape(-1)\n        dvz_points = renderer._dvz_app.point(\n            position=dummy_position_numpy,\n            color=dummy_color_numpy,\n            size=dummy_size_numpy,\n        )\n        renderer._dvz_visuals[artist_uuid] = dvz_points\n        # Add the new visual to the panel\n        dvz_panel.add(dvz_points)\n\n    # =============================================================================\n    # Update all attributes\n    # =============================================================================\n\n    # get the datoviz visual\n    dvz_points = typing.cast(_DvzPoints, renderer._dvz_visuals[artist_uuid])\n\n    # set attributes\n    dvz_points.set_position(vertices_3d)\n\n    # set group_sizes\n    group_sizes = np.tile(diameter_px_numpy, vertices_3d.__len__()).reshape((-1, 1))\n    group_sizes = group_sizes.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n    dvz_points.set_size(group_sizes)\n\n    # set group_colors\n    group_colors = np.tile(face_colors_numpy, vertices_3d.__len__()).reshape((-1, 4))\n    dvz_points.set_color(group_colors)\n</code></pre>"},{"location":"api/gsp_datoviz/#segments-renderer","title":"Segments Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_segments","title":"<code>gsp_datoviz.renderer.datoviz_renderer_segments</code>","text":"<p>Datoviz renderer for Segments visuals.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_segments.DatovizRendererSegments","title":"<code>DatovizRendererSegments</code>","text":"<p>Datoviz renderer for Segments visuals.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_segments.py</code> <pre><code>class DatovizRendererSegments:\n    \"\"\"Datoviz renderer for Segments visuals.\"\"\"\n    @staticmethod\n    def render(\n        renderer: DatovizRenderer,\n        viewport: Viewport,\n        segments: Segments,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; None:\n        \"\"\"Render Segments visuals using Datoviz.\n\n        Args:\n            renderer (DatovizRenderer): The Datoviz renderer instance.\n            viewport (Viewport): The viewport to render in.\n            segments (Segments): The Segments visual to render.\n            model_matrix (TransBuf): The model matrix for the visual.\n            camera (Camera): The camera used for rendering.\n        \"\"\"\n        dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(segments.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 3d - shape (N, 3)\n        vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n        # =============================================================================\n        # Get attributes\n        # =============================================================================\n\n        # get attributes from TransBuf to buffer\n        colors_buffer = TransBufUtils.to_buffer(segments.get_colors())\n        line_widths_buffer = TransBufUtils.to_buffer(segments.get_line_widths())\n\n        # convert buffers to numpy arrays\n        colors_numpy = Bufferx.to_numpy(colors_buffer)\n        line_widths_pt_numpy = Bufferx.to_numpy(line_widths_buffer)\n\n        # Convert sizes from point to pixel diameter\n        line_widths_px_numpy = UnitUtils.point_to_pixel_numpy(line_widths_pt_numpy, renderer.get_canvas().get_dpi())\n        line_widths_px_numpy = line_widths_px_numpy.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n\n        # =============================================================================\n        # Create the datoviz visual if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{segments.get_uuid()}\"\n\n        # Create datoviz_visual if they do not exist\n        if artist_uuid not in renderer._dvz_visuals:\n            dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n            dvz_segments = renderer._dvz_app.segment(dummy_position_numpy, dummy_position_numpy)\n            renderer._dvz_visuals[artist_uuid] = dvz_segments\n            # Add the new visual to the panel\n            dvz_panel.add(dvz_segments)\n\n        # =============================================================================\n        # Update all attributes\n        # =============================================================================\n\n        # get the datoviz visual\n        dvz_segments = typing.cast(_DvzSegments, renderer._dvz_visuals[artist_uuid])\n\n        # dvz_vertices_initial - the even indices are initial points\n        dvz_initial_vertices = np.ascontiguousarray(vertices_3d[0::2])\n        # dvz_vertices_terminal - the odd indices are terminal points\n        dvz_terminal_vertices = np.ascontiguousarray(vertices_3d[1::2])\n        dvz_initial_cap = ConverterUtils.cap_style_gsp_to_dvz(segments.get_cap_style())\n        dvz_terminal_cap = dvz_initial_cap  # same cap for initial and terminal\n\n        dvz_segments.set_position(dvz_initial_vertices, dvz_terminal_vertices)\n        dvz_segments.set_color(colors_numpy)\n        dvz_segments.set_linewidth(line_widths_px_numpy)\n        dvz_segments.set_cap(dvz_initial_cap, dvz_terminal_cap)\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_segments.DatovizRendererSegments.render","title":"<code>render(renderer: DatovizRenderer, viewport: Viewport, segments: Segments, model_matrix: TransBuf, camera: Camera) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Render Segments visuals using Datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer</code> <p>The Datoviz renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render in.</p> required <code>segments</code> <code>gsp.visuals.segments.Segments</code> <p>The Segments visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model matrix for the visual.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera used for rendering.</p> required Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_segments.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: DatovizRenderer,\n    viewport: Viewport,\n    segments: Segments,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; None:\n    \"\"\"Render Segments visuals using Datoviz.\n\n    Args:\n        renderer (DatovizRenderer): The Datoviz renderer instance.\n        viewport (Viewport): The viewport to render in.\n        segments (Segments): The Segments visual to render.\n        model_matrix (TransBuf): The model matrix for the visual.\n        camera (Camera): The camera used for rendering.\n    \"\"\"\n    dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(segments.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 3d - shape (N, 3)\n    vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n    # =============================================================================\n    # Get attributes\n    # =============================================================================\n\n    # get attributes from TransBuf to buffer\n    colors_buffer = TransBufUtils.to_buffer(segments.get_colors())\n    line_widths_buffer = TransBufUtils.to_buffer(segments.get_line_widths())\n\n    # convert buffers to numpy arrays\n    colors_numpy = Bufferx.to_numpy(colors_buffer)\n    line_widths_pt_numpy = Bufferx.to_numpy(line_widths_buffer)\n\n    # Convert sizes from point to pixel diameter\n    line_widths_px_numpy = UnitUtils.point_to_pixel_numpy(line_widths_pt_numpy, renderer.get_canvas().get_dpi())\n    line_widths_px_numpy = line_widths_px_numpy.reshape(-1)  # datoviz expects (N,) shape for (N, 1) input\n\n    # =============================================================================\n    # Create the datoviz visual if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{segments.get_uuid()}\"\n\n    # Create datoviz_visual if they do not exist\n    if artist_uuid not in renderer._dvz_visuals:\n        dummy_position_numpy = np.array([[0, 0, 0]], dtype=np.float32).reshape((-1, 3))\n        dvz_segments = renderer._dvz_app.segment(dummy_position_numpy, dummy_position_numpy)\n        renderer._dvz_visuals[artist_uuid] = dvz_segments\n        # Add the new visual to the panel\n        dvz_panel.add(dvz_segments)\n\n    # =============================================================================\n    # Update all attributes\n    # =============================================================================\n\n    # get the datoviz visual\n    dvz_segments = typing.cast(_DvzSegments, renderer._dvz_visuals[artist_uuid])\n\n    # dvz_vertices_initial - the even indices are initial points\n    dvz_initial_vertices = np.ascontiguousarray(vertices_3d[0::2])\n    # dvz_vertices_terminal - the odd indices are terminal points\n    dvz_terminal_vertices = np.ascontiguousarray(vertices_3d[1::2])\n    dvz_initial_cap = ConverterUtils.cap_style_gsp_to_dvz(segments.get_cap_style())\n    dvz_terminal_cap = dvz_initial_cap  # same cap for initial and terminal\n\n    dvz_segments.set_position(dvz_initial_vertices, dvz_terminal_vertices)\n    dvz_segments.set_color(colors_numpy)\n    dvz_segments.set_linewidth(line_widths_px_numpy)\n    dvz_segments.set_cap(dvz_initial_cap, dvz_terminal_cap)\n</code></pre>"},{"location":"api/gsp_datoviz/#texts-renderer","title":"Texts Renderer","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_texts","title":"<code>gsp_datoviz.renderer.datoviz_renderer_texts</code>","text":"<p>Datoviz renderer for Texts visuals.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_texts.DatovizRendererTexts","title":"<code>DatovizRendererTexts</code>","text":"<p>Datoviz renderer for Texts visuals.</p> Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_texts.py</code> <pre><code>class DatovizRendererTexts:\n    \"\"\"Datoviz renderer for Texts visuals.\"\"\"\n    @staticmethod\n    def render(\n        renderer: DatovizRenderer,\n        viewport: Viewport,\n        texts: Texts,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; None:\n        \"\"\"Render Texts visuals using Datoviz.\n\n        Args:\n            renderer (DatovizRenderer): The Datoviz renderer instance.\n            viewport (Viewport): The viewport to render in.\n            texts (Texts): The Texts visual to render.\n            model_matrix (TransBuf): The model matrix for the visual.\n            camera (Camera): The camera used for rendering.\n        \"\"\"\n        dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(texts.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 3d - shape (N, 3)\n        vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n        # =============================================================================\n        # Get attributes\n        # =============================================================================\n\n        # get attributes from TransBuf to buffer\n        colors_buffer = TransBufUtils.to_buffer(texts.get_colors())\n        font_sizes_buffer = TransBufUtils.to_buffer(texts.get_font_sizes())\n        anchors_buffer = TransBufUtils.to_buffer(texts.get_anchors())\n        angles_buffer = TransBufUtils.to_buffer(texts.get_angles())\n\n        # convert buffers to numpy arrays\n        colors_numpy = Bufferx.to_numpy(colors_buffer)\n        font_sizes_numpy = Bufferx.to_numpy(font_sizes_buffer)\n        anchors_numpy = Bufferx.to_numpy(anchors_buffer)\n        angles_numpy = Bufferx.to_numpy(angles_buffer)\n\n        # =============================================================================\n        # Create the datoviz visual if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{texts.get_uuid()}\"\n\n        # Create datoviz_visual if they do not exist\n        if artist_uuid not in renderer._dvz_visuals:\n            artist_uuid = f\"{viewport.get_uuid()}_{texts.get_uuid()}\"\n            dvz_glyphs = renderer._dvz_app.glyph(font_size=30)\n            # set dummy strings to initialize the visual\n            dvz_glyphs.set_strings([\"dummy string\"], string_pos=np.array([[0.0, 0.0, 0.0]], dtype=np.float32), scales=np.array([1.0], dtype=np.float32))\n            renderer._dvz_visuals[artist_uuid] = dvz_glyphs\n            # Add the new visual to the panel\n            dvz_panel.add(dvz_glyphs)\n\n        # =============================================================================\n        # Update all attributes\n        # =============================================================================\n\n        # # get the datoviz visual\n        dvz_glyphs = typing.cast(_DvzGlyphs, renderer._dvz_visuals[artist_uuid])\n\n        text_strings = texts.get_strings()\n        text_count = len(text_strings)\n        glyph_count = sum(map(len, text_strings))\n\n        # build glyph scales from font sizes\n        glyph_scales = np.zeros((glyph_count,), dtype=np.float32)\n        for text_index in range(text_count):\n            # TODO font-size is in typographic points, have to convert to pixels ? relation with the font_size of the dvz visual ?\n            # glyph_scales[text_index] = font_sizes_numpy[text_index, 0]  # dvz visual default font size is 100\n            for glyph_index in range(len(text_strings[text_index])):\n                global_glyph_index = sum(len(s) for s in text_strings[:text_index]) + glyph_index\n                glyph_scales[global_glyph_index] = font_sizes_numpy[text_index, 0] / 15  # dvz visual default font size is 100\n\n        # build glyph colors from text colors\n        glyph_colors = np.zeros((glyph_count, 4), dtype=np.uint8)\n        for text_index in range(text_count):\n            for glyph_index in range(len(text_strings[text_index])):\n                global_glyph_index = sum(len(s) for s in text_strings[:text_index]) + glyph_index\n                glyph_colors[global_glyph_index, :] = colors_numpy[text_index, :]\n\n        glyphs_angles = np.zeros((glyph_count,), dtype=np.float32)\n        for text_index in range(text_count):\n            for glyph_index in range(len(text_strings[text_index])):\n                global_glyph_index = sum(len(s) for s in text_strings[:text_index]) + glyph_index\n                glyphs_angles[global_glyph_index] = angles_numpy[text_index, 0] / 180 * np.pi  # convert to radians\n\n        dvz_glyphs.set_strings(text_strings, string_pos=vertices_3d)\n        dvz_glyphs.set_color(glyph_colors)\n        dvz_glyphs.set_angle(glyphs_angles)\n        dvz_glyphs.set_scale(glyph_scales)\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.renderer.datoviz_renderer_texts.DatovizRendererTexts.render","title":"<code>render(renderer: DatovizRenderer, viewport: Viewport, texts: Texts, model_matrix: TransBuf, camera: Camera) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Render Texts visuals using Datoviz.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_datoviz.renderer.datoviz_renderer.DatovizRenderer</code> <p>The Datoviz renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render in.</p> required <code>texts</code> <code>gsp.visuals.texts.Texts</code> <p>The Texts visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model matrix for the visual.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera used for rendering.</p> required Source code in <code>src/gsp_datoviz/renderer/datoviz_renderer_texts.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: DatovizRenderer,\n    viewport: Viewport,\n    texts: Texts,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; None:\n    \"\"\"Render Texts visuals using Datoviz.\n\n    Args:\n        renderer (DatovizRenderer): The Datoviz renderer instance.\n        viewport (Viewport): The viewport to render in.\n        texts (Texts): The Texts visual to render.\n        model_matrix (TransBuf): The model matrix for the visual.\n        camera (Camera): The camera used for rendering.\n    \"\"\"\n    dvz_panel = renderer._getOrCreateDvzPanel(viewport)\n\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(texts.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 3d - shape (N, 3)\n    vertices_3d = np.ascontiguousarray(vertices_3d_transformed, dtype=np.float32)\n\n    # =============================================================================\n    # Get attributes\n    # =============================================================================\n\n    # get attributes from TransBuf to buffer\n    colors_buffer = TransBufUtils.to_buffer(texts.get_colors())\n    font_sizes_buffer = TransBufUtils.to_buffer(texts.get_font_sizes())\n    anchors_buffer = TransBufUtils.to_buffer(texts.get_anchors())\n    angles_buffer = TransBufUtils.to_buffer(texts.get_angles())\n\n    # convert buffers to numpy arrays\n    colors_numpy = Bufferx.to_numpy(colors_buffer)\n    font_sizes_numpy = Bufferx.to_numpy(font_sizes_buffer)\n    anchors_numpy = Bufferx.to_numpy(anchors_buffer)\n    angles_numpy = Bufferx.to_numpy(angles_buffer)\n\n    # =============================================================================\n    # Create the datoviz visual if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{texts.get_uuid()}\"\n\n    # Create datoviz_visual if they do not exist\n    if artist_uuid not in renderer._dvz_visuals:\n        artist_uuid = f\"{viewport.get_uuid()}_{texts.get_uuid()}\"\n        dvz_glyphs = renderer._dvz_app.glyph(font_size=30)\n        # set dummy strings to initialize the visual\n        dvz_glyphs.set_strings([\"dummy string\"], string_pos=np.array([[0.0, 0.0, 0.0]], dtype=np.float32), scales=np.array([1.0], dtype=np.float32))\n        renderer._dvz_visuals[artist_uuid] = dvz_glyphs\n        # Add the new visual to the panel\n        dvz_panel.add(dvz_glyphs)\n\n    # =============================================================================\n    # Update all attributes\n    # =============================================================================\n\n    # # get the datoviz visual\n    dvz_glyphs = typing.cast(_DvzGlyphs, renderer._dvz_visuals[artist_uuid])\n\n    text_strings = texts.get_strings()\n    text_count = len(text_strings)\n    glyph_count = sum(map(len, text_strings))\n\n    # build glyph scales from font sizes\n    glyph_scales = np.zeros((glyph_count,), dtype=np.float32)\n    for text_index in range(text_count):\n        # TODO font-size is in typographic points, have to convert to pixels ? relation with the font_size of the dvz visual ?\n        # glyph_scales[text_index] = font_sizes_numpy[text_index, 0]  # dvz visual default font size is 100\n        for glyph_index in range(len(text_strings[text_index])):\n            global_glyph_index = sum(len(s) for s in text_strings[:text_index]) + glyph_index\n            glyph_scales[global_glyph_index] = font_sizes_numpy[text_index, 0] / 15  # dvz visual default font size is 100\n\n    # build glyph colors from text colors\n    glyph_colors = np.zeros((glyph_count, 4), dtype=np.uint8)\n    for text_index in range(text_count):\n        for glyph_index in range(len(text_strings[text_index])):\n            global_glyph_index = sum(len(s) for s in text_strings[:text_index]) + glyph_index\n            glyph_colors[global_glyph_index, :] = colors_numpy[text_index, :]\n\n    glyphs_angles = np.zeros((glyph_count,), dtype=np.float32)\n    for text_index in range(text_count):\n        for glyph_index in range(len(text_strings[text_index])):\n            global_glyph_index = sum(len(s) for s in text_strings[:text_index]) + glyph_index\n            glyphs_angles[global_glyph_index] = angles_numpy[text_index, 0] / 180 * np.pi  # convert to radians\n\n    dvz_glyphs.set_strings(text_strings, string_pos=vertices_3d)\n    dvz_glyphs.set_color(glyph_colors)\n    dvz_glyphs.set_angle(glyphs_angles)\n    dvz_glyphs.set_scale(glyph_scales)\n</code></pre>"},{"location":"api/gsp_datoviz/#utils-module","title":"Utils Module","text":"<p>The utils module provides converter utilities for the Datoviz backend.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils","title":"<code>gsp_datoviz.utils</code>","text":"<p>Utility functions for converting GSP types to Datoviz types.</p>"},{"location":"api/gsp_datoviz/#converter-utils","title":"Converter Utils","text":""},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils","title":"<code>gsp_datoviz.utils.converter_utils</code>","text":"<p>Utility functions for converting GSP types to Datoviz types.</p>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils.ConverterUtils","title":"<code>ConverterUtils</code>","text":"<p>Utility class for converting GSP types to Datoviz types.</p> Source code in <code>src/gsp_datoviz/utils/converter_utils.py</code> <pre><code>class ConverterUtils:\n    \"\"\"Utility class for converting GSP types to Datoviz types.\"\"\"\n\n    @staticmethod\n    def cap_style_gsp_to_dvz(cap_style: CapStyle) -&gt; str:\n        \"\"\"Convert CapStyle enum to Datoviz string.\n\n        Args:\n            cap_style: The GSP CapStyle enum value.\n\n        Returns:\n            The corresponding Datoviz cap style string.\n        \"\"\"\n        if cap_style == CapStyle.BUTT:\n            return \"butt\"\n        elif cap_style == CapStyle.ROUND:\n            return \"round\"\n        elif cap_style == CapStyle.PROJECTING:\n            return \"square\"\n        else:\n            raise ValueError(f\"Unsupported CapStyle: {cap_style}\")\n\n    @staticmethod\n    def join_style_gsp_to_dvz(join_style: JoinStyle) -&gt; str:\n        \"\"\"Convert JoinStyle enum to Datoviz string.\n\n        Args:\n            join_style: The GSP JoinStyle enum value.\n\n        Returns:\n            The corresponding Datoviz join style string.\n        \"\"\"\n        if join_style == JoinStyle.MITER:\n            raise ValueError(f\"Unsupported JoinStyle in datoviz: {join_style}\")\n        elif join_style == JoinStyle.ROUND:\n            return \"round\"\n        elif join_style == JoinStyle.BEVEL:\n            return \"square\"\n        else:\n            raise ValueError(f\"Unsupported JoinStyle: {join_style}\")\n\n    @staticmethod\n    def marker_shape_gsp_to_dvz(gsp_marker_shape: MarkerShape) -&gt; str:\n        \"\"\"Convert GSP marker shape to Datoviz marker shape.\n\n        Args:\n            gsp_marker_shape: The GSP MarkerShape enum value.\n\n        Returns:\n            The corresponding Datoviz marker shape string.\n        \"\"\"\n        if gsp_marker_shape == MarkerShape.disc:\n            mpl_marker_shape = \"disc\"\n        elif gsp_marker_shape == MarkerShape.square:\n            mpl_marker_shape = \"square\"\n        elif gsp_marker_shape == MarkerShape.club:\n            mpl_marker_shape = \"club\"\n        else:\n            raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n        return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils.ConverterUtils.cap_style_gsp_to_dvz","title":"<code>cap_style_gsp_to_dvz(cap_style: CapStyle) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert CapStyle enum to Datoviz string.</p> <p>Parameters:</p> Name Type Description Default <code>cap_style</code> <code>gsp.types.CapStyle</code> <p>The GSP CapStyle enum value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The corresponding Datoviz cap style string.</p> Source code in <code>src/gsp_datoviz/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef cap_style_gsp_to_dvz(cap_style: CapStyle) -&gt; str:\n    \"\"\"Convert CapStyle enum to Datoviz string.\n\n    Args:\n        cap_style: The GSP CapStyle enum value.\n\n    Returns:\n        The corresponding Datoviz cap style string.\n    \"\"\"\n    if cap_style == CapStyle.BUTT:\n        return \"butt\"\n    elif cap_style == CapStyle.ROUND:\n        return \"round\"\n    elif cap_style == CapStyle.PROJECTING:\n        return \"square\"\n    else:\n        raise ValueError(f\"Unsupported CapStyle: {cap_style}\")\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils.ConverterUtils.join_style_gsp_to_dvz","title":"<code>join_style_gsp_to_dvz(join_style: JoinStyle) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert JoinStyle enum to Datoviz string.</p> <p>Parameters:</p> Name Type Description Default <code>join_style</code> <code>gsp.types.JoinStyle</code> <p>The GSP JoinStyle enum value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The corresponding Datoviz join style string.</p> Source code in <code>src/gsp_datoviz/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef join_style_gsp_to_dvz(join_style: JoinStyle) -&gt; str:\n    \"\"\"Convert JoinStyle enum to Datoviz string.\n\n    Args:\n        join_style: The GSP JoinStyle enum value.\n\n    Returns:\n        The corresponding Datoviz join style string.\n    \"\"\"\n    if join_style == JoinStyle.MITER:\n        raise ValueError(f\"Unsupported JoinStyle in datoviz: {join_style}\")\n    elif join_style == JoinStyle.ROUND:\n        return \"round\"\n    elif join_style == JoinStyle.BEVEL:\n        return \"square\"\n    else:\n        raise ValueError(f\"Unsupported JoinStyle: {join_style}\")\n</code></pre>"},{"location":"api/gsp_datoviz/#gsp_datoviz.utils.converter_utils.ConverterUtils.marker_shape_gsp_to_dvz","title":"<code>marker_shape_gsp_to_dvz(gsp_marker_shape: MarkerShape) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert GSP marker shape to Datoviz marker shape.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_marker_shape</code> <code>gsp.types.MarkerShape</code> <p>The GSP MarkerShape enum value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The corresponding Datoviz marker shape string.</p> Source code in <code>src/gsp_datoviz/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef marker_shape_gsp_to_dvz(gsp_marker_shape: MarkerShape) -&gt; str:\n    \"\"\"Convert GSP marker shape to Datoviz marker shape.\n\n    Args:\n        gsp_marker_shape: The GSP MarkerShape enum value.\n\n    Returns:\n        The corresponding Datoviz marker shape string.\n    \"\"\"\n    if gsp_marker_shape == MarkerShape.disc:\n        mpl_marker_shape = \"disc\"\n    elif gsp_marker_shape == MarkerShape.square:\n        mpl_marker_shape = \"square\"\n    elif gsp_marker_shape == MarkerShape.club:\n        mpl_marker_shape = \"club\"\n    else:\n        raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n    return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_matplotlib/","title":"GSP Matplotlib API Reference","text":"<p>The GSP Matplotlib backend provides rendering using the Matplotlib library, enabling integration with the Python scientific visualization ecosystem.</p>"},{"location":"api/gsp_matplotlib/#overview","title":"Overview","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib","title":"<code>gsp_matplotlib</code>","text":"<p>GSP Matplotlib package initialization.</p>"},{"location":"api/gsp_matplotlib/#renderer-module","title":"Renderer Module","text":"<p>The renderer module contains the main Matplotlib renderer implementation and specialized renderers for different visual types.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer","title":"<code>gsp_matplotlib.renderer</code>","text":"<p>Matplotlib Renderer Package.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer","title":"<code>MatplotlibRenderer</code>","text":"<p>               Bases: <code>gsp.types.renderer_base.RendererBase</code></p> <p>Matplotlib-based renderer for GSP visuals.</p> <p>This renderer implements the GSP rendering interface using Matplotlib as the backend. It creates and manages a Matplotlib figure with multiple axes for different viewports, and renders various visual types (pixels, points, paths, markers, segments, texts) into them.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>class MatplotlibRenderer(RendererBase):\n    \"\"\"Matplotlib-based renderer for GSP visuals.\n\n    This renderer implements the GSP rendering interface using Matplotlib as the backend.\n    It creates and manages a Matplotlib figure with multiple axes for different viewports,\n    and renders various visual types (pixels, points, paths, markers, segments, texts) into them.\n    \"\"\"\n\n    def __init__(self, canvas: Canvas):\n        \"\"\"Initialize the Matplotlib renderer.\n\n        Args:\n            canvas: The canvas defining the rendering surface dimensions and DPI.\n        \"\"\"\n        self.canvas = canvas\n        # Store mapping of viewport UUIDs to axes\n        self._axes: dict[str, matplotlib.axes.Axes] = {}\n        # Store mapping of visual UUIDs to matplotlib artists\n        self._artists: dict[str, matplotlib.artist.Artist] = {}\n        # Store group count per visual UUID\n        self._group_count: dict[str, int] = {}\n\n        # Create a figure\n        figure_width = canvas.get_width() / canvas.get_dpi()\n        figure_height = canvas.get_height() / canvas.get_dpi()\n        self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=canvas.get_dpi())\n        assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n        self._figure.canvas.manager.set_window_title(\"Matplotlib\")\n\n    def get_canvas(self) -&gt; Canvas:\n        \"\"\"Get the canvas associated with this renderer.\n\n        Returns:\n            The canvas instance.\n        \"\"\"\n        return self.canvas\n\n    def close(self) -&gt; None:\n        \"\"\"Close the renderer and release resources.\n\n        Stops the Matplotlib event loop and closes the figure.\n        \"\"\"\n        # warnings.warn(f\"Closing NetworkRenderer does not release any resources.\", UserWarning)\n        # stop the event loop if any - thus .show(block=True) will return\n        self._figure.canvas.stop_event_loop()\n        # close the figure\n        matplotlib.pyplot.close(self._figure)\n        self._figure = None  # type: ignore\n\n    def show(self) -&gt; None:\n        \"\"\"Display the rendered figure in an interactive window.\n\n        This method shows the Matplotlib figure. It does nothing when running\n        in test mode (GSP_TEST environment variable set to \"True\").\n        \"\"\"\n        # handle non-interactive mode for tests\n        in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n        if in_test:\n            return\n\n        matplotlib.pyplot.show()\n\n    def render(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n        return_image: bool = True,\n        image_format: str = \"png\",\n    ) -&gt; bytes:\n        \"\"\"Render the scene to an image.\n\n        Args:\n            viewports: Sequence of viewport regions to render into.\n            visuals: Sequence of visual elements to render.\n            model_matrices: Sequence of model transformation matrices for each visual.\n            cameras: Sequence of cameras defining view and projection for each visual.\n            return_image: Whether to return the rendered image as bytes.\n            image_format: Format for the output image (e.g., \"png\", \"jpg\").\n\n        Returns:\n            The rendered image as bytes in the specified format, or empty bytes if return_image is False.\n\n        Raises:\n            AssertionError: If the sequences don't all have the same length.\n        \"\"\"\n        # =============================================================================\n        # Sanity checks\n        # =============================================================================\n\n        assert (\n            len(viewports) == len(visuals) == len(model_matrices) == len(cameras)\n        ), f\"All length MUST be equal. Mismatched lengths: {len(viewports)} viewports, {len(visuals)} visuals, {len(model_matrices)} model matrices, {len(cameras)} cameras\"\n\n        # =============================================================================\n        # Create all the axes if needed\n        # =============================================================================\n        for viewport in viewports:\n            if viewport.get_uuid() in self._axes:\n                continue\n            axes_rect = (\n                viewport.get_x() / self.canvas.get_width(),\n                viewport.get_y() / self.canvas.get_height(),\n                viewport.get_width() / self.canvas.get_width(),\n                viewport.get_height() / self.canvas.get_height(),\n            )\n            axes: matplotlib.axes.Axes = matplotlib.pyplot.axes(axes_rect)\n            # this should be -1 to 1 - from normalized device coordinates - https://en.wikipedia.org/wiki/Graphics_pipeline\n            # - https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection\n            axes.set_xlim(-1, 1)\n            axes.set_ylim(-1, 1)\n            # hide the borders\n            axes.axis(\"off\")\n            # store axes for this viewport\n            self._axes[viewport.get_uuid()] = axes\n\n        # =============================================================================\n        # Render each visual\n        # =============================================================================\n\n        for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n            self._render_visual(viewport, visual, model_matrix, camera)\n\n        # =============================================================================\n        # Render the output image\n        # =============================================================================\n        image_png_data = b\"\"\n\n        # honor return_image option\n        if return_image:\n            # Render the image to a PNG buffer\n            image_png_buffer = io.BytesIO()\n            self._figure.savefig(image_png_buffer, format=image_format, dpi=self.canvas.get_dpi())\n\n            image_png_buffer.seek(0)\n            image_png_data = image_png_buffer.getvalue()\n            image_png_buffer.close()\n\n        return image_png_data\n\n    def _render_visual(self, viewport: Viewport, visual: VisualBase, model_matrix: TransBuf, camera: Camera):\n        \"\"\"Render a single visual in a given viewport using the specified camera.\"\"\"\n        if isinstance(visual, Pixels):\n            from gsp_matplotlib.renderer.matplotlib_renderer_pixels import RendererPixels\n\n            RendererPixels.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Points):\n            from gsp_matplotlib.renderer.matplotlib_renderer_points import RendererPoints\n\n            RendererPoints.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Paths):\n            from gsp_matplotlib.renderer.matplotlib_renderer_paths import RendererPaths\n\n            RendererPaths.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Markers):\n            from gsp_matplotlib.renderer.matplotlib_renderer_markers import RendererMarkers\n\n            RendererMarkers.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Segments):\n            from gsp_matplotlib.renderer.matplotlib_renderer_segments import RendererSegments\n\n            RendererSegments.render(self, viewport, visual, model_matrix, camera)\n\n        elif isinstance(visual, Texts):\n            from gsp_matplotlib.renderer.matplotlib_renderer_texts import RendererTexts\n\n            RendererTexts.render(self, viewport, visual, model_matrix, camera)\n        else:\n            raise NotImplementedError(f\"Rendering for visual type {type(visual)} is not implemented.\")\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    def get_mpl_axes_for_viewport(self, viewport: Viewport) -&gt; matplotlib.axes.Axes:\n        \"\"\"Get the Matplotlib axes associated with a viewport.\n\n        Args:\n            viewport: The viewport to get axes for.\n\n        Returns:\n            The Matplotlib Axes object for the given viewport.\n        \"\"\"\n        return self._axes[viewport.get_uuid()]\n\n    def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n        \"\"\"Get the underlying Matplotlib figure.\n\n        Returns:\n            The Matplotlib Figure object used by this renderer.\n        \"\"\"\n        return self._figure\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.__init__","title":"<code>__init__(canvas: Canvas)</code>","text":"<p>Initialize the Matplotlib renderer.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>gsp.core.canvas.Canvas</code> <p>The canvas defining the rendering surface dimensions and DPI.</p> required Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def __init__(self, canvas: Canvas):\n    \"\"\"Initialize the Matplotlib renderer.\n\n    Args:\n        canvas: The canvas defining the rendering surface dimensions and DPI.\n    \"\"\"\n    self.canvas = canvas\n    # Store mapping of viewport UUIDs to axes\n    self._axes: dict[str, matplotlib.axes.Axes] = {}\n    # Store mapping of visual UUIDs to matplotlib artists\n    self._artists: dict[str, matplotlib.artist.Artist] = {}\n    # Store group count per visual UUID\n    self._group_count: dict[str, int] = {}\n\n    # Create a figure\n    figure_width = canvas.get_width() / canvas.get_dpi()\n    figure_height = canvas.get_height() / canvas.get_dpi()\n    self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=canvas.get_dpi())\n    assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n    self._figure.canvas.manager.set_window_title(\"Matplotlib\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.get_canvas","title":"<code>get_canvas() -&gt; Canvas</code>","text":"<p>Get the canvas associated with this renderer.</p> <p>Returns:</p> Type Description <code>gsp.core.canvas.Canvas</code> <p>The canvas instance.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def get_canvas(self) -&gt; Canvas:\n    \"\"\"Get the canvas associated with this renderer.\n\n    Returns:\n        The canvas instance.\n    \"\"\"\n    return self.canvas\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the renderer and release resources.</p> <p>Stops the Matplotlib event loop and closes the figure.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the renderer and release resources.\n\n    Stops the Matplotlib event loop and closes the figure.\n    \"\"\"\n    # warnings.warn(f\"Closing NetworkRenderer does not release any resources.\", UserWarning)\n    # stop the event loop if any - thus .show(block=True) will return\n    self._figure.canvas.stop_event_loop()\n    # close the figure\n    matplotlib.pyplot.close(self._figure)\n    self._figure = None  # type: ignore\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.show","title":"<code>show() -&gt; None</code>","text":"<p>Display the rendered figure in an interactive window.</p> <p>This method shows the Matplotlib figure. It does nothing when running in test mode (GSP_TEST environment variable set to \"True\").</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Display the rendered figure in an interactive window.\n\n    This method shows the Matplotlib figure. It does nothing when running\n    in test mode (GSP_TEST environment variable set to \"True\").\n    \"\"\"\n    # handle non-interactive mode for tests\n    in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n    if in_test:\n        return\n\n    matplotlib.pyplot.show()\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.render","title":"<code>render(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera], return_image: bool = True, image_format: str = 'png') -&gt; bytes</code>","text":"<p>Render the scene to an image.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>Sequence of viewport regions to render into.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>Sequence of visual elements to render.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>Sequence of model transformation matrices for each visual.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>Sequence of cameras defining view and projection for each visual.</p> required <code>return_image</code> <code>bool</code> <p>Whether to return the rendered image as bytes.</p> <code>True</code> <code>image_format</code> <code>str</code> <p>Format for the output image (e.g., \"png\", \"jpg\").</p> <code>'png'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The rendered image as bytes in the specified format, or empty bytes if return_image is False.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the sequences don't all have the same length.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def render(\n    self,\n    viewports: Sequence[Viewport],\n    visuals: Sequence[VisualBase],\n    model_matrices: Sequence[TransBuf],\n    cameras: Sequence[Camera],\n    return_image: bool = True,\n    image_format: str = \"png\",\n) -&gt; bytes:\n    \"\"\"Render the scene to an image.\n\n    Args:\n        viewports: Sequence of viewport regions to render into.\n        visuals: Sequence of visual elements to render.\n        model_matrices: Sequence of model transformation matrices for each visual.\n        cameras: Sequence of cameras defining view and projection for each visual.\n        return_image: Whether to return the rendered image as bytes.\n        image_format: Format for the output image (e.g., \"png\", \"jpg\").\n\n    Returns:\n        The rendered image as bytes in the specified format, or empty bytes if return_image is False.\n\n    Raises:\n        AssertionError: If the sequences don't all have the same length.\n    \"\"\"\n    # =============================================================================\n    # Sanity checks\n    # =============================================================================\n\n    assert (\n        len(viewports) == len(visuals) == len(model_matrices) == len(cameras)\n    ), f\"All length MUST be equal. Mismatched lengths: {len(viewports)} viewports, {len(visuals)} visuals, {len(model_matrices)} model matrices, {len(cameras)} cameras\"\n\n    # =============================================================================\n    # Create all the axes if needed\n    # =============================================================================\n    for viewport in viewports:\n        if viewport.get_uuid() in self._axes:\n            continue\n        axes_rect = (\n            viewport.get_x() / self.canvas.get_width(),\n            viewport.get_y() / self.canvas.get_height(),\n            viewport.get_width() / self.canvas.get_width(),\n            viewport.get_height() / self.canvas.get_height(),\n        )\n        axes: matplotlib.axes.Axes = matplotlib.pyplot.axes(axes_rect)\n        # this should be -1 to 1 - from normalized device coordinates - https://en.wikipedia.org/wiki/Graphics_pipeline\n        # - https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection\n        axes.set_xlim(-1, 1)\n        axes.set_ylim(-1, 1)\n        # hide the borders\n        axes.axis(\"off\")\n        # store axes for this viewport\n        self._axes[viewport.get_uuid()] = axes\n\n    # =============================================================================\n    # Render each visual\n    # =============================================================================\n\n    for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n        self._render_visual(viewport, visual, model_matrix, camera)\n\n    # =============================================================================\n    # Render the output image\n    # =============================================================================\n    image_png_data = b\"\"\n\n    # honor return_image option\n    if return_image:\n        # Render the image to a PNG buffer\n        image_png_buffer = io.BytesIO()\n        self._figure.savefig(image_png_buffer, format=image_format, dpi=self.canvas.get_dpi())\n\n        image_png_buffer.seek(0)\n        image_png_data = image_png_buffer.getvalue()\n        image_png_buffer.close()\n\n    return image_png_data\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.get_mpl_axes_for_viewport","title":"<code>get_mpl_axes_for_viewport(viewport: Viewport) -&gt; matplotlib.axes.Axes</code>","text":"<p>Get the Matplotlib axes associated with a viewport.</p> <p>Parameters:</p> Name Type Description Default <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to get axes for.</p> required <p>Returns:</p> Type Description <code>matplotlib.axes.Axes</code> <p>The Matplotlib Axes object for the given viewport.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def get_mpl_axes_for_viewport(self, viewport: Viewport) -&gt; matplotlib.axes.Axes:\n    \"\"\"Get the Matplotlib axes associated with a viewport.\n\n    Args:\n        viewport: The viewport to get axes for.\n\n    Returns:\n        The Matplotlib Axes object for the given viewport.\n    \"\"\"\n    return self._axes[viewport.get_uuid()]\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.MatplotlibRenderer.get_mpl_figure","title":"<code>get_mpl_figure() -&gt; matplotlib.figure.Figure</code>","text":"<p>Get the underlying Matplotlib figure.</p> <p>Returns:</p> Type Description <code>matplotlib.figure.Figure</code> <p>The Matplotlib Figure object used by this renderer.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n    \"\"\"Get the underlying Matplotlib figure.\n\n    Returns:\n        The Matplotlib Figure object used by this renderer.\n    \"\"\"\n    return self._figure\n</code></pre>"},{"location":"api/gsp_matplotlib/#matplotlib-renderer","title":"Matplotlib Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer</code>","text":"<p>Matplotlib renderer for GSP visuals.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer","title":"<code>MatplotlibRenderer</code>","text":"<p>               Bases: <code>gsp.types.renderer_base.RendererBase</code></p> <p>Matplotlib-based renderer for GSP visuals.</p> <p>This renderer implements the GSP rendering interface using Matplotlib as the backend. It creates and manages a Matplotlib figure with multiple axes for different viewports, and renders various visual types (pixels, points, paths, markers, segments, texts) into them.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>class MatplotlibRenderer(RendererBase):\n    \"\"\"Matplotlib-based renderer for GSP visuals.\n\n    This renderer implements the GSP rendering interface using Matplotlib as the backend.\n    It creates and manages a Matplotlib figure with multiple axes for different viewports,\n    and renders various visual types (pixels, points, paths, markers, segments, texts) into them.\n    \"\"\"\n\n    def __init__(self, canvas: Canvas):\n        \"\"\"Initialize the Matplotlib renderer.\n\n        Args:\n            canvas: The canvas defining the rendering surface dimensions and DPI.\n        \"\"\"\n        self.canvas = canvas\n        # Store mapping of viewport UUIDs to axes\n        self._axes: dict[str, matplotlib.axes.Axes] = {}\n        # Store mapping of visual UUIDs to matplotlib artists\n        self._artists: dict[str, matplotlib.artist.Artist] = {}\n        # Store group count per visual UUID\n        self._group_count: dict[str, int] = {}\n\n        # Create a figure\n        figure_width = canvas.get_width() / canvas.get_dpi()\n        figure_height = canvas.get_height() / canvas.get_dpi()\n        self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=canvas.get_dpi())\n        assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n        self._figure.canvas.manager.set_window_title(\"Matplotlib\")\n\n    def get_canvas(self) -&gt; Canvas:\n        \"\"\"Get the canvas associated with this renderer.\n\n        Returns:\n            The canvas instance.\n        \"\"\"\n        return self.canvas\n\n    def close(self) -&gt; None:\n        \"\"\"Close the renderer and release resources.\n\n        Stops the Matplotlib event loop and closes the figure.\n        \"\"\"\n        # warnings.warn(f\"Closing NetworkRenderer does not release any resources.\", UserWarning)\n        # stop the event loop if any - thus .show(block=True) will return\n        self._figure.canvas.stop_event_loop()\n        # close the figure\n        matplotlib.pyplot.close(self._figure)\n        self._figure = None  # type: ignore\n\n    def show(self) -&gt; None:\n        \"\"\"Display the rendered figure in an interactive window.\n\n        This method shows the Matplotlib figure. It does nothing when running\n        in test mode (GSP_TEST environment variable set to \"True\").\n        \"\"\"\n        # handle non-interactive mode for tests\n        in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n        if in_test:\n            return\n\n        matplotlib.pyplot.show()\n\n    def render(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n        return_image: bool = True,\n        image_format: str = \"png\",\n    ) -&gt; bytes:\n        \"\"\"Render the scene to an image.\n\n        Args:\n            viewports: Sequence of viewport regions to render into.\n            visuals: Sequence of visual elements to render.\n            model_matrices: Sequence of model transformation matrices for each visual.\n            cameras: Sequence of cameras defining view and projection for each visual.\n            return_image: Whether to return the rendered image as bytes.\n            image_format: Format for the output image (e.g., \"png\", \"jpg\").\n\n        Returns:\n            The rendered image as bytes in the specified format, or empty bytes if return_image is False.\n\n        Raises:\n            AssertionError: If the sequences don't all have the same length.\n        \"\"\"\n        # =============================================================================\n        # Sanity checks\n        # =============================================================================\n\n        assert (\n            len(viewports) == len(visuals) == len(model_matrices) == len(cameras)\n        ), f\"All length MUST be equal. Mismatched lengths: {len(viewports)} viewports, {len(visuals)} visuals, {len(model_matrices)} model matrices, {len(cameras)} cameras\"\n\n        # =============================================================================\n        # Create all the axes if needed\n        # =============================================================================\n        for viewport in viewports:\n            if viewport.get_uuid() in self._axes:\n                continue\n            axes_rect = (\n                viewport.get_x() / self.canvas.get_width(),\n                viewport.get_y() / self.canvas.get_height(),\n                viewport.get_width() / self.canvas.get_width(),\n                viewport.get_height() / self.canvas.get_height(),\n            )\n            axes: matplotlib.axes.Axes = matplotlib.pyplot.axes(axes_rect)\n            # this should be -1 to 1 - from normalized device coordinates - https://en.wikipedia.org/wiki/Graphics_pipeline\n            # - https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection\n            axes.set_xlim(-1, 1)\n            axes.set_ylim(-1, 1)\n            # hide the borders\n            axes.axis(\"off\")\n            # store axes for this viewport\n            self._axes[viewport.get_uuid()] = axes\n\n        # =============================================================================\n        # Render each visual\n        # =============================================================================\n\n        for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n            self._render_visual(viewport, visual, model_matrix, camera)\n\n        # =============================================================================\n        # Render the output image\n        # =============================================================================\n        image_png_data = b\"\"\n\n        # honor return_image option\n        if return_image:\n            # Render the image to a PNG buffer\n            image_png_buffer = io.BytesIO()\n            self._figure.savefig(image_png_buffer, format=image_format, dpi=self.canvas.get_dpi())\n\n            image_png_buffer.seek(0)\n            image_png_data = image_png_buffer.getvalue()\n            image_png_buffer.close()\n\n        return image_png_data\n\n    def _render_visual(self, viewport: Viewport, visual: VisualBase, model_matrix: TransBuf, camera: Camera):\n        \"\"\"Render a single visual in a given viewport using the specified camera.\"\"\"\n        if isinstance(visual, Pixels):\n            from gsp_matplotlib.renderer.matplotlib_renderer_pixels import RendererPixels\n\n            RendererPixels.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Points):\n            from gsp_matplotlib.renderer.matplotlib_renderer_points import RendererPoints\n\n            RendererPoints.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Paths):\n            from gsp_matplotlib.renderer.matplotlib_renderer_paths import RendererPaths\n\n            RendererPaths.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Markers):\n            from gsp_matplotlib.renderer.matplotlib_renderer_markers import RendererMarkers\n\n            RendererMarkers.render(self, viewport, visual, model_matrix, camera)\n        elif isinstance(visual, Segments):\n            from gsp_matplotlib.renderer.matplotlib_renderer_segments import RendererSegments\n\n            RendererSegments.render(self, viewport, visual, model_matrix, camera)\n\n        elif isinstance(visual, Texts):\n            from gsp_matplotlib.renderer.matplotlib_renderer_texts import RendererTexts\n\n            RendererTexts.render(self, viewport, visual, model_matrix, camera)\n        else:\n            raise NotImplementedError(f\"Rendering for visual type {type(visual)} is not implemented.\")\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    def get_mpl_axes_for_viewport(self, viewport: Viewport) -&gt; matplotlib.axes.Axes:\n        \"\"\"Get the Matplotlib axes associated with a viewport.\n\n        Args:\n            viewport: The viewport to get axes for.\n\n        Returns:\n            The Matplotlib Axes object for the given viewport.\n        \"\"\"\n        return self._axes[viewport.get_uuid()]\n\n    def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n        \"\"\"Get the underlying Matplotlib figure.\n\n        Returns:\n            The Matplotlib Figure object used by this renderer.\n        \"\"\"\n        return self._figure\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.__init__","title":"<code>__init__(canvas: Canvas)</code>","text":"<p>Initialize the Matplotlib renderer.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>gsp.core.canvas.Canvas</code> <p>The canvas defining the rendering surface dimensions and DPI.</p> required Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def __init__(self, canvas: Canvas):\n    \"\"\"Initialize the Matplotlib renderer.\n\n    Args:\n        canvas: The canvas defining the rendering surface dimensions and DPI.\n    \"\"\"\n    self.canvas = canvas\n    # Store mapping of viewport UUIDs to axes\n    self._axes: dict[str, matplotlib.axes.Axes] = {}\n    # Store mapping of visual UUIDs to matplotlib artists\n    self._artists: dict[str, matplotlib.artist.Artist] = {}\n    # Store group count per visual UUID\n    self._group_count: dict[str, int] = {}\n\n    # Create a figure\n    figure_width = canvas.get_width() / canvas.get_dpi()\n    figure_height = canvas.get_height() / canvas.get_dpi()\n    self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=canvas.get_dpi())\n    assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n    self._figure.canvas.manager.set_window_title(\"Matplotlib\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the renderer and release resources.</p> <p>Stops the Matplotlib event loop and closes the figure.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the renderer and release resources.\n\n    Stops the Matplotlib event loop and closes the figure.\n    \"\"\"\n    # warnings.warn(f\"Closing NetworkRenderer does not release any resources.\", UserWarning)\n    # stop the event loop if any - thus .show(block=True) will return\n    self._figure.canvas.stop_event_loop()\n    # close the figure\n    matplotlib.pyplot.close(self._figure)\n    self._figure = None  # type: ignore\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.get_canvas","title":"<code>get_canvas() -&gt; Canvas</code>","text":"<p>Get the canvas associated with this renderer.</p> <p>Returns:</p> Type Description <code>gsp.core.canvas.Canvas</code> <p>The canvas instance.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def get_canvas(self) -&gt; Canvas:\n    \"\"\"Get the canvas associated with this renderer.\n\n    Returns:\n        The canvas instance.\n    \"\"\"\n    return self.canvas\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.get_mpl_axes_for_viewport","title":"<code>get_mpl_axes_for_viewport(viewport: Viewport) -&gt; matplotlib.axes.Axes</code>","text":"<p>Get the Matplotlib axes associated with a viewport.</p> <p>Parameters:</p> Name Type Description Default <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to get axes for.</p> required <p>Returns:</p> Type Description <code>matplotlib.axes.Axes</code> <p>The Matplotlib Axes object for the given viewport.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def get_mpl_axes_for_viewport(self, viewport: Viewport) -&gt; matplotlib.axes.Axes:\n    \"\"\"Get the Matplotlib axes associated with a viewport.\n\n    Args:\n        viewport: The viewport to get axes for.\n\n    Returns:\n        The Matplotlib Axes object for the given viewport.\n    \"\"\"\n    return self._axes[viewport.get_uuid()]\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.get_mpl_figure","title":"<code>get_mpl_figure() -&gt; matplotlib.figure.Figure</code>","text":"<p>Get the underlying Matplotlib figure.</p> <p>Returns:</p> Type Description <code>matplotlib.figure.Figure</code> <p>The Matplotlib Figure object used by this renderer.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n    \"\"\"Get the underlying Matplotlib figure.\n\n    Returns:\n        The Matplotlib Figure object used by this renderer.\n    \"\"\"\n    return self._figure\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.render","title":"<code>render(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera], return_image: bool = True, image_format: str = 'png') -&gt; bytes</code>","text":"<p>Render the scene to an image.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>Sequence of viewport regions to render into.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>Sequence of visual elements to render.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>Sequence of model transformation matrices for each visual.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>Sequence of cameras defining view and projection for each visual.</p> required <code>return_image</code> <code>bool</code> <p>Whether to return the rendered image as bytes.</p> <code>True</code> <code>image_format</code> <code>str</code> <p>Format for the output image (e.g., \"png\", \"jpg\").</p> <code>'png'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The rendered image as bytes in the specified format, or empty bytes if return_image is False.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the sequences don't all have the same length.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def render(\n    self,\n    viewports: Sequence[Viewport],\n    visuals: Sequence[VisualBase],\n    model_matrices: Sequence[TransBuf],\n    cameras: Sequence[Camera],\n    return_image: bool = True,\n    image_format: str = \"png\",\n) -&gt; bytes:\n    \"\"\"Render the scene to an image.\n\n    Args:\n        viewports: Sequence of viewport regions to render into.\n        visuals: Sequence of visual elements to render.\n        model_matrices: Sequence of model transformation matrices for each visual.\n        cameras: Sequence of cameras defining view and projection for each visual.\n        return_image: Whether to return the rendered image as bytes.\n        image_format: Format for the output image (e.g., \"png\", \"jpg\").\n\n    Returns:\n        The rendered image as bytes in the specified format, or empty bytes if return_image is False.\n\n    Raises:\n        AssertionError: If the sequences don't all have the same length.\n    \"\"\"\n    # =============================================================================\n    # Sanity checks\n    # =============================================================================\n\n    assert (\n        len(viewports) == len(visuals) == len(model_matrices) == len(cameras)\n    ), f\"All length MUST be equal. Mismatched lengths: {len(viewports)} viewports, {len(visuals)} visuals, {len(model_matrices)} model matrices, {len(cameras)} cameras\"\n\n    # =============================================================================\n    # Create all the axes if needed\n    # =============================================================================\n    for viewport in viewports:\n        if viewport.get_uuid() in self._axes:\n            continue\n        axes_rect = (\n            viewport.get_x() / self.canvas.get_width(),\n            viewport.get_y() / self.canvas.get_height(),\n            viewport.get_width() / self.canvas.get_width(),\n            viewport.get_height() / self.canvas.get_height(),\n        )\n        axes: matplotlib.axes.Axes = matplotlib.pyplot.axes(axes_rect)\n        # this should be -1 to 1 - from normalized device coordinates - https://en.wikipedia.org/wiki/Graphics_pipeline\n        # - https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection\n        axes.set_xlim(-1, 1)\n        axes.set_ylim(-1, 1)\n        # hide the borders\n        axes.axis(\"off\")\n        # store axes for this viewport\n        self._axes[viewport.get_uuid()] = axes\n\n    # =============================================================================\n    # Render each visual\n    # =============================================================================\n\n    for viewport, visual, model_matrix, camera in zip(viewports, visuals, model_matrices, cameras):\n        self._render_visual(viewport, visual, model_matrix, camera)\n\n    # =============================================================================\n    # Render the output image\n    # =============================================================================\n    image_png_data = b\"\"\n\n    # honor return_image option\n    if return_image:\n        # Render the image to a PNG buffer\n        image_png_buffer = io.BytesIO()\n        self._figure.savefig(image_png_buffer, format=image_format, dpi=self.canvas.get_dpi())\n\n        image_png_buffer.seek(0)\n        image_png_data = image_png_buffer.getvalue()\n        image_png_buffer.close()\n\n    return image_png_data\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer.show","title":"<code>show() -&gt; None</code>","text":"<p>Display the rendered figure in an interactive window.</p> <p>This method shows the Matplotlib figure. It does nothing when running in test mode (GSP_TEST environment variable set to \"True\").</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Display the rendered figure in an interactive window.\n\n    This method shows the Matplotlib figure. It does nothing when running\n    in test mode (GSP_TEST environment variable set to \"True\").\n    \"\"\"\n    # handle non-interactive mode for tests\n    in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n    if in_test:\n        return\n\n    matplotlib.pyplot.show()\n</code></pre>"},{"location":"api/gsp_matplotlib/#markers-renderer","title":"Markers Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_markers","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_markers</code>","text":"<p>Matplotlib renderer for Markers objects.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_markers.RendererMarkers","title":"<code>RendererMarkers</code>","text":"<p>Renderer for Markers objects using Matplotlib.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_markers.py</code> <pre><code>class RendererMarkers:\n    \"\"\"Renderer for Markers objects using Matplotlib.\"\"\"\n    @staticmethod\n    def render(\n        renderer: MatplotlibRenderer,\n        viewport: Viewport,\n        markers: Markers,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Render the given Markers object onto the specified viewport using Matplotlib.\n\n        Args:\n            renderer (MatplotlibRenderer): The renderer instance.\n            viewport (Viewport): The viewport to render onto.\n            markers (Markers): The Markers object containing marker data.\n            model_matrix (TransBuf): The model transformation matrix.           \n            camera (Camera): The camera providing view and projection matrices.\n\n        Returns:\n            list[matplotlib.artist.Artist]: A list of Matplotlib artist objects created or updated\n        \"\"\"\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(markers.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 2D - shape (N, 2)\n        vertices_2d = vertices_3d_transformed[:, :2]\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        # Convert all attributes to buffer\n        sizes_buffer = TransBufUtils.to_buffer(markers.get_sizes())\n        face_colors_buffer = TransBufUtils.to_buffer(markers.get_face_colors())\n        edge_colors_buffer = TransBufUtils.to_buffer(markers.get_edge_colors())\n        edge_widths_buffer = TransBufUtils.to_buffer(markers.get_edge_widths())\n\n        # Convert buffers to numpy arrays\n        sizes_numpy = Bufferx.to_numpy(sizes_buffer).reshape(-1)\n        face_colors_numpy = Bufferx.to_numpy(face_colors_buffer) / 255.0  # normalize to [0, 1] range\n        edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer) / 255.0  # normalize to [0, 1] range\n        edge_widths_numpy = Bufferx.to_numpy(edge_widths_buffer).flatten()\n\n        # =============================================================================\n        # Create the artists if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{markers.get_uuid()}\"\n\n        if artist_uuid not in renderer._artists:\n            axes = renderer.get_mpl_axes_for_viewport(viewport)\n            mpl_marker_shape = ConverterUtils.marker_shape_gsp_to_mpl(markers.get_marker_shape())\n            mpl_path_collection = axes.scatter([], [], marker=mpl_marker_shape)\n            mpl_path_collection.set_visible(False)\n            # hide until properly positioned and sized\n            renderer._artists[artist_uuid] = mpl_path_collection\n            axes.add_artist(mpl_path_collection)\n\n        # =============================================================================\n        # Get existing artists\n        # =============================================================================\n\n        mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[artist_uuid])\n        mpl_path_collection.set_visible(True)\n\n        # =============================================================================\n        # Update artists\n        # =============================================================================\n\n        mpl_path_collection.set_offsets(offsets=vertices_2d)\n        mpl_path_collection.set_sizes(typing.cast(list, sizes_numpy))\n        mpl_path_collection.set_facecolor(typing.cast(list, face_colors_numpy))\n        mpl_path_collection.set_edgecolor(typing.cast(list, edge_colors_numpy))\n        mpl_path_collection.set_linewidth(typing.cast(list, edge_widths_numpy))\n\n        # Return the list of artists created/updated\n        return [mpl_path_collection]\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_markers.RendererMarkers.render","title":"<code>render(renderer: MatplotlibRenderer, viewport: Viewport, markers: Markers, model_matrix: TransBuf, camera: Camera) -&gt; list[matplotlib.artist.Artist]</code>  <code>staticmethod</code>","text":"<p>Render the given Markers object onto the specified viewport using Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer</code> <p>The renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render onto.</p> required <code>markers</code> <code>gsp.visuals.Markers</code> <p>The Markers object containing marker data.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model transformation matrix.           </p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera providing view and projection matrices.</p> required <p>Returns:</p> Type Description <code>list[matplotlib.artist.Artist]</code> <p>list[matplotlib.artist.Artist]: A list of Matplotlib artist objects created or updated</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_markers.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: MatplotlibRenderer,\n    viewport: Viewport,\n    markers: Markers,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; list[matplotlib.artist.Artist]:\n    \"\"\"Render the given Markers object onto the specified viewport using Matplotlib.\n\n    Args:\n        renderer (MatplotlibRenderer): The renderer instance.\n        viewport (Viewport): The viewport to render onto.\n        markers (Markers): The Markers object containing marker data.\n        model_matrix (TransBuf): The model transformation matrix.           \n        camera (Camera): The camera providing view and projection matrices.\n\n    Returns:\n        list[matplotlib.artist.Artist]: A list of Matplotlib artist objects created or updated\n    \"\"\"\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(markers.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 2D - shape (N, 2)\n    vertices_2d = vertices_3d_transformed[:, :2]\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    # Convert all attributes to buffer\n    sizes_buffer = TransBufUtils.to_buffer(markers.get_sizes())\n    face_colors_buffer = TransBufUtils.to_buffer(markers.get_face_colors())\n    edge_colors_buffer = TransBufUtils.to_buffer(markers.get_edge_colors())\n    edge_widths_buffer = TransBufUtils.to_buffer(markers.get_edge_widths())\n\n    # Convert buffers to numpy arrays\n    sizes_numpy = Bufferx.to_numpy(sizes_buffer).reshape(-1)\n    face_colors_numpy = Bufferx.to_numpy(face_colors_buffer) / 255.0  # normalize to [0, 1] range\n    edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer) / 255.0  # normalize to [0, 1] range\n    edge_widths_numpy = Bufferx.to_numpy(edge_widths_buffer).flatten()\n\n    # =============================================================================\n    # Create the artists if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{markers.get_uuid()}\"\n\n    if artist_uuid not in renderer._artists:\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        mpl_marker_shape = ConverterUtils.marker_shape_gsp_to_mpl(markers.get_marker_shape())\n        mpl_path_collection = axes.scatter([], [], marker=mpl_marker_shape)\n        mpl_path_collection.set_visible(False)\n        # hide until properly positioned and sized\n        renderer._artists[artist_uuid] = mpl_path_collection\n        axes.add_artist(mpl_path_collection)\n\n    # =============================================================================\n    # Get existing artists\n    # =============================================================================\n\n    mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[artist_uuid])\n    mpl_path_collection.set_visible(True)\n\n    # =============================================================================\n    # Update artists\n    # =============================================================================\n\n    mpl_path_collection.set_offsets(offsets=vertices_2d)\n    mpl_path_collection.set_sizes(typing.cast(list, sizes_numpy))\n    mpl_path_collection.set_facecolor(typing.cast(list, face_colors_numpy))\n    mpl_path_collection.set_edgecolor(typing.cast(list, edge_colors_numpy))\n    mpl_path_collection.set_linewidth(typing.cast(list, edge_widths_numpy))\n\n    # Return the list of artists created/updated\n    return [mpl_path_collection]\n</code></pre>"},{"location":"api/gsp_matplotlib/#paths-renderer","title":"Paths Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_paths","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_paths</code>","text":"<p>Matplotlib renderer for Paths objects.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_paths.RendererPaths","title":"<code>RendererPaths</code>","text":"<p>Renderer for Paths objects using Matplotlib.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_paths.py</code> <pre><code>class RendererPaths:\n    \"\"\"Renderer for Paths objects using Matplotlib.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: MatplotlibRenderer,\n        viewport: Viewport,\n        paths: Paths,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Render the given Paths object onto the specified viewport using Matplotlib.\n\n        Args:\n            renderer (MatplotlibRenderer): The renderer instance.\n            viewport (Viewport): The viewport to render onto.\n            paths (Paths): The Paths object containing path data.\n            model_matrix (TransBuf): The model transformation matrix.\n            camera (Camera): The camera providing view and projection matrices.\n\n        Returns:\n            list[matplotlib.artist.Artist]: A list of Matplotlib artist objects created or updated\n        \"\"\"\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(paths.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 2D - shape (N, 2)\n        vertices_2d = vertices_3d_transformed[:, :2]\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        # Convert all attributes to buffer\n        path_sizes_buffer = TransBufUtils.to_buffer(paths.get_path_sizes())\n        colors_buffer = TransBufUtils.to_buffer(paths.get_colors())\n        line_widths_buffer = TransBufUtils.to_buffer(paths.get_line_widths())\n\n        # Convert buffers to numpy arrays\n        path_sizes_numpy = Bufferx.to_numpy(path_sizes_buffer)\n        colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n        line_widths_numpy = Bufferx.to_numpy(line_widths_buffer)\n        line_widths_numpy = line_widths_numpy.reshape(-1)\n\n        # =============================================================================\n        #\n        # =============================================================================\n        # mpl_paths is of shape (M, 2, 2) where M is total number of line segments across all paths\n        mpl_paths = np.zeros((0, 2, 2), dtype=np.float32)\n        # mpl_colors is of shape (M, 4)\n        mpl_colors = np.zeros((0, 4), dtype=np.float32)\n        # mpl_line_widths is of shape (M,)\n        mpl_line_widths = np.zeros((0,), dtype=np.float32)\n\n        for path_index, path_size in enumerate(path_sizes_numpy):\n            path_start = int(np.sum(path_sizes_numpy[:path_index]))\n            path_size_int = int(path_size)\n            path_vertices_2d = vertices_2d[path_start : path_start + path_size_int]\n\n            # Create segments for this path\n            path_mpl_paths = np.concatenate([path_vertices_2d[:-1].reshape(-1, 1, 2), path_vertices_2d[1:].reshape(-1, 1, 2)], axis=1)\n            mpl_paths = np.vstack([mpl_paths, path_mpl_paths])\n\n            mpl_colors = np.vstack([mpl_colors, colors_numpy[path_start : path_start + path_size_int - 1]])\n            mpl_line_widths = np.hstack([mpl_line_widths, line_widths_numpy[path_start : path_start + path_size_int - 1]])\n\n        # =============================================================================\n        # Create the artists if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{paths.get_uuid()}\"\n\n        if artist_uuid not in renderer._artists:\n            mpl_line_collection = matplotlib.collections.LineCollection([])\n            mpl_line_collection.set_visible(False)\n            # hide until properly positioned and sized\n            renderer._artists[artist_uuid] = mpl_line_collection\n            axes = renderer.get_mpl_axes_for_viewport(viewport)\n            axes.add_artist(mpl_line_collection)\n\n        # =============================================================================\n        # Get existing artists\n        # =============================================================================\n\n        mpl_line_collection = typing.cast(matplotlib.collections.LineCollection, renderer._artists[artist_uuid])\n        mpl_line_collection.set_visible(True)\n\n        # =============================================================================\n        # Update artists\n        # =============================================================================\n\n        mpl_line_collection.set_paths(typing.cast(list, mpl_paths))\n        mpl_line_collection.set_color(typing.cast(list, mpl_colors))\n        mpl_line_collection.set_linewidth(typing.cast(list, mpl_line_widths))\n        mpl_line_collection.set_capstyle(ConverterUtils.cap_style_gsp_to_mpl(paths.get_cap_style()))\n        mpl_line_collection.set_joinstyle(ConverterUtils.join_style_gsp_to_mpl(paths.get_join_style()))\n\n        # Return the list of artists created/updated\n        changed_artists: list[matplotlib.artist.Artist] = []\n        changed_artists.append(mpl_line_collection)\n        return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_paths.RendererPaths.render","title":"<code>render(renderer: MatplotlibRenderer, viewport: Viewport, paths: Paths, model_matrix: TransBuf, camera: Camera) -&gt; list[matplotlib.artist.Artist]</code>  <code>staticmethod</code>","text":"<p>Render the given Paths object onto the specified viewport using Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer</code> <p>The renderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport to render onto.</p> required <code>paths</code> <code>gsp.visuals.paths.Paths</code> <p>The Paths object containing path data.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model transformation matrix.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The camera providing view and projection matrices.</p> required <p>Returns:</p> Type Description <code>list[matplotlib.artist.Artist]</code> <p>list[matplotlib.artist.Artist]: A list of Matplotlib artist objects created or updated</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_paths.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: MatplotlibRenderer,\n    viewport: Viewport,\n    paths: Paths,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; list[matplotlib.artist.Artist]:\n    \"\"\"Render the given Paths object onto the specified viewport using Matplotlib.\n\n    Args:\n        renderer (MatplotlibRenderer): The renderer instance.\n        viewport (Viewport): The viewport to render onto.\n        paths (Paths): The Paths object containing path data.\n        model_matrix (TransBuf): The model transformation matrix.\n        camera (Camera): The camera providing view and projection matrices.\n\n    Returns:\n        list[matplotlib.artist.Artist]: A list of Matplotlib artist objects created or updated\n    \"\"\"\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(paths.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 2D - shape (N, 2)\n    vertices_2d = vertices_3d_transformed[:, :2]\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    # Convert all attributes to buffer\n    path_sizes_buffer = TransBufUtils.to_buffer(paths.get_path_sizes())\n    colors_buffer = TransBufUtils.to_buffer(paths.get_colors())\n    line_widths_buffer = TransBufUtils.to_buffer(paths.get_line_widths())\n\n    # Convert buffers to numpy arrays\n    path_sizes_numpy = Bufferx.to_numpy(path_sizes_buffer)\n    colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n    line_widths_numpy = Bufferx.to_numpy(line_widths_buffer)\n    line_widths_numpy = line_widths_numpy.reshape(-1)\n\n    # =============================================================================\n    #\n    # =============================================================================\n    # mpl_paths is of shape (M, 2, 2) where M is total number of line segments across all paths\n    mpl_paths = np.zeros((0, 2, 2), dtype=np.float32)\n    # mpl_colors is of shape (M, 4)\n    mpl_colors = np.zeros((0, 4), dtype=np.float32)\n    # mpl_line_widths is of shape (M,)\n    mpl_line_widths = np.zeros((0,), dtype=np.float32)\n\n    for path_index, path_size in enumerate(path_sizes_numpy):\n        path_start = int(np.sum(path_sizes_numpy[:path_index]))\n        path_size_int = int(path_size)\n        path_vertices_2d = vertices_2d[path_start : path_start + path_size_int]\n\n        # Create segments for this path\n        path_mpl_paths = np.concatenate([path_vertices_2d[:-1].reshape(-1, 1, 2), path_vertices_2d[1:].reshape(-1, 1, 2)], axis=1)\n        mpl_paths = np.vstack([mpl_paths, path_mpl_paths])\n\n        mpl_colors = np.vstack([mpl_colors, colors_numpy[path_start : path_start + path_size_int - 1]])\n        mpl_line_widths = np.hstack([mpl_line_widths, line_widths_numpy[path_start : path_start + path_size_int - 1]])\n\n    # =============================================================================\n    # Create the artists if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{paths.get_uuid()}\"\n\n    if artist_uuid not in renderer._artists:\n        mpl_line_collection = matplotlib.collections.LineCollection([])\n        mpl_line_collection.set_visible(False)\n        # hide until properly positioned and sized\n        renderer._artists[artist_uuid] = mpl_line_collection\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        axes.add_artist(mpl_line_collection)\n\n    # =============================================================================\n    # Get existing artists\n    # =============================================================================\n\n    mpl_line_collection = typing.cast(matplotlib.collections.LineCollection, renderer._artists[artist_uuid])\n    mpl_line_collection.set_visible(True)\n\n    # =============================================================================\n    # Update artists\n    # =============================================================================\n\n    mpl_line_collection.set_paths(typing.cast(list, mpl_paths))\n    mpl_line_collection.set_color(typing.cast(list, mpl_colors))\n    mpl_line_collection.set_linewidth(typing.cast(list, mpl_line_widths))\n    mpl_line_collection.set_capstyle(ConverterUtils.cap_style_gsp_to_mpl(paths.get_cap_style()))\n    mpl_line_collection.set_joinstyle(ConverterUtils.join_style_gsp_to_mpl(paths.get_join_style()))\n\n    # Return the list of artists created/updated\n    changed_artists: list[matplotlib.artist.Artist] = []\n    changed_artists.append(mpl_line_collection)\n    return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#pixels-renderer","title":"Pixels Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_pixels</code>","text":"<p>\"Renderer for Pixels using Matplotlib.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels.RendererPixels","title":"<code>RendererPixels</code>","text":"<p>Renderer for Pixels using Matplotlib.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_pixels.py</code> <pre><code>class RendererPixels:\n    \"\"\"Renderer for Pixels using Matplotlib.\"\"\"\n    @staticmethod\n    def render(\n        renderer: MatplotlibRenderer,\n        viewport: Viewport,\n        pixels: Pixels,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Render Pixels visual using Matplotlib.\n\n        Args:\n            renderer: The MatplotlibRenderer instance.\n            viewport: The Viewport in which to render.\n            pixels: The Pixels visual to render.\n            model_matrix: The model transformation matrix as a TransBuf.\n            camera: The Camera providing view and projection matrices.      \n\n        Returns:\n            list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n        \"\"\"\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(pixels.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 2D - shape (N, 2)\n        vertices_2d = vertices_3d_transformed[:, :2]\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        # Convert all attributes to buffer\n        color_buffer = TransBufUtils.to_buffer(pixels.get_colors())\n\n        # Convert buffers to numpy arrays\n        colors_numpy = Bufferx.to_numpy(color_buffer) / 255.0  # normalize to [0, 1] range\n\n        # Sanity check - check visual attributes\n        Pixels.sanity_check_attribute_buffers(vertices_buffer, color_buffer, pixels.get_groups())\n\n        # =============================================================================\n        #   Compute indices_per_group for groups depending on the type of groups\n        # =============================================================================\n\n        indices_per_group = GroupUtils.compute_indices_per_group(vertices_numpy.__len__(), pixels.get_groups())\n        group_count = GroupUtils.get_group_count(vertices_numpy.__len__(), pixels.get_groups())\n\n        # =============================================================================\n        # Create the artists if needed\n        # =============================================================================\n\n        artist_uuid_prefix = f\"{viewport.get_uuid()}_{pixels.get_uuid()}\"\n\n        # update stored group count\n        old_group_count = None\n        if artist_uuid_prefix in renderer._group_count:\n            old_group_count = renderer._group_count[artist_uuid_prefix]\n        renderer._group_count[artist_uuid_prefix] = group_count\n\n        # If the group count has changed, destroy old artists\n        if old_group_count is not None and old_group_count != group_count:\n            RendererPixels.destroy_artists(renderer, viewport, pixels, old_group_count)\n\n        # Create artists if they do not exist\n        artist_uuid_sample = f\"{artist_uuid_prefix}_group_0\"\n        if artist_uuid_sample not in renderer._artists:\n            RendererPixels.create_artists(renderer, viewport, pixels, group_count)\n\n        # =============================================================================\n        # Update matplotlib for each group\n        # =============================================================================\n\n        changed_artists: list[matplotlib.artist.Artist] = []\n        for group_index in range(group_count):\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n\n            # =============================================================================\n            # Get existing artists\n            # =============================================================================\n\n            mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[group_uuid])\n            mpl_path_collection.set_visible(True)\n            changed_artists.append(mpl_path_collection)\n\n            # =============================================================================\n            # Update artists\n            # =============================================================================\n\n            mpl_path_collection.set_offsets(offsets=vertices_2d[indices_per_group[group_index]])\n            mpl_path_collection.set_facecolor(typing.cast(list, colors_numpy[group_index]))\n\n        # Return the list of artists created/updated\n        return changed_artists\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    @staticmethod\n    def create_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None:\n        \"\"\"Create the artists associated with the given visual and group count.\n\n        Args:\n            renderer: The Matplotlib renderer.\n            viewport: The viewport for which to create the artists.\n            visual: The visual for which to create the artists.\n            group_count: The number of groups in the visual.\n        \"\"\"\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        artist_uuid_prefix = f\"{viewport.get_uuid()}_{visual.get_uuid()}\"\n        # compute 1 pixel size in points squared for matplotlib sizing\n        assert axes.figure.get_dpi() is not None, \"Canvas DPI must be set for proper pixel sizing\"\n        size_pt = UnitUtils.pixel_to_point(1.0, axes.figure.get_dpi())\n        size_squared_pt = size_pt * size_pt\n\n        for group_index in range(group_count):\n            mpl_path_collection = axes.scatter([], [], s=size_squared_pt, marker=\"o\")\n            mpl_path_collection.set_antialiased(True)\n            mpl_path_collection.set_linewidth(0)\n            mpl_path_collection.set_visible(False)\n            # hide until properly positioned and sized\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n            renderer._artists[group_uuid] = mpl_path_collection\n            axes.add_artist(mpl_path_collection)\n\n    @staticmethod\n    def destroy_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None:\n        \"\"\"Destroy the artists associated with the given visual and group count.\n\n        Trigger a bug in matplotlib where artists are not properly removed from the axes.\n        \"\"\"\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        artist_uuid_prefix = f\"{viewport.get_uuid()}_{visual.get_uuid()}\"\n        for group_index in range(group_count):\n            group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n            mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[group_uuid])\n            del renderer._artists[group_uuid]\n            mpl_path_collection.remove()\n\n            # axes.collections.remove(mpl_path_collection)\n            # axes.collections.remove(axes.collections.index(mpl_path_collection))\n\n            ax = axes\n            artist = mpl_path_collection\n\n            print(\"Artist:\", artist)\n            print(\"In ax.artists?\", artist in ax.artists)\n            print(\"In ax.patches?\", artist in ax.patches)\n            print(\"In ax.lines?\", artist in ax.lines)\n            print(\"In ax.collections?\", artist in ax.collections)\n            print(\"In ax.texts?\", artist in ax.texts)\n            print(\"Figure art?\", artist in getattr(ax.figure, \"artists\", []))\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels.RendererPixels.create_artists","title":"<code>create_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Create the artists associated with the given visual and group count.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.MatplotlibRenderer</code> <p>The Matplotlib renderer.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The viewport for which to create the artists.</p> required <code>visual</code> <code>gsp.types.visual_base.VisualBase</code> <p>The visual for which to create the artists.</p> required <code>group_count</code> <code>int</code> <p>The number of groups in the visual.</p> required Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_pixels.py</code> <pre><code>@staticmethod\ndef create_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None:\n    \"\"\"Create the artists associated with the given visual and group count.\n\n    Args:\n        renderer: The Matplotlib renderer.\n        viewport: The viewport for which to create the artists.\n        visual: The visual for which to create the artists.\n        group_count: The number of groups in the visual.\n    \"\"\"\n    axes = renderer.get_mpl_axes_for_viewport(viewport)\n    artist_uuid_prefix = f\"{viewport.get_uuid()}_{visual.get_uuid()}\"\n    # compute 1 pixel size in points squared for matplotlib sizing\n    assert axes.figure.get_dpi() is not None, \"Canvas DPI must be set for proper pixel sizing\"\n    size_pt = UnitUtils.pixel_to_point(1.0, axes.figure.get_dpi())\n    size_squared_pt = size_pt * size_pt\n\n    for group_index in range(group_count):\n        mpl_path_collection = axes.scatter([], [], s=size_squared_pt, marker=\"o\")\n        mpl_path_collection.set_antialiased(True)\n        mpl_path_collection.set_linewidth(0)\n        mpl_path_collection.set_visible(False)\n        # hide until properly positioned and sized\n        group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n        renderer._artists[group_uuid] = mpl_path_collection\n        axes.add_artist(mpl_path_collection)\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels.RendererPixels.destroy_artists","title":"<code>destroy_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Destroy the artists associated with the given visual and group count.</p> <p>Trigger a bug in matplotlib where artists are not properly removed from the axes.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_pixels.py</code> <pre><code>@staticmethod\ndef destroy_artists(renderer: MatplotlibRenderer, viewport: Viewport, visual: VisualBase, group_count: int) -&gt; None:\n    \"\"\"Destroy the artists associated with the given visual and group count.\n\n    Trigger a bug in matplotlib where artists are not properly removed from the axes.\n    \"\"\"\n    axes = renderer.get_mpl_axes_for_viewport(viewport)\n    artist_uuid_prefix = f\"{viewport.get_uuid()}_{visual.get_uuid()}\"\n    for group_index in range(group_count):\n        group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n        mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[group_uuid])\n        del renderer._artists[group_uuid]\n        mpl_path_collection.remove()\n\n        # axes.collections.remove(mpl_path_collection)\n        # axes.collections.remove(axes.collections.index(mpl_path_collection))\n\n        ax = axes\n        artist = mpl_path_collection\n\n        print(\"Artist:\", artist)\n        print(\"In ax.artists?\", artist in ax.artists)\n        print(\"In ax.patches?\", artist in ax.patches)\n        print(\"In ax.lines?\", artist in ax.lines)\n        print(\"In ax.collections?\", artist in ax.collections)\n        print(\"In ax.texts?\", artist in ax.texts)\n        print(\"Figure art?\", artist in getattr(ax.figure, \"artists\", []))\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_pixels.RendererPixels.render","title":"<code>render(renderer: MatplotlibRenderer, viewport: Viewport, pixels: Pixels, model_matrix: TransBuf, camera: Camera) -&gt; list[matplotlib.artist.Artist]</code>  <code>staticmethod</code>","text":"<p>Render Pixels visual using Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.MatplotlibRenderer</code> <p>The MatplotlibRenderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The Viewport in which to render.</p> required <code>pixels</code> <code>gsp.visuals.pixels.Pixels</code> <p>The Pixels visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model transformation matrix as a TransBuf.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The Camera providing view and projection matrices.      </p> required <p>Returns:</p> Type Description <code>list[matplotlib.artist.Artist]</code> <p>list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_pixels.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: MatplotlibRenderer,\n    viewport: Viewport,\n    pixels: Pixels,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; list[matplotlib.artist.Artist]:\n    \"\"\"Render Pixels visual using Matplotlib.\n\n    Args:\n        renderer: The MatplotlibRenderer instance.\n        viewport: The Viewport in which to render.\n        pixels: The Pixels visual to render.\n        model_matrix: The model transformation matrix as a TransBuf.\n        camera: The Camera providing view and projection matrices.      \n\n    Returns:\n        list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n    \"\"\"\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(pixels.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 2D - shape (N, 2)\n    vertices_2d = vertices_3d_transformed[:, :2]\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    # Convert all attributes to buffer\n    color_buffer = TransBufUtils.to_buffer(pixels.get_colors())\n\n    # Convert buffers to numpy arrays\n    colors_numpy = Bufferx.to_numpy(color_buffer) / 255.0  # normalize to [0, 1] range\n\n    # Sanity check - check visual attributes\n    Pixels.sanity_check_attribute_buffers(vertices_buffer, color_buffer, pixels.get_groups())\n\n    # =============================================================================\n    #   Compute indices_per_group for groups depending on the type of groups\n    # =============================================================================\n\n    indices_per_group = GroupUtils.compute_indices_per_group(vertices_numpy.__len__(), pixels.get_groups())\n    group_count = GroupUtils.get_group_count(vertices_numpy.__len__(), pixels.get_groups())\n\n    # =============================================================================\n    # Create the artists if needed\n    # =============================================================================\n\n    artist_uuid_prefix = f\"{viewport.get_uuid()}_{pixels.get_uuid()}\"\n\n    # update stored group count\n    old_group_count = None\n    if artist_uuid_prefix in renderer._group_count:\n        old_group_count = renderer._group_count[artist_uuid_prefix]\n    renderer._group_count[artist_uuid_prefix] = group_count\n\n    # If the group count has changed, destroy old artists\n    if old_group_count is not None and old_group_count != group_count:\n        RendererPixels.destroy_artists(renderer, viewport, pixels, old_group_count)\n\n    # Create artists if they do not exist\n    artist_uuid_sample = f\"{artist_uuid_prefix}_group_0\"\n    if artist_uuid_sample not in renderer._artists:\n        RendererPixels.create_artists(renderer, viewport, pixels, group_count)\n\n    # =============================================================================\n    # Update matplotlib for each group\n    # =============================================================================\n\n    changed_artists: list[matplotlib.artist.Artist] = []\n    for group_index in range(group_count):\n        group_uuid = f\"{artist_uuid_prefix}_group_{group_index}\"\n\n        # =============================================================================\n        # Get existing artists\n        # =============================================================================\n\n        mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[group_uuid])\n        mpl_path_collection.set_visible(True)\n        changed_artists.append(mpl_path_collection)\n\n        # =============================================================================\n        # Update artists\n        # =============================================================================\n\n        mpl_path_collection.set_offsets(offsets=vertices_2d[indices_per_group[group_index]])\n        mpl_path_collection.set_facecolor(typing.cast(list, colors_numpy[group_index]))\n\n    # Return the list of artists created/updated\n    return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#points-renderer","title":"Points Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_points","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_points</code>","text":"<p>Renderer for Points using Matplotlib.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_points.RendererPoints","title":"<code>RendererPoints</code>","text":"<p>Renderer for Points using Matplotlib.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_points.py</code> <pre><code>class RendererPoints:\n    \"\"\"Renderer for Points using Matplotlib.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: MatplotlibRenderer,\n        viewport: Viewport,\n        points: Points,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Render Points visual using Matplotlib.\n\n        Args:\n            renderer: The MatplotlibRenderer instance.\n            viewport: The Viewport in which to render.\n            points: The Points visual to render.\n            model_matrix: The model transformation matrix as a TransBuf.\n            camera: The Camera providing view and projection matrices.\n\n        Returns:\n            list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n        \"\"\"\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(points.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 2D - shape (N, 2)\n        vertices_2d = vertices_3d_transformed[:, :2]\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        # Convert all attributes to buffer\n        sizes_buffer = TransBufUtils.to_buffer(points.get_sizes())\n        face_colors_buffer = TransBufUtils.to_buffer(points.get_face_colors())\n        edge_colors_buffer = TransBufUtils.to_buffer(points.get_edge_colors())\n        edge_widths_buffer = TransBufUtils.to_buffer(points.get_edge_widths())\n\n        # Convert buffers to numpy arrays\n        sizes_numpy = Bufferx.to_numpy(sizes_buffer).flatten()\n        face_colors_numpy = Bufferx.to_numpy(face_colors_buffer) / 255.0  # normalize to [0, 1] range\n        edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer) / 255.0  # normalize to [0, 1] range\n        edge_widths_numpy = Bufferx.to_numpy(edge_widths_buffer).flatten()\n\n        # =============================================================================\n        # Create the artists if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{points.get_uuid()}\"\n        if artist_uuid not in renderer._artists:\n            axes = renderer.get_mpl_axes_for_viewport(viewport)\n            mpl_path_collection = axes.scatter([], [])\n            mpl_path_collection.set_visible(False)\n            # hide until properly positioned and sized\n            renderer._artists[artist_uuid] = mpl_path_collection\n            axes.add_artist(mpl_path_collection)\n\n        # =============================================================================\n        # Get existing artists\n        # =============================================================================\n\n        mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[artist_uuid])\n        mpl_path_collection.set_visible(True)\n\n        # =============================================================================\n        # Update artists\n        # =============================================================================\n\n        mpl_path_collection.set_offsets(offsets=vertices_2d)\n        mpl_path_collection.set_sizes(typing.cast(list, sizes_numpy))\n        mpl_path_collection.set_facecolor(typing.cast(list, face_colors_numpy))\n        mpl_path_collection.set_edgecolor(typing.cast(list, edge_colors_numpy))\n        mpl_path_collection.set_linewidth(typing.cast(list, edge_widths_numpy))\n\n        # Return the list of artists created/updated\n        changed_artists: list[matplotlib.artist.Artist] = []\n        changed_artists.append(mpl_path_collection)\n        return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_points.RendererPoints.render","title":"<code>render(renderer: MatplotlibRenderer, viewport: Viewport, points: Points, model_matrix: TransBuf, camera: Camera) -&gt; list[matplotlib.artist.Artist]</code>  <code>staticmethod</code>","text":"<p>Render Points visual using Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer</code> <p>The MatplotlibRenderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The Viewport in which to render.</p> required <code>points</code> <code>gsp.visuals.points.Points</code> <p>The Points visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model transformation matrix as a TransBuf.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The Camera providing view and projection matrices.</p> required <p>Returns:</p> Type Description <code>list[matplotlib.artist.Artist]</code> <p>list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_points.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: MatplotlibRenderer,\n    viewport: Viewport,\n    points: Points,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; list[matplotlib.artist.Artist]:\n    \"\"\"Render Points visual using Matplotlib.\n\n    Args:\n        renderer: The MatplotlibRenderer instance.\n        viewport: The Viewport in which to render.\n        points: The Points visual to render.\n        model_matrix: The model transformation matrix as a TransBuf.\n        camera: The Camera providing view and projection matrices.\n\n    Returns:\n        list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n    \"\"\"\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(points.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 2D - shape (N, 2)\n    vertices_2d = vertices_3d_transformed[:, :2]\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    # Convert all attributes to buffer\n    sizes_buffer = TransBufUtils.to_buffer(points.get_sizes())\n    face_colors_buffer = TransBufUtils.to_buffer(points.get_face_colors())\n    edge_colors_buffer = TransBufUtils.to_buffer(points.get_edge_colors())\n    edge_widths_buffer = TransBufUtils.to_buffer(points.get_edge_widths())\n\n    # Convert buffers to numpy arrays\n    sizes_numpy = Bufferx.to_numpy(sizes_buffer).flatten()\n    face_colors_numpy = Bufferx.to_numpy(face_colors_buffer) / 255.0  # normalize to [0, 1] range\n    edge_colors_numpy = Bufferx.to_numpy(edge_colors_buffer) / 255.0  # normalize to [0, 1] range\n    edge_widths_numpy = Bufferx.to_numpy(edge_widths_buffer).flatten()\n\n    # =============================================================================\n    # Create the artists if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{points.get_uuid()}\"\n    if artist_uuid not in renderer._artists:\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        mpl_path_collection = axes.scatter([], [])\n        mpl_path_collection.set_visible(False)\n        # hide until properly positioned and sized\n        renderer._artists[artist_uuid] = mpl_path_collection\n        axes.add_artist(mpl_path_collection)\n\n    # =============================================================================\n    # Get existing artists\n    # =============================================================================\n\n    mpl_path_collection = typing.cast(matplotlib.collections.PathCollection, renderer._artists[artist_uuid])\n    mpl_path_collection.set_visible(True)\n\n    # =============================================================================\n    # Update artists\n    # =============================================================================\n\n    mpl_path_collection.set_offsets(offsets=vertices_2d)\n    mpl_path_collection.set_sizes(typing.cast(list, sizes_numpy))\n    mpl_path_collection.set_facecolor(typing.cast(list, face_colors_numpy))\n    mpl_path_collection.set_edgecolor(typing.cast(list, edge_colors_numpy))\n    mpl_path_collection.set_linewidth(typing.cast(list, edge_widths_numpy))\n\n    # Return the list of artists created/updated\n    changed_artists: list[matplotlib.artist.Artist] = []\n    changed_artists.append(mpl_path_collection)\n    return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#segments-renderer","title":"Segments Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_segments","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_segments</code>","text":"<p>Renderer for Segments using Matplotlib.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_segments.RendererSegments","title":"<code>RendererSegments</code>","text":"<p>Renderer for Segments using Matplotlib.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_segments.py</code> <pre><code>class RendererSegments:\n    \"\"\"Renderer for Segments using Matplotlib.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: MatplotlibRenderer,\n        viewport: Viewport,\n        segments: Segments,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Render Segments visual using Matplotlib.\n\n        Args:\n            renderer: The MatplotlibRenderer instance.\n            viewport: The Viewport in which to render.\n            segments: The Segments visual to render.\n            model_matrix: The model transformation matrix as a TransBuf.\n            camera: The Camera providing view and projection matrices.\n\n        Returns:\n            list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n        \"\"\"\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(segments.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 2D - shape (N, 2)\n        vertices_2d = vertices_3d_transformed[:, :2]\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        # Convert all attributes to buffer\n        colors_buffer = TransBufUtils.to_buffer(segments.get_colors())\n        line_widths_buffer = TransBufUtils.to_buffer(segments.get_line_widths())\n\n        # Convert buffers to numpy arrays\n        positions_numpy = vertices_2d.reshape(-1, 2, 2)\n        colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n        line_widths_numpy = Bufferx.to_numpy(line_widths_buffer)\n        line_widths_numpy = line_widths_numpy.reshape(-1)\n\n        # =============================================================================\n        # Create the artists if needed\n        # =============================================================================\n\n        artist_uuid = f\"{viewport.get_uuid()}_{segments.get_uuid()}\"\n        if artist_uuid not in renderer._artists:\n            mpl_line_collection = matplotlib.collections.LineCollection([])\n            mpl_line_collection.set_visible(False)\n            # hide until properly positioned and sized\n            renderer._artists[artist_uuid] = mpl_line_collection\n            axes = renderer.get_mpl_axes_for_viewport(viewport)\n            axes.add_artist(mpl_line_collection)\n\n        # =============================================================================\n        # Get existing artists\n        # =============================================================================\n\n        mpl_line_collection = typing.cast(matplotlib.collections.LineCollection, renderer._artists[artist_uuid])\n        mpl_line_collection.set_visible(True)\n\n        # =============================================================================\n        # Update artists\n        # =============================================================================\n\n        mpl_line_collection.set_paths(typing.cast(list, positions_numpy))\n        mpl_line_collection.set_color(typing.cast(list, colors_numpy))\n        mpl_line_collection.set_linewidth(typing.cast(list, line_widths_numpy))\n        mpl_line_collection.set_capstyle(ConverterUtils.cap_style_gsp_to_mpl(segments.get_cap_style()))\n\n        # Return the list of artists created/updated\n        changed_artists: list[matplotlib.artist.Artist] = []\n        changed_artists.append(mpl_line_collection)\n        return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_segments.RendererSegments.render","title":"<code>render(renderer: MatplotlibRenderer, viewport: Viewport, segments: Segments, model_matrix: TransBuf, camera: Camera) -&gt; list[matplotlib.artist.Artist]</code>  <code>staticmethod</code>","text":"<p>Render Segments visual using Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer</code> <p>The MatplotlibRenderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The Viewport in which to render.</p> required <code>segments</code> <code>gsp.visuals.segments.Segments</code> <p>The Segments visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model transformation matrix as a TransBuf.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The Camera providing view and projection matrices.</p> required <p>Returns:</p> Type Description <code>list[matplotlib.artist.Artist]</code> <p>list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_segments.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: MatplotlibRenderer,\n    viewport: Viewport,\n    segments: Segments,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; list[matplotlib.artist.Artist]:\n    \"\"\"Render Segments visual using Matplotlib.\n\n    Args:\n        renderer: The MatplotlibRenderer instance.\n        viewport: The Viewport in which to render.\n        segments: The Segments visual to render.\n        model_matrix: The model transformation matrix as a TransBuf.\n        camera: The Camera providing view and projection matrices.\n\n    Returns:\n        list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n    \"\"\"\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(segments.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 2D - shape (N, 2)\n    vertices_2d = vertices_3d_transformed[:, :2]\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    # Convert all attributes to buffer\n    colors_buffer = TransBufUtils.to_buffer(segments.get_colors())\n    line_widths_buffer = TransBufUtils.to_buffer(segments.get_line_widths())\n\n    # Convert buffers to numpy arrays\n    positions_numpy = vertices_2d.reshape(-1, 2, 2)\n    colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n    line_widths_numpy = Bufferx.to_numpy(line_widths_buffer)\n    line_widths_numpy = line_widths_numpy.reshape(-1)\n\n    # =============================================================================\n    # Create the artists if needed\n    # =============================================================================\n\n    artist_uuid = f\"{viewport.get_uuid()}_{segments.get_uuid()}\"\n    if artist_uuid not in renderer._artists:\n        mpl_line_collection = matplotlib.collections.LineCollection([])\n        mpl_line_collection.set_visible(False)\n        # hide until properly positioned and sized\n        renderer._artists[artist_uuid] = mpl_line_collection\n        axes = renderer.get_mpl_axes_for_viewport(viewport)\n        axes.add_artist(mpl_line_collection)\n\n    # =============================================================================\n    # Get existing artists\n    # =============================================================================\n\n    mpl_line_collection = typing.cast(matplotlib.collections.LineCollection, renderer._artists[artist_uuid])\n    mpl_line_collection.set_visible(True)\n\n    # =============================================================================\n    # Update artists\n    # =============================================================================\n\n    mpl_line_collection.set_paths(typing.cast(list, positions_numpy))\n    mpl_line_collection.set_color(typing.cast(list, colors_numpy))\n    mpl_line_collection.set_linewidth(typing.cast(list, line_widths_numpy))\n    mpl_line_collection.set_capstyle(ConverterUtils.cap_style_gsp_to_mpl(segments.get_cap_style()))\n\n    # Return the list of artists created/updated\n    changed_artists: list[matplotlib.artist.Artist] = []\n    changed_artists.append(mpl_line_collection)\n    return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#texts-renderer","title":"Texts Renderer","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_texts","title":"<code>gsp_matplotlib.renderer.matplotlib_renderer_texts</code>","text":"<p>Renderer for Texts using Matplotlib.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_texts.RendererTexts","title":"<code>RendererTexts</code>","text":"<p>Renderer for Texts using Matplotlib.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_texts.py</code> <pre><code>class RendererTexts:\n    \"\"\"Renderer for Texts using Matplotlib.\"\"\"\n\n    @staticmethod\n    def render(\n        renderer: MatplotlibRenderer,\n        viewport: Viewport,\n        texts: Texts,\n        model_matrix: TransBuf,\n        camera: Camera,\n    ) -&gt; list[matplotlib.artist.Artist]:\n        \"\"\"Render Texts visual using Matplotlib.\n\n        Args:\n            renderer: The MatplotlibRenderer instance.\n            viewport: The Viewport in which to render.\n            texts: The Texts visual to render.\n            model_matrix: The model transformation matrix as a TransBuf.\n            camera: The Camera providing view and projection matrices.\n\n        Returns:\n            list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n        \"\"\"\n        # =============================================================================\n        # Transform vertices with MVP matrix\n        # =============================================================================\n\n        vertices_buffer = TransBufUtils.to_buffer(texts.get_positions())\n        model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n        view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n        projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n        # convert all necessary buffers to numpy arrays\n        vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n        model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n        view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n        projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n        # Apply Model-View-Projection transformation to the vertices\n        vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n        # Convert 3D vertices to 2D - shape (N, 2)\n        vertices_2d = vertices_3d_transformed[:, :2]\n\n        # =============================================================================\n        # Convert all attributes to numpy arrays\n        # =============================================================================\n\n        # Convert all attributes to buffer\n        colors_buffer = TransBufUtils.to_buffer(texts.get_colors())\n        font_sizes_buffer = TransBufUtils.to_buffer(texts.get_font_sizes())\n        anchors_buffer = TransBufUtils.to_buffer(texts.get_anchors())\n        angles_buffer = TransBufUtils.to_buffer(texts.get_angles())\n\n        # Convert buffers to numpy arrays\n        font_sizes_numpy = Bufferx.to_numpy(font_sizes_buffer).flatten()\n        colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n        anchors_numpy = Bufferx.to_numpy(anchors_buffer)\n        angles_numpy = Bufferx.to_numpy(angles_buffer).flatten()\n\n        # =============================================================================\n        # Create the artists if needed\n        # =============================================================================\n\n        artist_uuid_sample = f\"{viewport.get_uuid()}_{texts.get_uuid()}_0\"\n        if artist_uuid_sample not in renderer._artists:\n            mpl_axes = renderer.get_mpl_axes_for_viewport(viewport)\n            for text_index in range(len(texts.get_strings())):\n                artist_uuid = f\"{viewport.get_uuid()}_{texts.get_uuid()}_{text_index}\"\n                mpl_text = matplotlib.text.Text()\n                mpl_text.set_visible(False)\n                # hide until properly positioned and sized\n                renderer._artists[artist_uuid] = mpl_text\n                mpl_axes.add_artist(mpl_text)\n\n        # =============================================================================\n        # Get existing artists\n        # =============================================================================\n\n        changed_artists: list[matplotlib.artist.Artist] = []\n        for text_index in range(len(texts.get_strings())):\n            artist_uuid = f\"{viewport.get_uuid()}_{texts.get_uuid()}_{text_index}\"\n            mpl_text = typing.cast(matplotlib.text.Text, renderer._artists[artist_uuid])\n            mpl_text.set_visible(True)\n\n            # =============================================================================\n            # Update artists\n            # =============================================================================\n\n            mpl_text.set_x(vertices_2d[text_index, 0])\n            mpl_text.set_y(vertices_2d[text_index, 1])\n            mpl_text.set_text(texts.get_strings()[text_index])\n            mpl_text.set_rotation(angles_numpy[text_index] / np.pi * 180.0)  # convert rad to deg\n            print(f\"angles_numpy[{text_index}]: {angles_numpy[text_index]}\")\n\n            ha_label = \"center\" if anchors_numpy[text_index, 0] == 0.0 else \"right\" if anchors_numpy[text_index, 0] == 1.0 else \"left\"\n            mpl_text.set_horizontalalignment(ha_label)\n            va_label = \"center\" if anchors_numpy[text_index, 1] == 0.0 else \"top\" if anchors_numpy[text_index, 1] == 1.0 else \"bottom\"\n            mpl_text.set_verticalalignment(va_label)\n\n            mpl_text.set_fontfamily(texts.get_font_name())\n            mpl_text.set_fontsize(font_sizes_numpy[text_index])\n            mpl_text.set_color(typing.cast(tuple, colors_numpy[text_index]))\n\n            # Return the list of artists created/updated\n            changed_artists.append(mpl_text)\n\n        return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.renderer.matplotlib_renderer_texts.RendererTexts.render","title":"<code>render(renderer: MatplotlibRenderer, viewport: Viewport, texts: Texts, model_matrix: TransBuf, camera: Camera) -&gt; list[matplotlib.artist.Artist]</code>  <code>staticmethod</code>","text":"<p>Render Texts visual using Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>gsp_matplotlib.renderer.matplotlib_renderer.MatplotlibRenderer</code> <p>The MatplotlibRenderer instance.</p> required <code>viewport</code> <code>gsp.core.viewport.Viewport</code> <p>The Viewport in which to render.</p> required <code>texts</code> <code>gsp.visuals.texts.Texts</code> <p>The Texts visual to render.</p> required <code>model_matrix</code> <code>gsp.types.transbuf.TransBuf</code> <p>The model transformation matrix as a TransBuf.</p> required <code>camera</code> <code>gsp.core.camera.Camera</code> <p>The Camera providing view and projection matrices.</p> required <p>Returns:</p> Type Description <code>list[matplotlib.artist.Artist]</code> <p>list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.</p> Source code in <code>src/gsp_matplotlib/renderer/matplotlib_renderer_texts.py</code> <pre><code>@staticmethod\ndef render(\n    renderer: MatplotlibRenderer,\n    viewport: Viewport,\n    texts: Texts,\n    model_matrix: TransBuf,\n    camera: Camera,\n) -&gt; list[matplotlib.artist.Artist]:\n    \"\"\"Render Texts visual using Matplotlib.\n\n    Args:\n        renderer: The MatplotlibRenderer instance.\n        viewport: The Viewport in which to render.\n        texts: The Texts visual to render.\n        model_matrix: The model transformation matrix as a TransBuf.\n        camera: The Camera providing view and projection matrices.\n\n    Returns:\n        list[matplotlib.artist.Artist]: List of Matplotlib artists created/updated.\n    \"\"\"\n    # =============================================================================\n    # Transform vertices with MVP matrix\n    # =============================================================================\n\n    vertices_buffer = TransBufUtils.to_buffer(texts.get_positions())\n    model_matrix_buffer = TransBufUtils.to_buffer(model_matrix)\n    view_matrix_buffer = TransBufUtils.to_buffer(camera.get_view_matrix())\n    projection_matrix_buffer = TransBufUtils.to_buffer(camera.get_projection_matrix())\n\n    # convert all necessary buffers to numpy arrays\n    vertices_numpy = Bufferx.to_numpy(vertices_buffer)\n    model_matrix_numpy = Bufferx.to_numpy(model_matrix_buffer).squeeze()\n    view_matrix_numpy = Bufferx.to_numpy(view_matrix_buffer).squeeze()\n    projection_matrix_numpy = Bufferx.to_numpy(projection_matrix_buffer).squeeze()\n\n    # Apply Model-View-Projection transformation to the vertices\n    vertices_3d_transformed = MathUtils.apply_mvp_to_vertices(vertices_numpy, model_matrix_numpy, view_matrix_numpy, projection_matrix_numpy)\n\n    # Convert 3D vertices to 2D - shape (N, 2)\n    vertices_2d = vertices_3d_transformed[:, :2]\n\n    # =============================================================================\n    # Convert all attributes to numpy arrays\n    # =============================================================================\n\n    # Convert all attributes to buffer\n    colors_buffer = TransBufUtils.to_buffer(texts.get_colors())\n    font_sizes_buffer = TransBufUtils.to_buffer(texts.get_font_sizes())\n    anchors_buffer = TransBufUtils.to_buffer(texts.get_anchors())\n    angles_buffer = TransBufUtils.to_buffer(texts.get_angles())\n\n    # Convert buffers to numpy arrays\n    font_sizes_numpy = Bufferx.to_numpy(font_sizes_buffer).flatten()\n    colors_numpy = Bufferx.to_numpy(colors_buffer) / 255.0  # normalize to [0, 1] range\n    anchors_numpy = Bufferx.to_numpy(anchors_buffer)\n    angles_numpy = Bufferx.to_numpy(angles_buffer).flatten()\n\n    # =============================================================================\n    # Create the artists if needed\n    # =============================================================================\n\n    artist_uuid_sample = f\"{viewport.get_uuid()}_{texts.get_uuid()}_0\"\n    if artist_uuid_sample not in renderer._artists:\n        mpl_axes = renderer.get_mpl_axes_for_viewport(viewport)\n        for text_index in range(len(texts.get_strings())):\n            artist_uuid = f\"{viewport.get_uuid()}_{texts.get_uuid()}_{text_index}\"\n            mpl_text = matplotlib.text.Text()\n            mpl_text.set_visible(False)\n            # hide until properly positioned and sized\n            renderer._artists[artist_uuid] = mpl_text\n            mpl_axes.add_artist(mpl_text)\n\n    # =============================================================================\n    # Get existing artists\n    # =============================================================================\n\n    changed_artists: list[matplotlib.artist.Artist] = []\n    for text_index in range(len(texts.get_strings())):\n        artist_uuid = f\"{viewport.get_uuid()}_{texts.get_uuid()}_{text_index}\"\n        mpl_text = typing.cast(matplotlib.text.Text, renderer._artists[artist_uuid])\n        mpl_text.set_visible(True)\n\n        # =============================================================================\n        # Update artists\n        # =============================================================================\n\n        mpl_text.set_x(vertices_2d[text_index, 0])\n        mpl_text.set_y(vertices_2d[text_index, 1])\n        mpl_text.set_text(texts.get_strings()[text_index])\n        mpl_text.set_rotation(angles_numpy[text_index] / np.pi * 180.0)  # convert rad to deg\n        print(f\"angles_numpy[{text_index}]: {angles_numpy[text_index]}\")\n\n        ha_label = \"center\" if anchors_numpy[text_index, 0] == 0.0 else \"right\" if anchors_numpy[text_index, 0] == 1.0 else \"left\"\n        mpl_text.set_horizontalalignment(ha_label)\n        va_label = \"center\" if anchors_numpy[text_index, 1] == 0.0 else \"top\" if anchors_numpy[text_index, 1] == 1.0 else \"bottom\"\n        mpl_text.set_verticalalignment(va_label)\n\n        mpl_text.set_fontfamily(texts.get_font_name())\n        mpl_text.set_fontsize(font_sizes_numpy[text_index])\n        mpl_text.set_color(typing.cast(tuple, colors_numpy[text_index]))\n\n        # Return the list of artists created/updated\n        changed_artists.append(mpl_text)\n\n    return changed_artists\n</code></pre>"},{"location":"api/gsp_matplotlib/#extra-module","title":"Extra Module","text":"<p>The extra module provides additional utilities and extensions for Matplotlib rendering.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra","title":"<code>gsp_matplotlib.extra</code>","text":"<p>GSP Matplotlib extra utilities package initialization.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.Bufferx","title":"<code>Bufferx</code>","text":"<p>Utility class for Buffer extended functionality using numpy.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>class Bufferx:\n    \"\"\"Utility class for Buffer extended functionality using numpy.\"\"\"\n\n    # =============================================================================\n    # Matrix functions\n    # =============================================================================\n\n    @staticmethod\n    def mat4_identity() -&gt; Buffer:\n        \"\"\"Create a Buffer containing a 4x4 identity matrix.\"\"\"\n        mat4_numpy = np.asarray([np.identity(4, dtype=np.float32)])\n        buffer = Bufferx.from_numpy(mat4_numpy, BufferType.mat4)\n        return buffer\n\n    # =============================================================================\n    # .to_numpy/.from_numpy\n    # =============================================================================\n    @staticmethod\n    def to_numpy(buffer: Buffer) -&gt; np.ndarray:\n        \"\"\"Convert a Buffer to a numpy array.\"\"\"\n        if buffer.get_type() == BufferType.float32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.int8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.int8).reshape((count, 1))\n        elif buffer.get_type() == BufferType.int32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.int32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.uint8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 1))\n        elif buffer.get_type() == BufferType.uint32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.vec2:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 2))\n        elif buffer.get_type() == BufferType.vec3:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 3))\n        elif buffer.get_type() == BufferType.vec4:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4))\n        elif buffer.get_type() == BufferType.mat4:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4, 4))\n        elif buffer.get_type() == BufferType.rgba8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 4))\n        else:\n            raise NotImplementedError(f\"unable to convert buffer {buffer} to numpy array\")\n\n    @staticmethod\n    def from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer:\n        \"\"\"Create a Buffer from a numpy array.\"\"\"\n        if bufferType == BufferType.float32:\n            # sanity check\n            assert array_numpy.dtype == np.float32, \"Numpy array must be of dtype float32\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.uint32:\n            # sanity check\n            assert array_numpy.dtype == np.uint32, \"Numpy array must be of dtype uint32\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.vec2:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 2, \"Numpy array must be of shape (2,)\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.vec3:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 3, \"Numpy array must be of shape (3,)\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.mat4:\n            # sanity check\n            assert array_numpy.shape.__len__() == 3 and array_numpy.shape[1] == 4 and array_numpy.shape[2] == 4, \"Numpy array must be of shape (4, 4)\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, 1)\n            return buffer\n        elif bufferType == BufferType.rgba8:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 4, \"Numpy array must be of shape (4,)\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.uint8).tobytes()), 0, count)\n            return buffer\n        else:\n            raise NotImplementedError(f\"unable to create a {bufferType} buffer from numpy array of shape {array_numpy.shape} and dtype {array_numpy.dtype}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.Bufferx.mat4_identity","title":"<code>mat4_identity() -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Create a Buffer containing a 4x4 identity matrix.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef mat4_identity() -&gt; Buffer:\n    \"\"\"Create a Buffer containing a 4x4 identity matrix.\"\"\"\n    mat4_numpy = np.asarray([np.identity(4, dtype=np.float32)])\n    buffer = Bufferx.from_numpy(mat4_numpy, BufferType.mat4)\n    return buffer\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.Bufferx.to_numpy","title":"<code>to_numpy(buffer: Buffer) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Convert a Buffer to a numpy array.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef to_numpy(buffer: Buffer) -&gt; np.ndarray:\n    \"\"\"Convert a Buffer to a numpy array.\"\"\"\n    if buffer.get_type() == BufferType.float32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.int8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.int8).reshape((count, 1))\n    elif buffer.get_type() == BufferType.int32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.int32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.uint8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 1))\n    elif buffer.get_type() == BufferType.uint32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.vec2:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 2))\n    elif buffer.get_type() == BufferType.vec3:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 3))\n    elif buffer.get_type() == BufferType.vec4:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4))\n    elif buffer.get_type() == BufferType.mat4:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4, 4))\n    elif buffer.get_type() == BufferType.rgba8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 4))\n    else:\n        raise NotImplementedError(f\"unable to convert buffer {buffer} to numpy array\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.Bufferx.from_numpy","title":"<code>from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Create a Buffer from a numpy array.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer:\n    \"\"\"Create a Buffer from a numpy array.\"\"\"\n    if bufferType == BufferType.float32:\n        # sanity check\n        assert array_numpy.dtype == np.float32, \"Numpy array must be of dtype float32\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.uint32:\n        # sanity check\n        assert array_numpy.dtype == np.uint32, \"Numpy array must be of dtype uint32\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.vec2:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 2, \"Numpy array must be of shape (2,)\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.vec3:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 3, \"Numpy array must be of shape (3,)\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.mat4:\n        # sanity check\n        assert array_numpy.shape.__len__() == 3 and array_numpy.shape[1] == 4 and array_numpy.shape[2] == 4, \"Numpy array must be of shape (4, 4)\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, 1)\n        return buffer\n    elif bufferType == BufferType.rgba8:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 4, \"Numpy array must be of shape (4,)\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.uint8).tobytes()), 0, count)\n        return buffer\n    else:\n        raise NotImplementedError(f\"unable to create a {bufferType} buffer from numpy array of shape {array_numpy.shape} and dtype {array_numpy.dtype}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#bufferx","title":"Bufferx","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx","title":"<code>gsp_matplotlib.extra.bufferx</code>","text":"<p>Utility class for Buffer extended functionality using numpy.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx.Bufferx","title":"<code>Bufferx</code>","text":"<p>Utility class for Buffer extended functionality using numpy.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>class Bufferx:\n    \"\"\"Utility class for Buffer extended functionality using numpy.\"\"\"\n\n    # =============================================================================\n    # Matrix functions\n    # =============================================================================\n\n    @staticmethod\n    def mat4_identity() -&gt; Buffer:\n        \"\"\"Create a Buffer containing a 4x4 identity matrix.\"\"\"\n        mat4_numpy = np.asarray([np.identity(4, dtype=np.float32)])\n        buffer = Bufferx.from_numpy(mat4_numpy, BufferType.mat4)\n        return buffer\n\n    # =============================================================================\n    # .to_numpy/.from_numpy\n    # =============================================================================\n    @staticmethod\n    def to_numpy(buffer: Buffer) -&gt; np.ndarray:\n        \"\"\"Convert a Buffer to a numpy array.\"\"\"\n        if buffer.get_type() == BufferType.float32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.int8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.int8).reshape((count, 1))\n        elif buffer.get_type() == BufferType.int32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.int32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.uint8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 1))\n        elif buffer.get_type() == BufferType.uint32:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint32).reshape((count, 1))\n        elif buffer.get_type() == BufferType.vec2:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 2))\n        elif buffer.get_type() == BufferType.vec3:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 3))\n        elif buffer.get_type() == BufferType.vec4:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4))\n        elif buffer.get_type() == BufferType.mat4:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4, 4))\n        elif buffer.get_type() == BufferType.rgba8:\n            count = buffer.get_count()\n            return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 4))\n        else:\n            raise NotImplementedError(f\"unable to convert buffer {buffer} to numpy array\")\n\n    @staticmethod\n    def from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer:\n        \"\"\"Create a Buffer from a numpy array.\"\"\"\n        if bufferType == BufferType.float32:\n            # sanity check\n            assert array_numpy.dtype == np.float32, \"Numpy array must be of dtype float32\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.uint32:\n            # sanity check\n            assert array_numpy.dtype == np.uint32, \"Numpy array must be of dtype uint32\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.vec2:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 2, \"Numpy array must be of shape (2,)\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.vec3:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 3, \"Numpy array must be of shape (3,)\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n            return buffer\n        elif bufferType == BufferType.mat4:\n            # sanity check\n            assert array_numpy.shape.__len__() == 3 and array_numpy.shape[1] == 4 and array_numpy.shape[2] == 4, \"Numpy array must be of shape (4, 4)\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, 1)\n            return buffer\n        elif bufferType == BufferType.rgba8:\n            # sanity check\n            assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 4, \"Numpy array must be of shape (4,)\"\n\n            count = array_numpy.shape[0]\n            buffer = Buffer(count, bufferType)\n            buffer.set_data(bytearray(array_numpy.astype(np.uint8).tobytes()), 0, count)\n            return buffer\n        else:\n            raise NotImplementedError(f\"unable to create a {bufferType} buffer from numpy array of shape {array_numpy.shape} and dtype {array_numpy.dtype}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx.Bufferx.from_numpy","title":"<code>from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Create a Buffer from a numpy array.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef from_numpy(array_numpy: np.ndarray, bufferType: BufferType) -&gt; Buffer:\n    \"\"\"Create a Buffer from a numpy array.\"\"\"\n    if bufferType == BufferType.float32:\n        # sanity check\n        assert array_numpy.dtype == np.float32, \"Numpy array must be of dtype float32\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.uint32:\n        # sanity check\n        assert array_numpy.dtype == np.uint32, \"Numpy array must be of dtype uint32\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.vec2:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 2, \"Numpy array must be of shape (2,)\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.vec3:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 3, \"Numpy array must be of shape (3,)\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, count)\n        return buffer\n    elif bufferType == BufferType.mat4:\n        # sanity check\n        assert array_numpy.shape.__len__() == 3 and array_numpy.shape[1] == 4 and array_numpy.shape[2] == 4, \"Numpy array must be of shape (4, 4)\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.float32).tobytes()), 0, 1)\n        return buffer\n    elif bufferType == BufferType.rgba8:\n        # sanity check\n        assert array_numpy.shape.__len__() == 2 and array_numpy.shape[1] == 4, \"Numpy array must be of shape (4,)\"\n\n        count = array_numpy.shape[0]\n        buffer = Buffer(count, bufferType)\n        buffer.set_data(bytearray(array_numpy.astype(np.uint8).tobytes()), 0, count)\n        return buffer\n    else:\n        raise NotImplementedError(f\"unable to create a {bufferType} buffer from numpy array of shape {array_numpy.shape} and dtype {array_numpy.dtype}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx.Bufferx.mat4_identity","title":"<code>mat4_identity() -&gt; Buffer</code>  <code>staticmethod</code>","text":"<p>Create a Buffer containing a 4x4 identity matrix.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef mat4_identity() -&gt; Buffer:\n    \"\"\"Create a Buffer containing a 4x4 identity matrix.\"\"\"\n    mat4_numpy = np.asarray([np.identity(4, dtype=np.float32)])\n    buffer = Bufferx.from_numpy(mat4_numpy, BufferType.mat4)\n    return buffer\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.extra.bufferx.Bufferx.to_numpy","title":"<code>to_numpy(buffer: Buffer) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":"<p>Convert a Buffer to a numpy array.</p> Source code in <code>src/gsp_matplotlib/extra/bufferx.py</code> <pre><code>@staticmethod\ndef to_numpy(buffer: Buffer) -&gt; np.ndarray:\n    \"\"\"Convert a Buffer to a numpy array.\"\"\"\n    if buffer.get_type() == BufferType.float32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.int8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.int8).reshape((count, 1))\n    elif buffer.get_type() == BufferType.int32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.int32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.uint8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 1))\n    elif buffer.get_type() == BufferType.uint32:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint32).reshape((count, 1))\n    elif buffer.get_type() == BufferType.vec2:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 2))\n    elif buffer.get_type() == BufferType.vec3:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 3))\n    elif buffer.get_type() == BufferType.vec4:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4))\n    elif buffer.get_type() == BufferType.mat4:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.float32).reshape((count, 4, 4))\n    elif buffer.get_type() == BufferType.rgba8:\n        count = buffer.get_count()\n        return np.frombuffer(buffer.to_bytearray(), dtype=np.uint8).reshape((count, 4))\n    else:\n        raise NotImplementedError(f\"unable to convert buffer {buffer} to numpy array\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#utils-module","title":"Utils Module","text":"<p>The utils module provides converter utilities for the Matplotlib backend.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils","title":"<code>gsp_matplotlib.utils</code>","text":"<p>Utility module for GSP Matplotlib conversions.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.ConverterUtils","title":"<code>ConverterUtils</code>","text":"<p>Utility class for converting GSP types to Matplotlib types.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>class ConverterUtils:\n    \"\"\"Utility class for converting GSP types to Matplotlib types.\"\"\"\n\n    @staticmethod\n    def cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal[\"butt\", \"round\", \"projecting\"]:\n        \"\"\"Convert CapStyle enum to Matplotlib string.\n\n        Args:\n            gsp_cap_style (CapStyle): The GSP cap style.\n\n        Returns:\n            str: The corresponding Matplotlib cap style.\n        \"\"\"\n        if gsp_cap_style == CapStyle.BUTT:\n            return \"butt\"\n        elif gsp_cap_style == CapStyle.ROUND:\n            return \"round\"\n        elif gsp_cap_style == CapStyle.PROJECTING:\n            return \"projecting\"\n        else:\n            raise ValueError(f\"Unsupported CapStyle: {gsp_cap_style}\")\n\n    @staticmethod\n    def join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal[\"miter\", \"round\", \"bevel\"]:\n        \"\"\"Convert JoinStyle enum to Matplotlib string.\n\n        Args:\n            gsp_join_style (JoinStyle): The GSP join style.\n\n        Returns:\n            str: The corresponding Matplotlib join style.\n        \"\"\"\n        if gsp_join_style == JoinStyle.MITER:\n            return \"miter\"\n        elif gsp_join_style == JoinStyle.ROUND:\n            return \"round\"\n        elif gsp_join_style == JoinStyle.BEVEL:\n            return \"bevel\"\n        else:\n            raise ValueError(f\"Unsupported JoinStyle: {gsp_join_style}\")\n\n    @staticmethod\n    def marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str:\n        \"\"\"Convert GSP marker shape to Matplotlib marker shape.\n\n        Args:\n            gsp_marker_shape (MarkerShape): The GSP marker shape.\n\n        Returns:\n            str: The corresponding Matplotlib marker shape.\n        \"\"\"\n        if gsp_marker_shape == MarkerShape.disc:\n            mpl_marker_shape = \"o\"\n        elif gsp_marker_shape == MarkerShape.square:\n            mpl_marker_shape = \"s\"\n        elif gsp_marker_shape == MarkerShape.club:\n            mpl_marker_shape = r\"$\\clubsuit$\"\n        else:\n            raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n        return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.ConverterUtils.cap_style_gsp_to_mpl","title":"<code>cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal['butt', 'round', 'projecting']</code>  <code>staticmethod</code>","text":"<p>Convert CapStyle enum to Matplotlib string.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_cap_style</code> <code>gsp.types.CapStyle</code> <p>The GSP cap style.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>typing.Literal['butt', 'round', 'projecting']</code> <p>The corresponding Matplotlib cap style.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal[\"butt\", \"round\", \"projecting\"]:\n    \"\"\"Convert CapStyle enum to Matplotlib string.\n\n    Args:\n        gsp_cap_style (CapStyle): The GSP cap style.\n\n    Returns:\n        str: The corresponding Matplotlib cap style.\n    \"\"\"\n    if gsp_cap_style == CapStyle.BUTT:\n        return \"butt\"\n    elif gsp_cap_style == CapStyle.ROUND:\n        return \"round\"\n    elif gsp_cap_style == CapStyle.PROJECTING:\n        return \"projecting\"\n    else:\n        raise ValueError(f\"Unsupported CapStyle: {gsp_cap_style}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.ConverterUtils.join_style_gsp_to_mpl","title":"<code>join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal['miter', 'round', 'bevel']</code>  <code>staticmethod</code>","text":"<p>Convert JoinStyle enum to Matplotlib string.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_join_style</code> <code>gsp.types.JoinStyle</code> <p>The GSP join style.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>typing.Literal['miter', 'round', 'bevel']</code> <p>The corresponding Matplotlib join style.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal[\"miter\", \"round\", \"bevel\"]:\n    \"\"\"Convert JoinStyle enum to Matplotlib string.\n\n    Args:\n        gsp_join_style (JoinStyle): The GSP join style.\n\n    Returns:\n        str: The corresponding Matplotlib join style.\n    \"\"\"\n    if gsp_join_style == JoinStyle.MITER:\n        return \"miter\"\n    elif gsp_join_style == JoinStyle.ROUND:\n        return \"round\"\n    elif gsp_join_style == JoinStyle.BEVEL:\n        return \"bevel\"\n    else:\n        raise ValueError(f\"Unsupported JoinStyle: {gsp_join_style}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.ConverterUtils.marker_shape_gsp_to_mpl","title":"<code>marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert GSP marker shape to Matplotlib marker shape.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_marker_shape</code> <code>gsp.types.MarkerShape</code> <p>The GSP marker shape.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The corresponding Matplotlib marker shape.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str:\n    \"\"\"Convert GSP marker shape to Matplotlib marker shape.\n\n    Args:\n        gsp_marker_shape (MarkerShape): The GSP marker shape.\n\n    Returns:\n        str: The corresponding Matplotlib marker shape.\n    \"\"\"\n    if gsp_marker_shape == MarkerShape.disc:\n        mpl_marker_shape = \"o\"\n    elif gsp_marker_shape == MarkerShape.square:\n        mpl_marker_shape = \"s\"\n    elif gsp_marker_shape == MarkerShape.club:\n        mpl_marker_shape = r\"$\\clubsuit$\"\n    else:\n        raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n    return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_matplotlib/#converter-utils","title":"Converter Utils","text":""},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils","title":"<code>gsp_matplotlib.utils.converter_utils</code>","text":"<p>Utility class for converting GSP types to Matplotlib types.</p>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils.ConverterUtils","title":"<code>ConverterUtils</code>","text":"<p>Utility class for converting GSP types to Matplotlib types.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>class ConverterUtils:\n    \"\"\"Utility class for converting GSP types to Matplotlib types.\"\"\"\n\n    @staticmethod\n    def cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal[\"butt\", \"round\", \"projecting\"]:\n        \"\"\"Convert CapStyle enum to Matplotlib string.\n\n        Args:\n            gsp_cap_style (CapStyle): The GSP cap style.\n\n        Returns:\n            str: The corresponding Matplotlib cap style.\n        \"\"\"\n        if gsp_cap_style == CapStyle.BUTT:\n            return \"butt\"\n        elif gsp_cap_style == CapStyle.ROUND:\n            return \"round\"\n        elif gsp_cap_style == CapStyle.PROJECTING:\n            return \"projecting\"\n        else:\n            raise ValueError(f\"Unsupported CapStyle: {gsp_cap_style}\")\n\n    @staticmethod\n    def join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal[\"miter\", \"round\", \"bevel\"]:\n        \"\"\"Convert JoinStyle enum to Matplotlib string.\n\n        Args:\n            gsp_join_style (JoinStyle): The GSP join style.\n\n        Returns:\n            str: The corresponding Matplotlib join style.\n        \"\"\"\n        if gsp_join_style == JoinStyle.MITER:\n            return \"miter\"\n        elif gsp_join_style == JoinStyle.ROUND:\n            return \"round\"\n        elif gsp_join_style == JoinStyle.BEVEL:\n            return \"bevel\"\n        else:\n            raise ValueError(f\"Unsupported JoinStyle: {gsp_join_style}\")\n\n    @staticmethod\n    def marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str:\n        \"\"\"Convert GSP marker shape to Matplotlib marker shape.\n\n        Args:\n            gsp_marker_shape (MarkerShape): The GSP marker shape.\n\n        Returns:\n            str: The corresponding Matplotlib marker shape.\n        \"\"\"\n        if gsp_marker_shape == MarkerShape.disc:\n            mpl_marker_shape = \"o\"\n        elif gsp_marker_shape == MarkerShape.square:\n            mpl_marker_shape = \"s\"\n        elif gsp_marker_shape == MarkerShape.club:\n            mpl_marker_shape = r\"$\\clubsuit$\"\n        else:\n            raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n        return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils.ConverterUtils.cap_style_gsp_to_mpl","title":"<code>cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal['butt', 'round', 'projecting']</code>  <code>staticmethod</code>","text":"<p>Convert CapStyle enum to Matplotlib string.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_cap_style</code> <code>gsp.types.CapStyle</code> <p>The GSP cap style.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>typing.Literal['butt', 'round', 'projecting']</code> <p>The corresponding Matplotlib cap style.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef cap_style_gsp_to_mpl(gsp_cap_style: CapStyle) -&gt; Literal[\"butt\", \"round\", \"projecting\"]:\n    \"\"\"Convert CapStyle enum to Matplotlib string.\n\n    Args:\n        gsp_cap_style (CapStyle): The GSP cap style.\n\n    Returns:\n        str: The corresponding Matplotlib cap style.\n    \"\"\"\n    if gsp_cap_style == CapStyle.BUTT:\n        return \"butt\"\n    elif gsp_cap_style == CapStyle.ROUND:\n        return \"round\"\n    elif gsp_cap_style == CapStyle.PROJECTING:\n        return \"projecting\"\n    else:\n        raise ValueError(f\"Unsupported CapStyle: {gsp_cap_style}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils.ConverterUtils.join_style_gsp_to_mpl","title":"<code>join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal['miter', 'round', 'bevel']</code>  <code>staticmethod</code>","text":"<p>Convert JoinStyle enum to Matplotlib string.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_join_style</code> <code>gsp.types.JoinStyle</code> <p>The GSP join style.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>typing.Literal['miter', 'round', 'bevel']</code> <p>The corresponding Matplotlib join style.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef join_style_gsp_to_mpl(gsp_join_style: JoinStyle) -&gt; Literal[\"miter\", \"round\", \"bevel\"]:\n    \"\"\"Convert JoinStyle enum to Matplotlib string.\n\n    Args:\n        gsp_join_style (JoinStyle): The GSP join style.\n\n    Returns:\n        str: The corresponding Matplotlib join style.\n    \"\"\"\n    if gsp_join_style == JoinStyle.MITER:\n        return \"miter\"\n    elif gsp_join_style == JoinStyle.ROUND:\n        return \"round\"\n    elif gsp_join_style == JoinStyle.BEVEL:\n        return \"bevel\"\n    else:\n        raise ValueError(f\"Unsupported JoinStyle: {gsp_join_style}\")\n</code></pre>"},{"location":"api/gsp_matplotlib/#gsp_matplotlib.utils.converter_utils.ConverterUtils.marker_shape_gsp_to_mpl","title":"<code>marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Convert GSP marker shape to Matplotlib marker shape.</p> <p>Parameters:</p> Name Type Description Default <code>gsp_marker_shape</code> <code>gsp.types.MarkerShape</code> <p>The GSP marker shape.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The corresponding Matplotlib marker shape.</p> Source code in <code>src/gsp_matplotlib/utils/converter_utils.py</code> <pre><code>@staticmethod\ndef marker_shape_gsp_to_mpl(gsp_marker_shape: MarkerShape) -&gt; str:\n    \"\"\"Convert GSP marker shape to Matplotlib marker shape.\n\n    Args:\n        gsp_marker_shape (MarkerShape): The GSP marker shape.\n\n    Returns:\n        str: The corresponding Matplotlib marker shape.\n    \"\"\"\n    if gsp_marker_shape == MarkerShape.disc:\n        mpl_marker_shape = \"o\"\n    elif gsp_marker_shape == MarkerShape.square:\n        mpl_marker_shape = \"s\"\n    elif gsp_marker_shape == MarkerShape.club:\n        mpl_marker_shape = r\"$\\clubsuit$\"\n    else:\n        raise ValueError(f\"Unsupported marker shape: {gsp_marker_shape}\")\n\n    return mpl_marker_shape\n</code></pre>"},{"location":"api/gsp_network/","title":"GSP Network API Reference","text":"<p>The GSP Network module provides network-based rendering capabilities, enabling remote visualization and client-server architectures.</p>"},{"location":"api/gsp_network/#overview","title":"Overview","text":""},{"location":"api/gsp_network/#gsp_network","title":"<code>gsp_network</code>","text":"<p>gsp_network provides functionality for rendering graphics over a network using different remote renderers.</p>"},{"location":"api/gsp_network/#renderer-module","title":"Renderer Module","text":"<p>The renderer module contains the network renderer implementation for remote rendering.</p>"},{"location":"api/gsp_network/#gsp_network.renderer","title":"<code>gsp_network.renderer</code>","text":"<p>Network renderer that sends rendering requests to a remote server and displays the results using Matplotlib.</p>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer","title":"<code>NetworkRenderer</code>","text":"<p>               Bases: <code>gsp.types.renderer_base.RendererBase</code></p> <p>Note: this requires a running gsp_network server. See the README for instructions.</p> <p>IMPORTANT: it DOES NOT depend on GSP matplotlib renderer, it only uses pip matplotlib to display the remotely rendered images.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>class NetworkRenderer(RendererBase):\n    \"\"\"**Note**: this requires a running gsp_network server. See the README for instructions.\n\n    **IMPORTANT**: it DOES NOT depend on GSP matplotlib renderer, it only uses pip matplotlib to display the remotely rendered images.\n    \"\"\"\n\n    def __init__(self, canvas: Canvas, server_base_url: str, remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = \"matplotlib\") -&gt; None:\n        \"\"\"Initialize the NetworkRenderer.\n\n        Args:\n            canvas (Canvas): _description_\n            server_base_url (str): _description_\n            remote_renderer_name (Literal[\"matplotlib\", \"datoviz\"], optional): _description_. Defaults to \"matplotlib\".\n        \"\"\"\n        self._canvas = canvas\n        self._server_base_url = server_base_url\n        self._remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = remote_renderer_name\n\n        # Create a figure\n        figure_width = self._canvas.get_width() / self._canvas.get_dpi()\n        figure_height = self._canvas.get_height() / self._canvas.get_dpi()\n        self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=self._canvas.get_dpi())\n        assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n        self._figure.canvas.manager.set_window_title(f\"Network ({self._remote_renderer_name})\")\n\n        # get the only axes in the figure\n        self._mpl_axes = self._figure.add_axes((0, 0, 1, 1))\n        # hide the borders\n        self._mpl_axes.axis(\"off\")\n\n        # create an np.array to hold the image\n        image_data_np = np.zeros((self._canvas.get_height(), self._canvas.get_width(), 3), dtype=np.uint8)\n        self._axes_image = self._mpl_axes.imshow(image_data_np, aspect=\"auto\")\n\n    def get_canvas(self) -&gt; Canvas:\n        \"\"\"Get the canvas associated with the network renderer.\n\n        Returns:\n            Canvas: The canvas associated with the network renderer.\n        \"\"\"\n        return self._canvas\n\n    def close(self) -&gt; None:\n        \"\"\"Close the network renderer and release resources.\"\"\"\n        # stop the event loop if any - thus .show(block=True) will return\n        self._figure.canvas.stop_event_loop()\n        # close the figure\n        matplotlib.pyplot.close(self._figure)\n        self._figure = None  # type: ignore\n\n    def get_remote_renderer_name(self) -&gt; Literal[\"matplotlib\", \"datoviz\"]:\n        \"\"\"Get the name of the remote renderer being used.\n\n        Returns:\n            Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.\n        \"\"\"\n        return self._remote_renderer_name\n\n    def render(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n    ) -&gt; bytes:\n        \"\"\"Render the scene remotely and update the matplotlib figure with the rendered image.\n\n        Args:\n            viewports (Sequence[Viewport]): The viewports to render.\n            visuals (Sequence[VisualBase]): The visuals to render.\n            model_matrices (Sequence[TransBuf]): The model matrices for the visuals.\n            cameras (Sequence[Camera]): The cameras to use for rendering.\n\n        Returns:\n            bytes: The rendered image data in PNG format.\n\n        Raises:\n            Exception: If the network request fails.\n        \"\"\"\n        # =============================================================================\n        # Serialize the scene and create the payload\n        # =============================================================================\n        pydanticSerializer = PydanticSerializer(self._canvas)\n        pydantic_scene_dict = pydanticSerializer.serialize(\n            viewports=viewports,\n            visuals=visuals,\n            model_matrices=model_matrices,\n            cameras=cameras,\n        )\n\n        payload: NetworkPayload = {\n            \"renderer_name\": self._remote_renderer_name,\n            \"data\": pydantic_scene_dict,\n        }\n\n        # =============================================================================\n        # do network request to send the payload and get the rendered image\n        # =============================================================================\n        # Send the POST request with JSON data\n        call_url = f\"{self._server_base_url}/render\"\n        headers = {\"Content-Type\": \"application/json\"}\n        response = requests.post(call_url, data=json.dumps(payload), headers=headers)\n\n        # Check the response status\n        if response.status_code != HttpStatus.OK:\n            raise Exception(f\"Request failed with status code {response.status_code}\")\n        image_png_data = response.content\n\n        # =============================================================================\n        # Render the image in the matplotlib figure\n        # =============================================================================\n        assert self._axes_image is not None, \"PANIC self._axes_image is None\"\n        # update the image data\n        image_data_io = io.BytesIO(image_png_data)\n        image_data_np = matplotlib.image.imread(image_data_io, format=\"png\")\n        self._axes_image.set_data(image_data_np)\n\n        # return png data as bytes\n        return image_png_data\n\n    def show(self) -&gt; None:\n        \"\"\"Show the rendered canvas (blocking call).\"\"\"\n        # handle non-interactive mode for tests\n        in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n        if in_test:\n            return\n\n        matplotlib.pyplot.show()\n\n    def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n        \"\"\"Get the underlying Matplotlib figure.\n\n        Returns:\n            matplotlib.figure.Figure: The Matplotlib figure used by the renderer.\n        \"\"\"\n        return self._figure\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.__init__","title":"<code>__init__(canvas: Canvas, server_base_url: str, remote_renderer_name: Literal['matplotlib', 'datoviz'] = 'matplotlib') -&gt; None</code>","text":"<p>Initialize the NetworkRenderer.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>gsp.core.canvas.Canvas</code> <p>description</p> required <code>server_base_url</code> <code>str</code> <p>description</p> required <code>remote_renderer_name</code> <code>typing.Literal['matplotlib', 'datoviz']</code> <p>description. Defaults to \"matplotlib\".</p> <code>'matplotlib'</code> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def __init__(self, canvas: Canvas, server_base_url: str, remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = \"matplotlib\") -&gt; None:\n    \"\"\"Initialize the NetworkRenderer.\n\n    Args:\n        canvas (Canvas): _description_\n        server_base_url (str): _description_\n        remote_renderer_name (Literal[\"matplotlib\", \"datoviz\"], optional): _description_. Defaults to \"matplotlib\".\n    \"\"\"\n    self._canvas = canvas\n    self._server_base_url = server_base_url\n    self._remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = remote_renderer_name\n\n    # Create a figure\n    figure_width = self._canvas.get_width() / self._canvas.get_dpi()\n    figure_height = self._canvas.get_height() / self._canvas.get_dpi()\n    self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=self._canvas.get_dpi())\n    assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n    self._figure.canvas.manager.set_window_title(f\"Network ({self._remote_renderer_name})\")\n\n    # get the only axes in the figure\n    self._mpl_axes = self._figure.add_axes((0, 0, 1, 1))\n    # hide the borders\n    self._mpl_axes.axis(\"off\")\n\n    # create an np.array to hold the image\n    image_data_np = np.zeros((self._canvas.get_height(), self._canvas.get_width(), 3), dtype=np.uint8)\n    self._axes_image = self._mpl_axes.imshow(image_data_np, aspect=\"auto\")\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.get_canvas","title":"<code>get_canvas() -&gt; Canvas</code>","text":"<p>Get the canvas associated with the network renderer.</p> <p>Returns:</p> Name Type Description <code>Canvas</code> <code>gsp.core.canvas.Canvas</code> <p>The canvas associated with the network renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_canvas(self) -&gt; Canvas:\n    \"\"\"Get the canvas associated with the network renderer.\n\n    Returns:\n        Canvas: The canvas associated with the network renderer.\n    \"\"\"\n    return self._canvas\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the network renderer and release resources.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the network renderer and release resources.\"\"\"\n    # stop the event loop if any - thus .show(block=True) will return\n    self._figure.canvas.stop_event_loop()\n    # close the figure\n    matplotlib.pyplot.close(self._figure)\n    self._figure = None  # type: ignore\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.get_remote_renderer_name","title":"<code>get_remote_renderer_name() -&gt; Literal['matplotlib', 'datoviz']</code>","text":"<p>Get the name of the remote renderer being used.</p> <p>Returns:</p> Type Description <code>typing.Literal['matplotlib', 'datoviz']</code> <p>Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_remote_renderer_name(self) -&gt; Literal[\"matplotlib\", \"datoviz\"]:\n    \"\"\"Get the name of the remote renderer being used.\n\n    Returns:\n        Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.\n    \"\"\"\n    return self._remote_renderer_name\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.render","title":"<code>render(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; bytes</code>","text":"<p>Render the scene remotely and update the matplotlib figure with the rendered image.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>The viewports to render.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>The visuals to render.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>The model matrices for the visuals.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>The cameras to use for rendering.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The rendered image data in PNG format.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the network request fails.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def render(\n    self,\n    viewports: Sequence[Viewport],\n    visuals: Sequence[VisualBase],\n    model_matrices: Sequence[TransBuf],\n    cameras: Sequence[Camera],\n) -&gt; bytes:\n    \"\"\"Render the scene remotely and update the matplotlib figure with the rendered image.\n\n    Args:\n        viewports (Sequence[Viewport]): The viewports to render.\n        visuals (Sequence[VisualBase]): The visuals to render.\n        model_matrices (Sequence[TransBuf]): The model matrices for the visuals.\n        cameras (Sequence[Camera]): The cameras to use for rendering.\n\n    Returns:\n        bytes: The rendered image data in PNG format.\n\n    Raises:\n        Exception: If the network request fails.\n    \"\"\"\n    # =============================================================================\n    # Serialize the scene and create the payload\n    # =============================================================================\n    pydanticSerializer = PydanticSerializer(self._canvas)\n    pydantic_scene_dict = pydanticSerializer.serialize(\n        viewports=viewports,\n        visuals=visuals,\n        model_matrices=model_matrices,\n        cameras=cameras,\n    )\n\n    payload: NetworkPayload = {\n        \"renderer_name\": self._remote_renderer_name,\n        \"data\": pydantic_scene_dict,\n    }\n\n    # =============================================================================\n    # do network request to send the payload and get the rendered image\n    # =============================================================================\n    # Send the POST request with JSON data\n    call_url = f\"{self._server_base_url}/render\"\n    headers = {\"Content-Type\": \"application/json\"}\n    response = requests.post(call_url, data=json.dumps(payload), headers=headers)\n\n    # Check the response status\n    if response.status_code != HttpStatus.OK:\n        raise Exception(f\"Request failed with status code {response.status_code}\")\n    image_png_data = response.content\n\n    # =============================================================================\n    # Render the image in the matplotlib figure\n    # =============================================================================\n    assert self._axes_image is not None, \"PANIC self._axes_image is None\"\n    # update the image data\n    image_data_io = io.BytesIO(image_png_data)\n    image_data_np = matplotlib.image.imread(image_data_io, format=\"png\")\n    self._axes_image.set_data(image_data_np)\n\n    # return png data as bytes\n    return image_png_data\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.show","title":"<code>show() -&gt; None</code>","text":"<p>Show the rendered canvas (blocking call).</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the rendered canvas (blocking call).\"\"\"\n    # handle non-interactive mode for tests\n    in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n    if in_test:\n        return\n\n    matplotlib.pyplot.show()\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.NetworkRenderer.get_mpl_figure","title":"<code>get_mpl_figure() -&gt; matplotlib.figure.Figure</code>","text":"<p>Get the underlying Matplotlib figure.</p> <p>Returns:</p> Type Description <code>matplotlib.figure.Figure</code> <p>matplotlib.figure.Figure: The Matplotlib figure used by the renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n    \"\"\"Get the underlying Matplotlib figure.\n\n    Returns:\n        matplotlib.figure.Figure: The Matplotlib figure used by the renderer.\n    \"\"\"\n    return self._figure\n</code></pre>"},{"location":"api/gsp_network/#network-renderer","title":"Network Renderer","text":""},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer","title":"<code>gsp_network.renderer.network_renderer</code>","text":"<p>Network renderer that sends rendering requests to a remote server and displays the results using Matplotlib.</p>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkPayload","title":"<code>NetworkPayload</code>","text":"<p>               Bases: <code>typing.TypedDict</code></p> <p>Type definition for the network payload sent to the server.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>class NetworkPayload(TypedDict):\n    \"\"\"Type definition for the network payload sent to the server.\"\"\"\n    renderer_name: Literal[\"matplotlib\", \"datoviz\"]\n    data: PydanticDict\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer","title":"<code>NetworkRenderer</code>","text":"<p>               Bases: <code>gsp.types.renderer_base.RendererBase</code></p> <p>Note: this requires a running gsp_network server. See the README for instructions.</p> <p>IMPORTANT: it DOES NOT depend on GSP matplotlib renderer, it only uses pip matplotlib to display the remotely rendered images.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>class NetworkRenderer(RendererBase):\n    \"\"\"**Note**: this requires a running gsp_network server. See the README for instructions.\n\n    **IMPORTANT**: it DOES NOT depend on GSP matplotlib renderer, it only uses pip matplotlib to display the remotely rendered images.\n    \"\"\"\n\n    def __init__(self, canvas: Canvas, server_base_url: str, remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = \"matplotlib\") -&gt; None:\n        \"\"\"Initialize the NetworkRenderer.\n\n        Args:\n            canvas (Canvas): _description_\n            server_base_url (str): _description_\n            remote_renderer_name (Literal[\"matplotlib\", \"datoviz\"], optional): _description_. Defaults to \"matplotlib\".\n        \"\"\"\n        self._canvas = canvas\n        self._server_base_url = server_base_url\n        self._remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = remote_renderer_name\n\n        # Create a figure\n        figure_width = self._canvas.get_width() / self._canvas.get_dpi()\n        figure_height = self._canvas.get_height() / self._canvas.get_dpi()\n        self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=self._canvas.get_dpi())\n        assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n        self._figure.canvas.manager.set_window_title(f\"Network ({self._remote_renderer_name})\")\n\n        # get the only axes in the figure\n        self._mpl_axes = self._figure.add_axes((0, 0, 1, 1))\n        # hide the borders\n        self._mpl_axes.axis(\"off\")\n\n        # create an np.array to hold the image\n        image_data_np = np.zeros((self._canvas.get_height(), self._canvas.get_width(), 3), dtype=np.uint8)\n        self._axes_image = self._mpl_axes.imshow(image_data_np, aspect=\"auto\")\n\n    def get_canvas(self) -&gt; Canvas:\n        \"\"\"Get the canvas associated with the network renderer.\n\n        Returns:\n            Canvas: The canvas associated with the network renderer.\n        \"\"\"\n        return self._canvas\n\n    def close(self) -&gt; None:\n        \"\"\"Close the network renderer and release resources.\"\"\"\n        # stop the event loop if any - thus .show(block=True) will return\n        self._figure.canvas.stop_event_loop()\n        # close the figure\n        matplotlib.pyplot.close(self._figure)\n        self._figure = None  # type: ignore\n\n    def get_remote_renderer_name(self) -&gt; Literal[\"matplotlib\", \"datoviz\"]:\n        \"\"\"Get the name of the remote renderer being used.\n\n        Returns:\n            Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.\n        \"\"\"\n        return self._remote_renderer_name\n\n    def render(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n    ) -&gt; bytes:\n        \"\"\"Render the scene remotely and update the matplotlib figure with the rendered image.\n\n        Args:\n            viewports (Sequence[Viewport]): The viewports to render.\n            visuals (Sequence[VisualBase]): The visuals to render.\n            model_matrices (Sequence[TransBuf]): The model matrices for the visuals.\n            cameras (Sequence[Camera]): The cameras to use for rendering.\n\n        Returns:\n            bytes: The rendered image data in PNG format.\n\n        Raises:\n            Exception: If the network request fails.\n        \"\"\"\n        # =============================================================================\n        # Serialize the scene and create the payload\n        # =============================================================================\n        pydanticSerializer = PydanticSerializer(self._canvas)\n        pydantic_scene_dict = pydanticSerializer.serialize(\n            viewports=viewports,\n            visuals=visuals,\n            model_matrices=model_matrices,\n            cameras=cameras,\n        )\n\n        payload: NetworkPayload = {\n            \"renderer_name\": self._remote_renderer_name,\n            \"data\": pydantic_scene_dict,\n        }\n\n        # =============================================================================\n        # do network request to send the payload and get the rendered image\n        # =============================================================================\n        # Send the POST request with JSON data\n        call_url = f\"{self._server_base_url}/render\"\n        headers = {\"Content-Type\": \"application/json\"}\n        response = requests.post(call_url, data=json.dumps(payload), headers=headers)\n\n        # Check the response status\n        if response.status_code != HttpStatus.OK:\n            raise Exception(f\"Request failed with status code {response.status_code}\")\n        image_png_data = response.content\n\n        # =============================================================================\n        # Render the image in the matplotlib figure\n        # =============================================================================\n        assert self._axes_image is not None, \"PANIC self._axes_image is None\"\n        # update the image data\n        image_data_io = io.BytesIO(image_png_data)\n        image_data_np = matplotlib.image.imread(image_data_io, format=\"png\")\n        self._axes_image.set_data(image_data_np)\n\n        # return png data as bytes\n        return image_png_data\n\n    def show(self) -&gt; None:\n        \"\"\"Show the rendered canvas (blocking call).\"\"\"\n        # handle non-interactive mode for tests\n        in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n        if in_test:\n            return\n\n        matplotlib.pyplot.show()\n\n    def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n        \"\"\"Get the underlying Matplotlib figure.\n\n        Returns:\n            matplotlib.figure.Figure: The Matplotlib figure used by the renderer.\n        \"\"\"\n        return self._figure\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.__init__","title":"<code>__init__(canvas: Canvas, server_base_url: str, remote_renderer_name: Literal['matplotlib', 'datoviz'] = 'matplotlib') -&gt; None</code>","text":"<p>Initialize the NetworkRenderer.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>gsp.core.canvas.Canvas</code> <p>description</p> required <code>server_base_url</code> <code>str</code> <p>description</p> required <code>remote_renderer_name</code> <code>typing.Literal['matplotlib', 'datoviz']</code> <p>description. Defaults to \"matplotlib\".</p> <code>'matplotlib'</code> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def __init__(self, canvas: Canvas, server_base_url: str, remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = \"matplotlib\") -&gt; None:\n    \"\"\"Initialize the NetworkRenderer.\n\n    Args:\n        canvas (Canvas): _description_\n        server_base_url (str): _description_\n        remote_renderer_name (Literal[\"matplotlib\", \"datoviz\"], optional): _description_. Defaults to \"matplotlib\".\n    \"\"\"\n    self._canvas = canvas\n    self._server_base_url = server_base_url\n    self._remote_renderer_name: Literal[\"matplotlib\", \"datoviz\"] = remote_renderer_name\n\n    # Create a figure\n    figure_width = self._canvas.get_width() / self._canvas.get_dpi()\n    figure_height = self._canvas.get_height() / self._canvas.get_dpi()\n    self._figure: matplotlib.figure.Figure = matplotlib.pyplot.figure(figsize=(figure_width, figure_height), dpi=self._canvas.get_dpi())\n    assert self._figure.canvas.manager is not None, \"matplotlib figure canvas manager is None\"\n    self._figure.canvas.manager.set_window_title(f\"Network ({self._remote_renderer_name})\")\n\n    # get the only axes in the figure\n    self._mpl_axes = self._figure.add_axes((0, 0, 1, 1))\n    # hide the borders\n    self._mpl_axes.axis(\"off\")\n\n    # create an np.array to hold the image\n    image_data_np = np.zeros((self._canvas.get_height(), self._canvas.get_width(), 3), dtype=np.uint8)\n    self._axes_image = self._mpl_axes.imshow(image_data_np, aspect=\"auto\")\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.close","title":"<code>close() -&gt; None</code>","text":"<p>Close the network renderer and release resources.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the network renderer and release resources.\"\"\"\n    # stop the event loop if any - thus .show(block=True) will return\n    self._figure.canvas.stop_event_loop()\n    # close the figure\n    matplotlib.pyplot.close(self._figure)\n    self._figure = None  # type: ignore\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.get_canvas","title":"<code>get_canvas() -&gt; Canvas</code>","text":"<p>Get the canvas associated with the network renderer.</p> <p>Returns:</p> Name Type Description <code>Canvas</code> <code>gsp.core.canvas.Canvas</code> <p>The canvas associated with the network renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_canvas(self) -&gt; Canvas:\n    \"\"\"Get the canvas associated with the network renderer.\n\n    Returns:\n        Canvas: The canvas associated with the network renderer.\n    \"\"\"\n    return self._canvas\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.get_mpl_figure","title":"<code>get_mpl_figure() -&gt; matplotlib.figure.Figure</code>","text":"<p>Get the underlying Matplotlib figure.</p> <p>Returns:</p> Type Description <code>matplotlib.figure.Figure</code> <p>matplotlib.figure.Figure: The Matplotlib figure used by the renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_mpl_figure(self) -&gt; matplotlib.figure.Figure:\n    \"\"\"Get the underlying Matplotlib figure.\n\n    Returns:\n        matplotlib.figure.Figure: The Matplotlib figure used by the renderer.\n    \"\"\"\n    return self._figure\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.get_remote_renderer_name","title":"<code>get_remote_renderer_name() -&gt; Literal['matplotlib', 'datoviz']</code>","text":"<p>Get the name of the remote renderer being used.</p> <p>Returns:</p> Type Description <code>typing.Literal['matplotlib', 'datoviz']</code> <p>Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def get_remote_renderer_name(self) -&gt; Literal[\"matplotlib\", \"datoviz\"]:\n    \"\"\"Get the name of the remote renderer being used.\n\n    Returns:\n        Literal[\"matplotlib\", \"datoviz\"]: The name of the remote renderer.\n    \"\"\"\n    return self._remote_renderer_name\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.render","title":"<code>render(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; bytes</code>","text":"<p>Render the scene remotely and update the matplotlib figure with the rendered image.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>The viewports to render.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>The visuals to render.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>The model matrices for the visuals.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>The cameras to use for rendering.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The rendered image data in PNG format.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the network request fails.</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def render(\n    self,\n    viewports: Sequence[Viewport],\n    visuals: Sequence[VisualBase],\n    model_matrices: Sequence[TransBuf],\n    cameras: Sequence[Camera],\n) -&gt; bytes:\n    \"\"\"Render the scene remotely and update the matplotlib figure with the rendered image.\n\n    Args:\n        viewports (Sequence[Viewport]): The viewports to render.\n        visuals (Sequence[VisualBase]): The visuals to render.\n        model_matrices (Sequence[TransBuf]): The model matrices for the visuals.\n        cameras (Sequence[Camera]): The cameras to use for rendering.\n\n    Returns:\n        bytes: The rendered image data in PNG format.\n\n    Raises:\n        Exception: If the network request fails.\n    \"\"\"\n    # =============================================================================\n    # Serialize the scene and create the payload\n    # =============================================================================\n    pydanticSerializer = PydanticSerializer(self._canvas)\n    pydantic_scene_dict = pydanticSerializer.serialize(\n        viewports=viewports,\n        visuals=visuals,\n        model_matrices=model_matrices,\n        cameras=cameras,\n    )\n\n    payload: NetworkPayload = {\n        \"renderer_name\": self._remote_renderer_name,\n        \"data\": pydantic_scene_dict,\n    }\n\n    # =============================================================================\n    # do network request to send the payload and get the rendered image\n    # =============================================================================\n    # Send the POST request with JSON data\n    call_url = f\"{self._server_base_url}/render\"\n    headers = {\"Content-Type\": \"application/json\"}\n    response = requests.post(call_url, data=json.dumps(payload), headers=headers)\n\n    # Check the response status\n    if response.status_code != HttpStatus.OK:\n        raise Exception(f\"Request failed with status code {response.status_code}\")\n    image_png_data = response.content\n\n    # =============================================================================\n    # Render the image in the matplotlib figure\n    # =============================================================================\n    assert self._axes_image is not None, \"PANIC self._axes_image is None\"\n    # update the image data\n    image_data_io = io.BytesIO(image_png_data)\n    image_data_np = matplotlib.image.imread(image_data_io, format=\"png\")\n    self._axes_image.set_data(image_data_np)\n\n    # return png data as bytes\n    return image_png_data\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.renderer.network_renderer.NetworkRenderer.show","title":"<code>show() -&gt; None</code>","text":"<p>Show the rendered canvas (blocking call).</p> Source code in <code>src/gsp_network/renderer/network_renderer.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the rendered canvas (blocking call).\"\"\"\n    # handle non-interactive mode for tests\n    in_test = os.environ.get(\"GSP_TEST\") == \"True\"\n    if in_test:\n        return\n\n    matplotlib.pyplot.show()\n</code></pre>"},{"location":"api/gsp_network/#tools-module","title":"Tools Module","text":"<p>The tools module provides server utilities for network-based rendering.</p>"},{"location":"api/gsp_network/#gsp_network.tools","title":"<code>gsp_network.tools</code>","text":"<p>tools package initialization.</p>"},{"location":"api/gsp_network/#network-server","title":"Network Server","text":""},{"location":"api/gsp_network/#gsp_network.tools.network_server","title":"<code>gsp_network.tools.network_server</code>","text":"<p>Server example using Flask to render a scene from JSON input.</p> <ul> <li>use Flask to create a simple web server</li> <li>render with matplotlib or datoviz based on environment variable</li> </ul>"},{"location":"api/gsp_network/#gsp_network.tools.network_server.ServerSample","title":"<code>ServerSample</code>","text":"<p>Sample class to demonstrate server functionality.</p> Source code in <code>src/gsp_network/tools/network_server.py</code> <pre><code>class ServerSample:\n    \"\"\"Sample class to demonstrate server functionality.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize the server sample.\"\"\"\n        pass\n\n    def run(self):\n        \"\"\"Run the Flask server.\"\"\"\n        flask_app.run(threaded=False, debug=False)  # Enable debug mode if desired\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.tools.network_server.ServerSample.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the server sample.</p> Source code in <code>src/gsp_network/tools/network_server.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the server sample.\"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.tools.network_server.ServerSample.run","title":"<code>run()</code>","text":"<p>Run the Flask server.</p> Source code in <code>src/gsp_network/tools/network_server.py</code> <pre><code>def run(self):\n    \"\"\"Run the Flask server.\"\"\"\n    flask_app.run(threaded=False, debug=False)  # Enable debug mode if desired\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.tools.network_server.render_scene_json","title":"<code>render_scene_json() -&gt; Response</code>","text":"<p>Flask route to render a scene from JSON input.</p> <p>Returns:</p> Name Type Description <code>Response</code> <code>flask.Response</code> <p>Flask response containing the rendered PNG image.</p> Source code in <code>src/gsp_network/tools/network_server.py</code> <pre><code>@flask_app.route(\"/render\", methods=[\"POST\"])\ndef render_scene_json() -&gt; Response:\n    \"\"\"Flask route to render a scene from JSON input.\n\n    Returns:\n        Response: Flask response containing the rendered PNG image.\n    \"\"\"\n    payload: NetworkPayload = request.get_json()\n\n    # Log the received payload for debugging\n    print(\"Received payload\")\n\n    ###############################################################################\n    # Load the scene from JSON\n    #\n\n    pydanticDict: PydanticDict = payload[\"data\"]\n\n    pydanticParser = PydanticParser()\n    parsed_canvas, parsed_viewports, parsed_visuals, parsed_model_matrices, parsed_cameras = pydanticParser.parse(pydanticDict)\n\n    ###############################################################################\n    # Render the loaded scene with matplotlib or datoviz based on environment variable\n    #\n    renderer_name = payload[\"renderer_name\"]\n    if renderer_name == \"matplotlib\":\n        renderer = MatplotlibRenderer(parsed_canvas)\n    else:\n        renderer = DatovizRenderer(parsed_canvas, offscreen=True)\n    image_png_data = renderer.render(parsed_viewports, parsed_visuals, parsed_model_matrices, parsed_cameras, return_image=True)\n\n    print(f\"Rendered image size: {text_cyan(str(len(image_png_data)))} bytes\")\n\n    ###############################################################################\n    # Return the rendered image as a PNG file\n    #\n    return send_file(\n        io.BytesIO(image_png_data),\n        mimetype=\"image/png\",\n        as_attachment=True,\n        download_name=\"rendered_scene.png\",\n    )\n</code></pre>"},{"location":"api/gsp_network/#gsp_network.tools.network_server.text_cyan","title":"<code>text_cyan(text: str) -&gt; str</code>","text":"<p>Return the given text string wrapped in ANSI escape codes for cyan color.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to color.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The colored text string.</p> Source code in <code>src/gsp_network/tools/network_server.py</code> <pre><code>def text_cyan(text: str) -&gt; str:\n    \"\"\"Return the given text string wrapped in ANSI escape codes for cyan color.\n\n    Args:\n        text (str): The text to color.\n\n    Returns:\n        str: The colored text string.\n    \"\"\"\n    return colorama.Fore.CYAN + text + colorama.Style.RESET_ALL\n</code></pre>"},{"location":"api/gsp_network/#network-server-kill","title":"Network Server Kill","text":""},{"location":"api/gsp_network/#gsp_network.tools.network_server_kill","title":"<code>gsp_network.tools.network_server_kill</code>","text":"<p>Kill any process using port 5000 (commonly used for flask server).</p> <p>in shell: <code>lsof -ti tcp:5000 | xargs kill</code></p>"},{"location":"api/gsp_network/#gsp_network.tools.network_server_kill.main","title":"<code>main() -&gt; int</code>","text":"<p>Main function to kill processes using port 5000.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Exit code (0 for success, 1 for failure).</p> Source code in <code>src/gsp_network/tools/network_server_kill.py</code> <pre><code>def main() -&gt; int:\n    \"\"\"Main function to kill processes using port 5000.\n\n    Returns:\n        int: Exit code (0 for success, 1 for failure).\n    \"\"\"\n    # parse command line arguments\n    parser = argparse.ArgumentParser(description=\"Kill any process using port 5000 (commonly used for flask server).\")\n    _ = parser.parse_args()\n\n    port = 5000\n\n    try:\n        # Get the list of process IDs using the specified port\n        result = subprocess.run([\"lsof\", \"-ti\", f\"tcp:{port}\"], capture_output=True, text=True)\n        pids = result.stdout.strip().split(\"\\n\")\n\n        if pids == [\"\"]:\n            print(f\"No processes found using port {port}.\")\n            return 0\n\n        for pid in pids:\n            os.kill(int(pid), signal.SIGTERM)\n            print(f\"Killed process with PID: {pid} using port {port}.\")\n\n        return 0\n\n    except Exception as error:\n        print(f\"An error occurred: {error}\")\n        return 1\n</code></pre>"},{"location":"api/gsp_pydantic/","title":"GSP Pydantic API Reference","text":"<p>The GSP Pydantic module provides serialization and deserialization capabilities using Pydantic models, enabling data validation and JSON schema generation for GSP objects.</p>"},{"location":"api/gsp_pydantic/#overview","title":"Overview","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic","title":"<code>gsp_pydantic</code>","text":"<p>GSP Pydantic package initialization.</p>"},{"location":"api/gsp_pydantic/#serializer-module","title":"Serializer Module","text":"<p>The serializer module contains the serialization and parsing utilities for converting GSP objects to and from Pydantic models.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer","title":"<code>gsp_pydantic.serializer</code>","text":"<p>Pydantic serializer and parser for GSP data structures.</p>"},{"location":"api/gsp_pydantic/#pydantic-serializer","title":"Pydantic Serializer","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_serializer","title":"<code>gsp_pydantic.serializer.pydantic_serializer</code>","text":"<p>Pydantic serializer for GSP data structures.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_serializer.PydanticSerializer","title":"<code>PydanticSerializer</code>","text":"<p>               Bases: <code>gsp.types.serializer_base.SerializerBase</code></p> <p>Serializer that converts GSP data structures into Pydantic models.</p> Source code in <code>src/gsp_pydantic/serializer/pydantic_serializer.py</code> <pre><code>class PydanticSerializer(SerializerBase):\n    \"\"\"Serializer that converts GSP data structures into Pydantic models.\"\"\"\n\n    def __init__(self, canvas: Canvas):\n        \"\"\"Initialize the PydanticSerializer with a canvas.\n\n        Args:\n            canvas (Canvas): The canvas to be used in the serialization.\n        \"\"\"\n        self._canvas = canvas\n\n    def serialize(\n        self,\n        viewports: Sequence[Viewport],\n        visuals: Sequence[VisualBase],\n        model_matrices: Sequence[TransBuf],\n        cameras: Sequence[Camera],\n    ) -&gt; PydanticDict:\n        \"\"\"Serialize the provided GSP data structures into a PydanticDict.\n\n        Args:\n            viewports (Sequence[Viewport]): The list of viewports to serialize.\n            visuals (Sequence[VisualBase]): The list of visual elements to serialize.\n            model_matrices (Sequence[TransBuf]): The list of model transformation matrices to serialize.\n            cameras (Sequence[Camera]): The list of cameras to serialize.\n\n        Returns:\n            PydanticDict: The serialized data as a PydanticDict.\n        \"\"\"\n        # =============================================================================\n        #\n        # =============================================================================\n\n        pydanticCanvas = PydanticCanvas(\n            uuid=self._canvas.get_uuid(),\n            width=self._canvas.get_width(),\n            height=self._canvas.get_height(),\n            dpi=self._canvas.get_dpi(),\n        )\n\n        pydanticViewports = [\n            PydanticViewport(\n                uuid=viewport.get_uuid(),\n                x=viewport.get_x(),\n                y=viewport.get_y(),\n                width=viewport.get_width(),\n                height=viewport.get_height(),\n            )\n            for viewport in viewports\n        ]\n\n        pydantic_visuals = PydanticSerializer._visuals_to_pydantic(visuals)\n\n        pydantic_model_matrices = [PydanticModelMatrix(model_matrix=PydanticSerializer._transbuf_to_pydantic(model_matrix)) for model_matrix in model_matrices]\n\n        pydantic_cameras = [\n            PydanticCamera(\n                uuid=camera.get_uuid(),\n                view_matrix=PydanticSerializer._transbuf_to_pydantic(camera.get_view_matrix()),\n                projection_matrix=PydanticSerializer._transbuf_to_pydantic(camera.get_projection_matrix()),\n            )\n            for camera in cameras\n        ]\n\n        # =============================================================================\n        #\n        # =============================================================================\n\n        pydantic_scene = PydanticScene(\n            canvas=pydanticCanvas,\n            viewports=pydanticViewports,\n            visuals=pydantic_visuals,\n            model_matrices=pydantic_model_matrices,\n            cameras=pydantic_cameras,\n        )\n\n        pydantic_scene_dict: PydanticDict = pydantic_scene.model_dump()\n\n        return pydantic_scene_dict  # Placeholder for JSON byte output\n\n    # =============================================================================\n    # Static methods\n    # =============================================================================\n\n    @staticmethod\n    def _visuals_to_pydantic(visuals: Sequence[VisualBase]) -&gt; list[PydanticVisual]:\n        pydantic_visuals: list[PydanticVisual] = []\n        for visual in visuals:\n            if isinstance(visual, Markers):\n                markers = typing.cast(Markers, visual)\n                pydantic_visual = PydanticVisual(\n                    type=\"markers\",\n                    visual=PydanticMarkers(\n                        uuid=markers.get_uuid(),\n                        marker_shape=markers.get_marker_shape().name,\n                        positions=PydanticSerializer._transbuf_to_pydantic(markers.get_positions()),\n                        sizes=PydanticSerializer._transbuf_to_pydantic(markers.get_sizes()),\n                        face_colors=PydanticSerializer._transbuf_to_pydantic(markers.get_face_colors()),\n                        edge_colors=PydanticSerializer._transbuf_to_pydantic(markers.get_edge_colors()),\n                        edge_widths=PydanticSerializer._transbuf_to_pydantic(markers.get_edge_widths()),\n                    ),\n                )\n                pydantic_visuals.append(pydantic_visual)\n            elif isinstance(visual, Paths):\n                paths = typing.cast(Paths, visual)\n                pydantic_visual = PydanticVisual(\n                    type=\"paths\",\n                    visual=PydanticPaths(\n                        uuid=paths.get_uuid(),\n                        positions=PydanticSerializer._transbuf_to_pydantic(paths.get_positions()),\n                        path_sizes=PydanticSerializer._transbuf_to_pydantic(paths.get_path_sizes()),\n                        colors=PydanticSerializer._transbuf_to_pydantic(paths.get_colors()),\n                        line_widths=PydanticSerializer._transbuf_to_pydantic(paths.get_line_widths()),\n                        cap_style=paths.get_cap_style().name,\n                        join_style=paths.get_join_style().name,\n                    ),\n                )\n                pydantic_visuals.append(pydantic_visual)\n            elif isinstance(visual, Pixels):\n                pixels = typing.cast(Pixels, visual)\n                pydantic_visual = PydanticVisual(\n                    type=\"pixels\",\n                    visual=PydanticPixels(\n                        uuid=pixels.get_uuid(),\n                        positions=PydanticSerializer._transbuf_to_pydantic(pixels.get_positions()),\n                        colors=PydanticSerializer._transbuf_to_pydantic(pixels.get_colors()),\n                        groups=pixels.get_groups(),\n                    ),\n                )\n                pydantic_visuals.append(pydantic_visual)\n            elif isinstance(visual, Points):\n                points = typing.cast(Points, visual)\n                pydantic_visual = PydanticVisual(\n                    type=\"points\",\n                    visual=PydanticPoints(\n                        uuid=points.get_uuid(),\n                        positions=PydanticSerializer._transbuf_to_pydantic(points.get_positions()),\n                        sizes=PydanticSerializer._transbuf_to_pydantic(points.get_sizes()),\n                        face_colors=PydanticSerializer._transbuf_to_pydantic(points.get_face_colors()),\n                        edge_colors=PydanticSerializer._transbuf_to_pydantic(points.get_edge_colors()),\n                        edge_widths=PydanticSerializer._transbuf_to_pydantic(points.get_edge_widths()),\n                    ),\n                )\n                pydantic_visuals.append(pydantic_visual)\n            elif isinstance(visual, Segments):\n                segments = typing.cast(Segments, visual)\n                pydantic_visual = PydanticVisual(\n                    type=\"segments\",\n                    visual=PydanticSegments(\n                        uuid=segments.get_uuid(),\n                        positions=PydanticSerializer._transbuf_to_pydantic(segments.get_positions()),\n                        line_widths=PydanticSerializer._transbuf_to_pydantic(segments.get_line_widths()),\n                        cap_style=segments.get_cap_style().name,\n                        colors=PydanticSerializer._transbuf_to_pydantic(segments.get_colors()),\n                    ),\n                )\n                pydantic_visuals.append(pydantic_visual)\n            elif isinstance(visual, Texts):\n                texts = typing.cast(Texts, visual)\n                pydantic_visual = PydanticVisual(\n                    type=\"texts\",\n                    visual=PydanticTexts(\n                        uuid=texts.get_uuid(),\n                        positions=PydanticSerializer._transbuf_to_pydantic(texts.get_positions()),\n                        texts=texts.get_strings(),\n                        colors=PydanticSerializer._transbuf_to_pydantic(texts.get_colors()),\n                        font_sizes=PydanticSerializer._transbuf_to_pydantic(texts.get_font_sizes()),\n                        anchors=PydanticSerializer._transbuf_to_pydantic(texts.get_anchors()),\n                        angles=PydanticSerializer._transbuf_to_pydantic(texts.get_angles()),\n                        font_name=texts.get_font_name(),\n                    ),\n                )\n                pydantic_visuals.append(pydantic_visual)\n            else:\n                raise NotImplementedError(f\"Serialization for this Visual type {type(visual)} is not implemented yet\")\n\n        # return the list of pydantic visuals\n        return pydantic_visuals\n\n    @staticmethod\n    def _transbuf_to_pydantic(transbuf: TransBuf) -&gt; PydanticTransBuf:\n        if isinstance(transbuf, Buffer):\n            buffer = typing.cast(Buffer, transbuf)\n            pydantic_transbuf = PydanticTransBuf(\n                type=\"buffer\",\n                transBuf=PydanticBuffer(\n                    count=buffer.get_count(),\n                    buffer_type=buffer.get_type().name,\n                    data_base64=base64.b64encode(buffer.to_bytearray()).decode(\"utf-8\"),\n                ),\n            )\n            return pydantic_transbuf\n        elif isinstance(transbuf, TransformChain):\n            transform_chain = typing.cast(TransformChain, transbuf)\n            pydantic_transbuf = PydanticTransBuf(\n                type=\"transform_chain\",\n                transBuf=PydanticTransformChain(\n                    transform_chain=transform_chain.serialize(),\n                ),\n            )\n            return pydantic_transbuf\n        else:\n            raise ValueError(\"Unknown TransBuf type\")\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_serializer.PydanticSerializer.__init__","title":"<code>__init__(canvas: Canvas)</code>","text":"<p>Initialize the PydanticSerializer with a canvas.</p> <p>Parameters:</p> Name Type Description Default <code>canvas</code> <code>gsp.core.canvas.Canvas</code> <p>The canvas to be used in the serialization.</p> required Source code in <code>src/gsp_pydantic/serializer/pydantic_serializer.py</code> <pre><code>def __init__(self, canvas: Canvas):\n    \"\"\"Initialize the PydanticSerializer with a canvas.\n\n    Args:\n        canvas (Canvas): The canvas to be used in the serialization.\n    \"\"\"\n    self._canvas = canvas\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_serializer.PydanticSerializer.serialize","title":"<code>serialize(viewports: Sequence[Viewport], visuals: Sequence[VisualBase], model_matrices: Sequence[TransBuf], cameras: Sequence[Camera]) -&gt; PydanticDict</code>","text":"<p>Serialize the provided GSP data structures into a PydanticDict.</p> <p>Parameters:</p> Name Type Description Default <code>viewports</code> <code>typing.Sequence[gsp.core.viewport.Viewport]</code> <p>The list of viewports to serialize.</p> required <code>visuals</code> <code>typing.Sequence[gsp.types.visual_base.VisualBase]</code> <p>The list of visual elements to serialize.</p> required <code>model_matrices</code> <code>typing.Sequence[gsp.types.transbuf.TransBuf]</code> <p>The list of model transformation matrices to serialize.</p> required <code>cameras</code> <code>typing.Sequence[gsp.core.camera.Camera]</code> <p>The list of cameras to serialize.</p> required <p>Returns:</p> Name Type Description <code>PydanticDict</code> <code>gsp_pydantic.types.pydantic_dict.PydanticDict</code> <p>The serialized data as a PydanticDict.</p> Source code in <code>src/gsp_pydantic/serializer/pydantic_serializer.py</code> <pre><code>def serialize(\n    self,\n    viewports: Sequence[Viewport],\n    visuals: Sequence[VisualBase],\n    model_matrices: Sequence[TransBuf],\n    cameras: Sequence[Camera],\n) -&gt; PydanticDict:\n    \"\"\"Serialize the provided GSP data structures into a PydanticDict.\n\n    Args:\n        viewports (Sequence[Viewport]): The list of viewports to serialize.\n        visuals (Sequence[VisualBase]): The list of visual elements to serialize.\n        model_matrices (Sequence[TransBuf]): The list of model transformation matrices to serialize.\n        cameras (Sequence[Camera]): The list of cameras to serialize.\n\n    Returns:\n        PydanticDict: The serialized data as a PydanticDict.\n    \"\"\"\n    # =============================================================================\n    #\n    # =============================================================================\n\n    pydanticCanvas = PydanticCanvas(\n        uuid=self._canvas.get_uuid(),\n        width=self._canvas.get_width(),\n        height=self._canvas.get_height(),\n        dpi=self._canvas.get_dpi(),\n    )\n\n    pydanticViewports = [\n        PydanticViewport(\n            uuid=viewport.get_uuid(),\n            x=viewport.get_x(),\n            y=viewport.get_y(),\n            width=viewport.get_width(),\n            height=viewport.get_height(),\n        )\n        for viewport in viewports\n    ]\n\n    pydantic_visuals = PydanticSerializer._visuals_to_pydantic(visuals)\n\n    pydantic_model_matrices = [PydanticModelMatrix(model_matrix=PydanticSerializer._transbuf_to_pydantic(model_matrix)) for model_matrix in model_matrices]\n\n    pydantic_cameras = [\n        PydanticCamera(\n            uuid=camera.get_uuid(),\n            view_matrix=PydanticSerializer._transbuf_to_pydantic(camera.get_view_matrix()),\n            projection_matrix=PydanticSerializer._transbuf_to_pydantic(camera.get_projection_matrix()),\n        )\n        for camera in cameras\n    ]\n\n    # =============================================================================\n    #\n    # =============================================================================\n\n    pydantic_scene = PydanticScene(\n        canvas=pydanticCanvas,\n        viewports=pydanticViewports,\n        visuals=pydantic_visuals,\n        model_matrices=pydantic_model_matrices,\n        cameras=pydantic_cameras,\n    )\n\n    pydantic_scene_dict: PydanticDict = pydantic_scene.model_dump()\n\n    return pydantic_scene_dict  # Placeholder for JSON byte output\n</code></pre>"},{"location":"api/gsp_pydantic/#pydantic-parser","title":"Pydantic Parser","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_parser","title":"<code>gsp_pydantic.serializer.pydantic_parser</code>","text":"<p>Pydantic parser for GSP data structures.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_parser.PydanticParser","title":"<code>PydanticParser</code>","text":"<p>Parser that converts Pydantic models into GSP data structures.</p> Source code in <code>src/gsp_pydantic/serializer/pydantic_parser.py</code> <pre><code>class PydanticParser:\n    \"\"\"Parser that converts Pydantic models into GSP data structures.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize the PydanticParser.\"\"\"\n        pass\n\n    def parse(self, json_dict: PydanticDict) -&gt; tuple[\n        Canvas,\n        list[Viewport],\n        list[VisualBase],\n        list[TransBuf],\n        list[Camera],\n    ]:\n        \"\"\"Parse a Pydantic JSON dictionary into GSP data structures.\n\n        Args:\n            json_dict (PydanticDict): The Pydantic JSON dictionary representing the scene.\n\n        Returns:\n            tuple[\n                Canvas,\n                list[Viewport],\n                list[VisualBase],\n                list[TransBuf],\n                list[Camera],\n            ]: The parsed GSP data structures.\n        \"\"\"\n        json_str = json.dumps(json_dict, indent=4)\n        pydantic_scene = PydanticScene.model_validate(pydantic_core.from_json(json_str, allow_partial=True))\n\n        # =============================================================================\n        # Parse Pydantic Canvas\n        # =============================================================================\n        pydantic_canvas = pydantic_scene.canvas\n        canvas = Canvas(pydantic_canvas.width, pydantic_canvas.height, pydantic_canvas.dpi)\n        canvas._uuid = pydantic_canvas.uuid\n\n        # =============================================================================\n        # Parse Pydantic Viewports\n        # =============================================================================\n        viewports: list[Viewport] = []  # Placeholder implementation\n        for pydantic_viewport in pydantic_scene.viewports:\n            viewport = Viewport(\n                pydantic_viewport.x,\n                pydantic_viewport.y,\n                pydantic_viewport.width,\n                pydantic_viewport.height,\n            )\n            viewport._uuid = pydantic_viewport.uuid\n            viewports.append(viewport)\n\n        # =============================================================================\n        # Parse Pydantic Visuals\n        # =============================================================================\n        visuals: list[VisualBase] = []  # Placeholder implementation\n        for pydantic_visual in pydantic_scene.visuals:\n            visual = PydanticParser._pydantic_to_visual(pydantic_visual)\n            visuals.append(visual)\n\n        # =============================================================================\n        # Parse Pydantic Model Matrices\n        # =============================================================================\n        model_matrices: list[TransBuf] = []  # Placeholder implementation\n        for pydantic_model_matrix in pydantic_scene.model_matrices:\n            model_matrix = PydanticParser._pydantic_to_transbuf(pydantic_model_matrix.model_matrix)\n            model_matrices.append(model_matrix)\n\n        # =============================================================================\n        # Parse Pydanticy Cameras\n        # =============================================================================\n        cameras: list[Camera] = []\n        for pydantic_camera in pydantic_scene.cameras:\n            view_matrix = PydanticParser._pydantic_to_transbuf(pydantic_camera.view_matrix)\n            projection_matrix = PydanticParser._pydantic_to_transbuf(pydantic_camera.projection_matrix)\n            camera = Camera(view_matrix, projection_matrix)\n            camera._uuid = pydantic_camera.uuid\n            cameras.append(camera)\n\n        # =============================================================================\n        # Return the renderer arguments\n        # =============================================================================\n        return canvas, viewports, visuals, model_matrices, cameras\n\n    @staticmethod\n    def _pydantic_to_visual(pydantic_visual: PydanticVisual) -&gt; VisualBase:\n        if pydantic_visual.type == \"markers\":\n            pydantic_markers = typing.cast(PydanticMarkers, pydantic_visual.visual)\n            marker_shape = MarkerShape[pydantic_markers.marker_shape]\n            positions = PydanticParser._pydantic_to_transbuf(pydantic_markers.positions)\n            sizes = PydanticParser._pydantic_to_transbuf(pydantic_markers.sizes)\n            face_colors = PydanticParser._pydantic_to_transbuf(pydantic_markers.face_colors)\n            edge_colors = PydanticParser._pydantic_to_transbuf(pydantic_markers.edge_colors)\n            edge_widths = PydanticParser._pydantic_to_transbuf(pydantic_markers.edge_widths)\n            markers = Markers(marker_shape, positions, sizes, face_colors, edge_colors, edge_widths)\n            markers._uuid = pydantic_markers.uuid\n            return markers\n        elif pydantic_visual.type == \"paths\":\n            pydantic_paths = typing.cast(PydanticPaths, pydantic_visual.visual)\n            positions = PydanticParser._pydantic_to_transbuf(pydantic_paths.positions)\n            path_sizes = PydanticParser._pydantic_to_transbuf(pydantic_paths.path_sizes)\n            colors = PydanticParser._pydantic_to_transbuf(pydantic_paths.colors)\n            line_widths = PydanticParser._pydantic_to_transbuf(pydantic_paths.line_widths)\n            cap_style = CapStyle[pydantic_paths.cap_style]\n            join_style = JoinStyle[pydantic_paths.join_style]\n            paths = Paths(positions, path_sizes, colors, line_widths, cap_style, join_style)\n            paths._uuid = pydantic_paths.uuid\n            return paths\n        elif pydantic_visual.type == \"pixels\":\n            pydantic_pixels = typing.cast(PydanticPixels, pydantic_visual.visual)\n            positions = PydanticParser._pydantic_to_transbuf(pydantic_pixels.positions)\n            colors = PydanticParser._pydantic_to_transbuf(pydantic_pixels.colors)\n            groups = pydantic_pixels.groups\n            pixels = Pixels(positions, colors, groups)\n            pixels._uuid = pydantic_pixels.uuid\n            return pixels\n        elif pydantic_visual.type == \"points\":\n            pydantic_points = typing.cast(PydanticPoints, pydantic_visual.visual)\n            positions = PydanticParser._pydantic_to_transbuf(pydantic_points.positions)\n            sizes = PydanticParser._pydantic_to_transbuf(pydantic_points.sizes)\n            face_colors = PydanticParser._pydantic_to_transbuf(pydantic_points.face_colors)\n            edge_colors = PydanticParser._pydantic_to_transbuf(pydantic_points.edge_colors)\n            edge_widths = PydanticParser._pydantic_to_transbuf(pydantic_points.edge_widths)\n            points = Points(positions, sizes, face_colors, edge_colors, edge_widths)\n            points._uuid = pydantic_points.uuid\n            return points\n        elif pydantic_visual.type == \"segments\":\n            pydantic_segments = typing.cast(PydanticSegments, pydantic_visual.visual)\n            positions = PydanticParser._pydantic_to_transbuf(pydantic_segments.positions)\n            line_widths = PydanticParser._pydantic_to_transbuf(pydantic_segments.line_widths)\n            cap_style = CapStyle[pydantic_segments.cap_style]\n            colors = PydanticParser._pydantic_to_transbuf(pydantic_segments.colors)\n            segments = Segments(positions, line_widths, cap_style, colors)\n            segments._uuid = pydantic_segments.uuid\n            return segments\n        elif pydantic_visual.type == \"texts\":\n            pydantic_texts = typing.cast(PydanticTexts, pydantic_visual.visual)\n            positions = PydanticParser._pydantic_to_transbuf(pydantic_texts.positions)\n            texts_list = pydantic_texts.texts\n            colors = PydanticParser._pydantic_to_transbuf(pydantic_texts.colors)\n            font_sizes = PydanticParser._pydantic_to_transbuf(pydantic_texts.font_sizes)\n            anchors = PydanticParser._pydantic_to_transbuf(pydantic_texts.anchors)\n            angles = PydanticParser._pydantic_to_transbuf(pydantic_texts.angles)\n            font_name = pydantic_texts.font_name\n            texts = Texts(positions, texts_list, colors, font_sizes, anchors, angles, font_name)\n            texts._uuid = pydantic_texts.uuid\n            return texts\n        else:\n            raise ValueError(f\"Unknown PydanticVisual type: {pydantic_visual.type}\")\n\n    @staticmethod\n    def _pydantic_to_transbuf(pydantic_transbuf: PydanticTransBuf) -&gt; TransBuf:\n        if pydantic_transbuf.type == \"buffer\":\n            pydantic_buffer = typing.cast(PydanticBuffer, pydantic_transbuf.transBuf)\n            count = pydantic_buffer.count\n            buffer_type = BufferType[pydantic_buffer.buffer_type]\n            buffer_data = bytearray(base64.b64decode(pydantic_buffer.data_base64))\n            buffer = Buffer.from_bytearray(buffer_data, buffer_type)\n            assert buffer.get_count() == count, f\"Buffer count mismatch: expected {count}, got {buffer.get_count()}\"\n            return buffer\n        elif pydantic_transbuf.type == \"transform_chain\":\n            pydantic_transform_chain = typing.cast(PydanticTransformChain, pydantic_transbuf.transBuf)\n            deserialized_transform = TransformChain.deserialize(pydantic_transform_chain.transform_chain)\n            buffer = deserialized_transform.run()\n            return buffer\n        else:\n            raise ValueError(f\"Unknown PydanticTransBuf type: {pydantic_transbuf.type}\")\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_parser.PydanticParser.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the PydanticParser.</p> Source code in <code>src/gsp_pydantic/serializer/pydantic_parser.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the PydanticParser.\"\"\"\n    pass\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.serializer.pydantic_parser.PydanticParser.parse","title":"<code>parse(json_dict: PydanticDict) -&gt; tuple[Canvas, list[Viewport], list[VisualBase], list[TransBuf], list[Camera]]</code>","text":"<p>Parse a Pydantic JSON dictionary into GSP data structures.</p> <p>Parameters:</p> Name Type Description Default <code>json_dict</code> <code>gsp_pydantic.types.pydantic_dict.PydanticDict</code> <p>The Pydantic JSON dictionary representing the scene.</p> required <p>Returns:</p> Type Description <code>gsp.core.canvas.Canvas</code> <p>tuple[ Canvas, list[Viewport], list[VisualBase], list[TransBuf], list[Camera],</p> <code>list[gsp.core.viewport.Viewport]</code> <p>]: The parsed GSP data structures.</p> Source code in <code>src/gsp_pydantic/serializer/pydantic_parser.py</code> <pre><code>def parse(self, json_dict: PydanticDict) -&gt; tuple[\n    Canvas,\n    list[Viewport],\n    list[VisualBase],\n    list[TransBuf],\n    list[Camera],\n]:\n    \"\"\"Parse a Pydantic JSON dictionary into GSP data structures.\n\n    Args:\n        json_dict (PydanticDict): The Pydantic JSON dictionary representing the scene.\n\n    Returns:\n        tuple[\n            Canvas,\n            list[Viewport],\n            list[VisualBase],\n            list[TransBuf],\n            list[Camera],\n        ]: The parsed GSP data structures.\n    \"\"\"\n    json_str = json.dumps(json_dict, indent=4)\n    pydantic_scene = PydanticScene.model_validate(pydantic_core.from_json(json_str, allow_partial=True))\n\n    # =============================================================================\n    # Parse Pydantic Canvas\n    # =============================================================================\n    pydantic_canvas = pydantic_scene.canvas\n    canvas = Canvas(pydantic_canvas.width, pydantic_canvas.height, pydantic_canvas.dpi)\n    canvas._uuid = pydantic_canvas.uuid\n\n    # =============================================================================\n    # Parse Pydantic Viewports\n    # =============================================================================\n    viewports: list[Viewport] = []  # Placeholder implementation\n    for pydantic_viewport in pydantic_scene.viewports:\n        viewport = Viewport(\n            pydantic_viewport.x,\n            pydantic_viewport.y,\n            pydantic_viewport.width,\n            pydantic_viewport.height,\n        )\n        viewport._uuid = pydantic_viewport.uuid\n        viewports.append(viewport)\n\n    # =============================================================================\n    # Parse Pydantic Visuals\n    # =============================================================================\n    visuals: list[VisualBase] = []  # Placeholder implementation\n    for pydantic_visual in pydantic_scene.visuals:\n        visual = PydanticParser._pydantic_to_visual(pydantic_visual)\n        visuals.append(visual)\n\n    # =============================================================================\n    # Parse Pydantic Model Matrices\n    # =============================================================================\n    model_matrices: list[TransBuf] = []  # Placeholder implementation\n    for pydantic_model_matrix in pydantic_scene.model_matrices:\n        model_matrix = PydanticParser._pydantic_to_transbuf(pydantic_model_matrix.model_matrix)\n        model_matrices.append(model_matrix)\n\n    # =============================================================================\n    # Parse Pydanticy Cameras\n    # =============================================================================\n    cameras: list[Camera] = []\n    for pydantic_camera in pydantic_scene.cameras:\n        view_matrix = PydanticParser._pydantic_to_transbuf(pydantic_camera.view_matrix)\n        projection_matrix = PydanticParser._pydantic_to_transbuf(pydantic_camera.projection_matrix)\n        camera = Camera(view_matrix, projection_matrix)\n        camera._uuid = pydantic_camera.uuid\n        cameras.append(camera)\n\n    # =============================================================================\n    # Return the renderer arguments\n    # =============================================================================\n    return canvas, viewports, visuals, model_matrices, cameras\n</code></pre>"},{"location":"api/gsp_pydantic/#types-module","title":"Types Module","text":"<p>The types module defines Pydantic models for GSP data structures, providing validation and schema generation.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types","title":"<code>gsp_pydantic.types</code>","text":"<p>Pydantic types for GSP data structures.</p>"},{"location":"api/gsp_pydantic/#pydantic-dict","title":"Pydantic Dict","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_dict","title":"<code>gsp_pydantic.types.pydantic_dict</code>","text":"<p>Pydantic type for a dictionary with string keys and any values.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_dict.PydanticDict","title":"<code>PydanticDict = Dict[str, Any]</code>  <code>module-attribute</code>","text":"<p>Type alias for a dictionary with string keys and any values.</p>"},{"location":"api/gsp_pydantic/#pydantic-types","title":"Pydantic Types","text":""},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types","title":"<code>gsp_pydantic.types.pydantic_types</code>","text":"<p>\"Pydantic models for GSP data types.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticGroups","title":"<code>PydanticGroups = Union[int, list[int], list[list[int]]]</code>  <code>module-attribute</code>","text":"<p>Type alias for groups which can be an int, a list of ints, or a list of list of ints.</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticBuffer","title":"<code>PydanticBuffer</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a buffer with encoded data.</p> <p>This class stores buffer data in a serializable format using base64 encoding.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticBuffer(BaseModel):\n    \"\"\"Pydantic model representing a buffer with encoded data.\n\n    This class stores buffer data in a serializable format using base64 encoding.\n    \"\"\"\n\n    count: int\n    \"\"\"number of elements in the buffer\"\"\"\n    buffer_type: str\n    \"\"\"type of the buffer elements, corresponds to BufferType enum value\"\"\"\n    data_base64: str\n    \"\"\"data encoded in base64 format\"\"\"\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticBuffer.buffer_type","title":"<code>buffer_type: str</code>  <code>instance-attribute</code>","text":"<p>type of the buffer elements, corresponds to BufferType enum value</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticBuffer.count","title":"<code>count: int</code>  <code>instance-attribute</code>","text":"<p>number of elements in the buffer</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticBuffer.data_base64","title":"<code>data_base64: str</code>  <code>instance-attribute</code>","text":"<p>data encoded in base64 format</p>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticCamera","title":"<code>PydanticCamera</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a camera.</p> <p>Defines the camera's view and projection transformations for rendering the scene.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticCamera(BaseModel):\n    \"\"\"Pydantic model representing a camera.\n\n    Defines the camera's view and projection transformations for rendering the scene.\n    \"\"\"\n\n    uuid: str\n    view_matrix: PydanticTransBuf\n    projection_matrix: PydanticTransBuf\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticCanvas","title":"<code>PydanticCanvas</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a canvas for rendering.</p> <p>Defines the rendering surface with dimensions and resolution.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticCanvas(BaseModel):\n    \"\"\"Pydantic model representing a canvas for rendering.\n\n    Defines the rendering surface with dimensions and resolution.\n    \"\"\"\n\n    uuid: str\n    width: int\n    height: int\n    dpi: float\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticMarkers","title":"<code>PydanticMarkers</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing marker visual elements.</p> <p>Markers are geometric shapes (circles, squares, etc.) positioned in space with configurable appearance properties.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticMarkers(BaseModel):\n    \"\"\"Pydantic model representing marker visual elements.\n\n    Markers are geometric shapes (circles, squares, etc.) positioned in space\n    with configurable appearance properties.\n    \"\"\"\n\n    uuid: str\n    marker_shape: str\n    positions: PydanticTransBuf\n    sizes: PydanticTransBuf\n    face_colors: PydanticTransBuf\n    edge_colors: PydanticTransBuf\n    edge_widths: PydanticTransBuf\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticModelMatrix","title":"<code>PydanticModelMatrix</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a model transformation matrix.</p> <p>Contains the transformation matrix for positioning objects in the scene.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticModelMatrix(BaseModel):\n    \"\"\"Pydantic model representing a model transformation matrix.\n\n    Contains the transformation matrix for positioning objects in the scene.\n    \"\"\"\n\n    model_matrix: PydanticTransBuf\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticPaths","title":"<code>PydanticPaths</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing path visual elements.</p> <p>Paths are continuous lines or curves with configurable line styles and colors.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticPaths(BaseModel):\n    \"\"\"Pydantic model representing path visual elements.\n\n    Paths are continuous lines or curves with configurable line styles and colors.\n    \"\"\"\n\n    uuid: str\n    positions: PydanticTransBuf\n    path_sizes: PydanticTransBuf\n    colors: PydanticTransBuf\n    line_widths: PydanticTransBuf\n    cap_style: str\n    join_style: str\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticPixels","title":"<code>PydanticPixels</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing pixel visual elements.</p> <p>Pixels are individual colored points organized into groups.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticPixels(BaseModel):\n    \"\"\"Pydantic model representing pixel visual elements.\n\n    Pixels are individual colored points organized into groups.\n    \"\"\"\n\n    uuid: str\n    positions: PydanticTransBuf\n    colors: PydanticTransBuf\n    groups: PydanticGroups\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticPoints","title":"<code>PydanticPoints</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing point visual elements.</p> <p>Points are circular elements with configurable size and appearance, including face color, edge color, and edge width.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticPoints(BaseModel):\n    \"\"\"Pydantic model representing point visual elements.\n\n    Points are circular elements with configurable size and appearance,\n    including face color, edge color, and edge width.\n    \"\"\"\n\n    uuid: str\n    positions: PydanticTransBuf\n    sizes: PydanticTransBuf\n    face_colors: PydanticTransBuf\n    edge_colors: PydanticTransBuf\n    edge_widths: PydanticTransBuf\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticScene","title":"<code>PydanticScene</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a complete scene.</p> <p>Aggregates all scene elements including canvas, viewports, visual elements, transformation matrices, and cameras.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticScene(BaseModel):\n    \"\"\"Pydantic model representing a complete scene.\n\n    Aggregates all scene elements including canvas, viewports, visual elements,\n    transformation matrices, and cameras.\n    \"\"\"\n\n    canvas: PydanticCanvas\n    viewports: list[PydanticViewport]\n    visuals: list[PydanticVisual]\n    model_matrices: list[PydanticModelMatrix]\n    cameras: list[PydanticCamera]\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticSegments","title":"<code>PydanticSegments</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing line segment visual elements.</p> <p>Segments are individual line segments with configurable width, color, and cap style.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticSegments(BaseModel):\n    \"\"\"Pydantic model representing line segment visual elements.\n\n    Segments are individual line segments with configurable width, color, and cap style.\n    \"\"\"\n\n    uuid: str\n    positions: PydanticTransBuf\n    line_widths: PydanticTransBuf\n    cap_style: str\n    colors: PydanticTransBuf\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticTexts","title":"<code>PydanticTexts</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing text visual elements.</p> <p>Text elements with configurable position, font properties, colors, and orientation.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticTexts(BaseModel):\n    \"\"\"Pydantic model representing text visual elements.\n\n    Text elements with configurable position, font properties, colors, and orientation.\n    \"\"\"\n\n    uuid: str\n    positions: PydanticTransBuf\n    texts: list[str]\n    colors: PydanticTransBuf\n    font_sizes: PydanticTransBuf\n    anchors: PydanticTransBuf\n    angles: PydanticTransBuf\n    font_name: str\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticTransBuf","title":"<code>PydanticTransBuf</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model for a transform buffer union type.</p> <p>Can represent either a buffer or a transform chain, discriminated by the type field.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticTransBuf(BaseModel):\n    \"\"\"Pydantic model for a transform buffer union type.\n\n    Can represent either a buffer or a transform chain, discriminated by the type field.\n    \"\"\"\n\n    type: Literal[\"buffer\", \"transform_chain\"]\n    transBuf: PydanticBuffer | PydanticTransformChain\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticTransformChain","title":"<code>PydanticTransformChain</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a chain of transformations.</p> <p>Contains a dictionary representing the transformation chain configuration.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticTransformChain(BaseModel):\n    \"\"\"Pydantic model representing a chain of transformations.\n\n    Contains a dictionary representing the transformation chain configuration.\n    \"\"\"\n\n    transform_chain: dict[str, Any]\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticViewport","title":"<code>PydanticViewport</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model representing a viewport region.</p> <p>Defines a rectangular viewing area within the canvas.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticViewport(BaseModel):\n    \"\"\"Pydantic model representing a viewport region.\n\n    Defines a rectangular viewing area within the canvas.\n    \"\"\"\n\n    uuid: str\n    x: int\n    y: int\n    width: int\n    height: int\n</code></pre>"},{"location":"api/gsp_pydantic/#gsp_pydantic.types.pydantic_types.PydanticVisual","title":"<code>PydanticVisual</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Pydantic model for a visual element union type.</p> <p>Discriminated union that can represent any of the visual element types, distinguished by the type field.</p> Source code in <code>src/gsp_pydantic/types/pydantic_types.py</code> <pre><code>class PydanticVisual(BaseModel):\n    \"\"\"Pydantic model for a visual element union type.\n\n    Discriminated union that can represent any of the visual element types,\n    distinguished by the type field.\n    \"\"\"\n\n    type: Literal[\"markers\", \"paths\", \"pixels\", \"points\", \"segments\", \"texts\"]\n    visual: PydanticMarkers | PydanticPaths | PydanticPixels | PydanticPoints | PydanticSegments | PydanticTexts\n</code></pre>"}]}